/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/datatables-checkboxes-jquery/datatables.checkboxes.js":
/*!********************************************************************!*\
  !*** ./libs/datatables-checkboxes-jquery/datatables.checkboxes.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery_datatables_checkboxes_js_dataTables_checkboxes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery-datatables-checkboxes/js/dataTables.checkboxes */ "./node_modules/jquery-datatables-checkboxes/js/dataTables.checkboxes.js");
/* harmony import */ var jquery_datatables_checkboxes_js_dataTables_checkboxes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_datatables_checkboxes_js_dataTables_checkboxes__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/jquery-datatables-checkboxes/js/dataTables.checkboxes.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jquery-datatables-checkboxes/js/dataTables.checkboxes.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * jQuery DataTables Checkboxes (https://www.gyrocode.com/projects/jquery-datatables-checkboxes/)\r\n * Checkboxes extension for jQuery DataTables\r\n *\r\n * @version     1.2.13\r\n * @author      Gyrocode LLC (https://www.gyrocode.com)\r\n * @copyright   (c) Gyrocode LLC\r\n * @license     MIT\r\n */\r\n(function( factory ){\r\n/* eslint-disable */\r\n   if ( true ) {\r\n      // AMD\r\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\r\n         return factory( $, window, document );\r\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n   }\r\n   else {}\r\n/* eslint-enable */\r\n}(function( $, window, document ) {\r\n   'use strict';\r\n   var DataTable = $.fn.dataTable;\r\n\r\n\r\n   /**\r\n   * Checkboxes is an extension for the jQuery DataTables library that provides\r\n   * universal solution for working with checkboxes in a table.\r\n   *\r\n   *  @class\r\n   *  @param {object} settings DataTables settings object for the host table\r\n   *  @requires jQuery 1.7+\r\n   *  @requires DataTables 1.10.8+\r\n   *\r\n   *  @example\r\n   *     $('#example').DataTable({\r\n   *        'columnDefs': [\r\n   *           {\r\n   *              'targets': 0,\r\n   *              'checkboxes': true\r\n   *           }\r\n   *        ]\r\n   *     });\r\n   */\r\n   var Checkboxes = function ( settings ) {\r\n      // Sanity check that we are using DataTables 1.10.8 or newer\r\n      if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.8' ) ) {\r\n         throw 'DataTables Checkboxes requires DataTables 1.10.8 or newer';\r\n      }\r\n\r\n      this.s = {\r\n         dt: new DataTable.Api( settings ),\r\n         columns: [],\r\n         data: {},\r\n         dataDisabled: {},\r\n         ignoreSelect: false\r\n      };\r\n\r\n      // Get settings object\r\n      this.s.ctx = this.s.dt.settings()[0];\r\n\r\n      // Check if checkboxes have already been initialised on this table\r\n      if ( this.s.ctx.checkboxes ) {\r\n         return;\r\n      }\r\n\r\n      settings.checkboxes = this;\r\n\r\n      this._constructor();\r\n   };\r\n\r\n\r\n   Checkboxes.prototype = {\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n      * Constructor\r\n      */\r\n\r\n      /**\r\n      * Initialise the Checkboxes instance\r\n      *\r\n      * @private\r\n      */\r\n      _constructor: function ()\r\n      {\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n         var hasCheckboxes = false;\r\n         var hasCheckboxesSelectRow = false;\r\n\r\n         for(var i = 0; i < ctx.aoColumns.length; i++){\r\n            if (ctx.aoColumns[i].checkboxes){\r\n               var $colHeader = $(dt.column(i).header());\r\n\r\n               //\r\n               // INITIALIZATION\r\n               //\r\n\r\n               hasCheckboxes = true;\r\n\r\n               if(!$.isPlainObject(ctx.aoColumns[i].checkboxes)){\r\n                  ctx.aoColumns[i].checkboxes = {};\r\n               }\r\n\r\n               ctx.aoColumns[i].checkboxes = $.extend(\r\n                  {}, Checkboxes.defaults, ctx.aoColumns[i].checkboxes\r\n               );\r\n\r\n               //\r\n               // OPTIONS\r\n               //\r\n\r\n               var colOptions = {\r\n                  'searchable': false,\r\n                  'orderable': false\r\n               };\r\n\r\n               if(ctx.aoColumns[i].sClass === ''){\r\n                  colOptions['className'] = 'dt-checkboxes-cell';\r\n               } else {\r\n                  colOptions['className'] = ctx.aoColumns[i].sClass + ' dt-checkboxes-cell';\r\n               }\r\n\r\n               if(ctx.aoColumns[i].sWidthOrig === null){\r\n                  colOptions['width'] = '1%';\r\n               }\r\n\r\n               if(ctx.aoColumns[i].mRender === null){\r\n                  colOptions['render'] = function(){\r\n                     return '<input type=\"checkbox\" class=\"dt-checkboxes\" autocomplete=\"off\">';\r\n                  };\r\n               }\r\n\r\n               DataTable.ext.internal._fnColumnOptions(ctx, i, colOptions);\r\n\r\n\r\n               // WORKAROUND: Remove \"sorting\" class\r\n               $colHeader.removeClass('sorting');\r\n\r\n               // WORKAROUND: Detach all event handlers for this column\r\n               $colHeader.off('.dt');\r\n\r\n               // If table has data source other than Ajax\r\n               if(ctx.sAjaxSource === null){\r\n                  // WORKAROUND: Invalidate column data\r\n                  var cells = dt.cells('tr', i);\r\n                  cells.invalidate('data');\r\n\r\n                  // WORKAROUND: Add required class to existing cells\r\n                  $(cells.nodes()).addClass(colOptions['className']);\r\n               }\r\n\r\n\r\n               //\r\n               // DATA\r\n               //\r\n\r\n               // Initialize object holding data for selected checkboxes\r\n               self.s.data[i] = {};\r\n               self.s.dataDisabled[i] = {};\r\n\r\n               // Store column index for easy column selection later\r\n               self.s.columns.push(i);\r\n\r\n\r\n               //\r\n               // CLASSES\r\n               //\r\n\r\n               // If row selection is enabled for this column\r\n               if(ctx.aoColumns[i].checkboxes.selectRow){\r\n\r\n                  // If Select extension is enabled\r\n                  if(ctx._select){\r\n                     hasCheckboxesSelectRow = true;\r\n\r\n                  // Otherwise, if Select extension is not enabled\r\n                  } else {\r\n                     // Disable row selection for this column\r\n                     ctx.aoColumns[i].checkboxes.selectRow = false;\r\n                  }\r\n               }\r\n\r\n               // If \"Select all\" control is enabled\r\n               if(ctx.aoColumns[i].checkboxes.selectAll){\r\n                  // Save previous HTML content\r\n                  $colHeader.data('html', $colHeader.html());\r\n\r\n                  // If \"Select all\" control markup is provided\r\n                  if(ctx.aoColumns[i].checkboxes.selectAllRender !== null){\r\n                     var selectAllHtml = '';\r\n\r\n                     // If \"selectAllRender\" option is a function\r\n                     if($.isFunction(ctx.aoColumns[i].checkboxes.selectAllRender)){\r\n                        selectAllHtml = ctx.aoColumns[i].checkboxes.selectAllRender();\r\n\r\n                     // Otherwise, if \"selectAllRender\" option is a string\r\n                     } else if(typeof ctx.aoColumns[i].checkboxes.selectAllRender === 'string'){\r\n                        selectAllHtml = ctx.aoColumns[i].checkboxes.selectAllRender;\r\n                     }\r\n\r\n                     $colHeader\r\n                        .html(selectAllHtml)\r\n                        .addClass('dt-checkboxes-select-all')\r\n                        .attr('data-col', i);\r\n                  }\r\n               }\r\n            }\r\n         }\r\n\r\n         // If table has at least one checkbox column\r\n         if(hasCheckboxes){\r\n\r\n            // Load previous state\r\n            self.loadState();\r\n\r\n            //\r\n            // EVENT HANDLERS\r\n            //\r\n\r\n            var $table = $(dt.table().node());\r\n            var $tableBody = $(dt.table().body());\r\n            var $tableContainer = $(dt.table().container());\r\n\r\n            // If there is at least one column that has row selection enabled\r\n            if(hasCheckboxesSelectRow){\r\n               $table.addClass('dt-checkboxes-select');\r\n\r\n               // Handle event before row is selected/deselected\r\n               $table.on('user-select.dt.dtCheckboxes', function (e, dt, type, cell , originalEvent){\r\n                  self.onDataTablesUserSelect(e, dt, type, cell , originalEvent);\r\n               });\r\n\r\n               // Handle row select/deselect event\r\n               $table.on('select.dt.dtCheckboxes deselect.dt.dtCheckboxes', function(e, api, type, indexes){\r\n                  self.onDataTablesSelectDeselect(e, type, indexes);\r\n               });\r\n\r\n               // If displaying of Select extension information is enabled\r\n               if(ctx._select.info){\r\n                  // Disable Select extension information display\r\n                  dt.select.info(false);\r\n\r\n                  // Update the table information element with selected item summary\r\n                  //\r\n                  // NOTE: Needed to display correct count of selected rows\r\n                  // when using server-side processing mode\r\n                  $table.on('draw.dt.dtCheckboxes select.dt.dtCheckboxes deselect.dt.dtCheckboxes', function(){\r\n                     self.showInfoSelected();\r\n                  });\r\n               }\r\n            }\r\n\r\n            // Handle table draw event\r\n            $table.on('draw.dt.dtCheckboxes', function(e){\r\n               self.onDataTablesDraw(e);\r\n            });\r\n\r\n            // Handle checkbox click event\r\n            $tableBody.on('click.dtCheckboxes', 'input.dt-checkboxes', function(e){\r\n               self.onClick(e, this);\r\n            });\r\n\r\n            // Handle click on \"Select all\" control\r\n            $tableContainer.on('click.dtCheckboxes', 'thead th.dt-checkboxes-select-all input[type=\"checkbox\"]', function(e){\r\n               self.onClickSelectAll(e, this);\r\n            });\r\n\r\n            // Handle click on heading containing \"Select all\" control\r\n            $tableContainer.on('click.dtCheckboxes', 'thead th.dt-checkboxes-select-all', function() {\r\n               $('input[type=\"checkbox\"]', this).not(':disabled').trigger('click');\r\n            });\r\n\r\n            // If row selection is disabled\r\n            if(!hasCheckboxesSelectRow){\r\n               // Handle click on cell containing checkbox\r\n               $tableContainer.on('click.dtCheckboxes', 'tbody td.dt-checkboxes-cell', function() {\r\n                  $('input[type=\"checkbox\"]', this).not(':disabled').trigger('click');\r\n               });\r\n            }\r\n\r\n            // Handle click on label node in heading containing \"Select all\" control\r\n            // and in cell containing checkbox\r\n            $tableContainer.on('click.dtCheckboxes', 'thead th.dt-checkboxes-select-all label, tbody td.dt-checkboxes-cell label', function(e) {\r\n               // Prevent default behavior\r\n               e.preventDefault();\r\n            });\r\n\r\n            // Handle click on \"Select all\" control in floating fixed header\r\n            $(document).on('click.dtCheckboxes', '.fixedHeader-floating thead th.dt-checkboxes-select-all input[type=\"checkbox\"]', function(e){\r\n               // If FixedHeader is enabled in this instance\r\n               if(ctx._fixedHeader){\r\n                  // If header is floating in this instance\r\n                  if(ctx._fixedHeader.dom['header'].floating){\r\n                     self.onClickSelectAll(e, this);\r\n                  }\r\n               }\r\n            });\r\n\r\n            // Handle click on heading containing \"Select all\" control in floating fixed header\r\n            $(document).on('click.dtCheckboxes', '.fixedHeader-floating thead th.dt-checkboxes-select-all', function() {\r\n               // If FixedHeader is enabled in this instance\r\n               if(ctx._fixedHeader){\r\n                  // If header is floating in this instance\r\n                  if(ctx._fixedHeader.dom['header'].floating){\r\n                     $('input[type=\"checkbox\"]', this).trigger('click');\r\n                  }\r\n               }\r\n            });\r\n\r\n            // Handle table initialization event\r\n            $table.on('init.dt.dtCheckboxes', function(){\r\n               // Use delay to handle initialization event\r\n               // because certain extensions (FixedColumns) are initialized\r\n               // only when initialization event is triggered.\r\n               setTimeout(function(){\r\n                   self.onDataTablesInit();\r\n               }, 0);\r\n            });\r\n\r\n            // Handle state saving event\r\n            $table.on('stateSaveParams.dt.dtCheckboxes', function (e, settings, data) {\r\n               self.onDataTablesStateSave(e, settings, data);\r\n            });\r\n\r\n            // Handle table destroy event\r\n            $table.one('destroy.dt.dtCheckboxes', function(e, settings){\r\n               self.onDataTablesDestroy(e, settings);\r\n            });\r\n         }\r\n      },\r\n\r\n      // Handles DataTables initialization event\r\n      onDataTablesInit: function(){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If server-side processing mode is not enabled\r\n         // NOTE: Needed to avoid duplicate call to updateStateCheckboxes() in onDataTablesDraw()\r\n         if(!ctx.oFeatures.bServerSide){\r\n\r\n            // If state saving is enabled\r\n            if(ctx.oFeatures.bStateSave){\r\n               self.updateState();\r\n            }\r\n\r\n            // Handle Ajax request completion event\r\n            // NOTE: Needed to update table state\r\n            // if table is reloaded via ajax.reload() API method\r\n            $(dt.table().node()).on('xhr.dt.dtCheckboxes', function ( e, settings , json, xhr ) {\r\n               self.onDataTablesXhr(e. settings, json, xhr);\r\n            });\r\n         }\r\n      },\r\n\r\n      // Handles DataTables user initiated select event\r\n      onDataTablesUserSelect: function ( e, dt, type, cell /*, originalEvent*/ ){\r\n         var self = this;\r\n\r\n         var cellIdx = cell.index();\r\n         var rowIdx = cellIdx.row;\r\n         var colIdx = self.getSelectRowColIndex();\r\n         var cellData = dt.cell({ row: rowIdx, column: colIdx }).data();\r\n\r\n         // If checkbox in the cell cannot be checked\r\n         if(!self.isCellSelectable(colIdx, cellData)){\r\n            // Prevent row selection\r\n            e.preventDefault();\r\n         }\r\n      },\r\n\r\n      // Handles DataTables row select/deselect event\r\n      onDataTablesSelectDeselect: function(e, type, indexes){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n\r\n         if(self.s.ignoreSelect){ return; }\r\n\r\n         if(type === 'row'){\r\n            // Get index of the first column that has checkbox and row selection enabled\r\n            var colIdx = self.getSelectRowColIndex();\r\n            if(colIdx !== null){\r\n               var cells = dt.cells(indexes, colIdx);\r\n\r\n               self.updateData(cells, colIdx, (e.type === 'select') ? true : false);\r\n               self.updateCheckbox(cells, colIdx, (e.type === 'select') ? true : false);\r\n               self.updateSelectAll(colIdx);\r\n            }\r\n         }\r\n      },\r\n\r\n      // Handles DataTables state save event\r\n      onDataTablesStateSave: function (e, settings, data) {\r\n         var self = this;\r\n         var ctx = self.s.ctx;\r\n\r\n         // For every column where checkboxes are enabled\r\n         $.each(self.s.columns, function(index, colIdx){\r\n            // If checkbox state saving is enabled\r\n            if(ctx.aoColumns[colIdx].checkboxes.stateSave){\r\n               // If checkboxes state hasn't been saved before\r\n               if(!Object.prototype.hasOwnProperty.call(data, 'checkboxes')){\r\n                  // Initialize array to save checkboxes state for each column\r\n                  data.checkboxes = [];\r\n               }\r\n\r\n               // Save checkboxes state\r\n               data.checkboxes[colIdx] = self.s.data[colIdx];\r\n            }\r\n         });\r\n      },\r\n\r\n      // Handles DataTables destroy event\r\n      onDataTablesDestroy: function(){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n\r\n         // Get table elements\r\n         var $table = $(dt.table().node());\r\n         var $tableBody = $(dt.table().body());\r\n         var $tableContainer = $(dt.table().container());\r\n\r\n         // Detach event handlers\r\n         $(document).off('click.dtCheckboxes');\r\n         $tableContainer.off('.dtCheckboxes');\r\n         $tableBody.off('.dtCheckboxes');\r\n         $table.off('.dtCheckboxes');\r\n\r\n         // Clear data\r\n         //\r\n         // NOTE: Needed only to reduce memory footprint\r\n         // in case user saves instance of DataTable object.\r\n         self.s.data = {};\r\n         self.s.dataDisabled = {};\r\n\r\n         // Remove added elements\r\n         $('.dt-checkboxes-select-all', $table).each(function(index, el){\r\n            $(el)\r\n               .html($(el).data('html'))\r\n               .removeClass('dt-checkboxes-select-all');\r\n         });\r\n      },\r\n\r\n      // Handles DataTables draw event\r\n      onDataTablesDraw: function(){\r\n         var self = this;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If server-side processing is enabled\r\n         // or deferred render is enabled\r\n         //\r\n         // TODO: it's not optimal to update state of checkboxes\r\n         // for already created rows in deferred rendering mode\r\n         if(ctx.oFeatures.bServerSide || ctx.oFeatures.bDeferRender){\r\n            self.updateStateCheckboxes({ page: 'current', search: 'none' });\r\n         }\r\n\r\n         $.each(self.s.columns, function(index, colIdx){\r\n            self.updateSelectAll(colIdx);\r\n         });\r\n      },\r\n\r\n      // Handles DataTables Ajax request completion event\r\n      onDataTablesXhr: function( /* e, settings , json, xhr */ ){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // Get table elements\r\n         var $table = $(dt.table().node());\r\n\r\n         // For every column where checkboxes are enabled\r\n         $.each(self.s.columns, function(index, colIdx){\r\n            // Reset data\r\n            self.s.data[colIdx] = {};\r\n            self.s.dataDisabled[colIdx] = {};\r\n         });\r\n\r\n         // If state saving is enabled\r\n         if(ctx.oFeatures.bStateSave){\r\n            // Load previous state\r\n            self.loadState();\r\n\r\n            // Update table state on next redraw\r\n            $table.one('draw.dt.dtCheckboxes', function(){\r\n               self.updateState();\r\n            });\r\n         }\r\n      },\r\n\r\n      // Updates array holding data for selected checkboxes\r\n      updateData: function(cells, colIdx, isSelected){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If Checkboxes extension is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes){\r\n            var cellsData = cells.data();\r\n            cellsData.each(function(cellData){\r\n               // If checkbox is checked\r\n               if(isSelected){\r\n                  ctx.checkboxes.s.data[colIdx][cellData] = 1;\r\n\r\n               // Otherwise, if checkbox is not checked\r\n               } else {\r\n                  delete ctx.checkboxes.s.data[colIdx][cellData];\r\n               }\r\n            });\r\n\r\n            // If state saving is enabled\r\n            if(ctx.oFeatures.bStateSave){\r\n               // If checkbox state saving is enabled\r\n               if(ctx.aoColumns[colIdx].checkboxes.stateSave){\r\n                  // Save state\r\n                  dt.state.save();\r\n               }\r\n            }\r\n         }\r\n      },\r\n\r\n      // Updates row selection\r\n      updateSelect: function(selector, isSelected){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If Select extension is enabled\r\n         if(ctx._select){\r\n            // Disable select event hanlder temporarily\r\n            self.s.ignoreSelect = true;\r\n\r\n            if(isSelected){\r\n               dt.rows(selector).select();\r\n            } else {\r\n               dt.rows(selector).deselect();\r\n            }\r\n\r\n            // Re-enable select event handler\r\n            self.s.ignoreSelect = false;\r\n         }\r\n      },\r\n\r\n      // Updates state of single checkbox\r\n      updateCheckbox: function(cells, colIdx, isSelected){\r\n         var self = this;\r\n         var ctx = self.s.ctx;\r\n\r\n         var cellNodes = cells.nodes();\r\n         if(cellNodes.length){\r\n            $('input.dt-checkboxes', cellNodes).not(':disabled').prop('checked', isSelected);\r\n\r\n            // If selectCallback is a function\r\n            if($.isFunction(ctx.aoColumns[colIdx].checkboxes.selectCallback)){\r\n               ctx.aoColumns[colIdx].checkboxes.selectCallback(cellNodes, isSelected);\r\n            }\r\n         }\r\n      },\r\n\r\n      // Update table state\r\n      updateState: function(){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         self.updateStateCheckboxes({ page: 'all', search: 'none' });\r\n\r\n         // If FixedColumns extension is enabled\r\n         if(ctx._oFixedColumns){\r\n            // Use delay to let FixedColumns construct the header\r\n            // before we update the \"Select all\" checkbox\r\n            setTimeout(function(){\r\n               // For every column where checkboxes are enabled\r\n               $.each(self.s.columns, function(index, colIdx){\r\n                  self.updateSelectAll(colIdx);\r\n               });\r\n            }, 0);\r\n         }\r\n      },\r\n\r\n      // Updates state of multiple checkboxes\r\n      updateStateCheckboxes: function(opts){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // Enumerate all cells\r\n         dt.cells('tr', self.s.columns, opts).every(function(rowIdx, colIdx){\r\n            // Get cell data\r\n            var cellData = this.data();\r\n\r\n            // Determine if checkbox in the cell can be selected\r\n            var isCellSelectable = self.isCellSelectable(colIdx, cellData);\r\n\r\n            // If checkbox is checked\r\n            if(\r\n               Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data, colIdx)\r\n               && Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data[colIdx], cellData)\r\n            ) {\r\n               // If row selection is enabled\r\n               // and checkbox can be checked\r\n               if(ctx.aoColumns[colIdx].checkboxes.selectRow && isCellSelectable){\r\n                  self.updateSelect(rowIdx, true);\r\n               }\r\n\r\n               self.updateCheckbox(this, colIdx, true);\r\n            }\r\n\r\n            // If checkbox is disabled\r\n            if(!isCellSelectable){\r\n               $('input.dt-checkboxes', this.node()).prop('disabled', true);\r\n            }\r\n         });\r\n      },\r\n\r\n      // Handles checkbox click event\r\n      onClick: function(e, ctrl){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         var cellSelector;\r\n\r\n         // Get cell\r\n         var $cell = $(ctrl).closest('td');\r\n\r\n         // If cell is in a fixed column using FixedColumns extension\r\n         if($cell.parents('.DTFC_Cloned').length){\r\n            cellSelector = dt.fixedColumns().cellIndex($cell);\r\n\r\n         } else {\r\n            cellSelector = $cell;\r\n         }\r\n\r\n         var cell    = dt.cell(cellSelector);\r\n         var cellIdx = cell.index();\r\n         var colIdx  = cellIdx.column;\r\n         var rowIdx  = cellIdx.row;\r\n\r\n         // If row selection is not enabled\r\n         // NOTE: if row selection is enabled, checkbox selection/deselection\r\n         // would be handled by onDataTablesSelectDeselect event handler instead\r\n         if(!ctx.aoColumns[colIdx].checkboxes.selectRow){\r\n            cell.checkboxes.select(ctrl.checked);\r\n\r\n            // Prevent click event from propagating to parent\r\n            e.stopPropagation();\r\n\r\n         } else {\r\n\r\n            // If Select extension is enabled\r\n            if(ctx._select){\r\n               // If style is set to \"os\"\r\n               if(ctx._select.style === 'os'){\r\n\r\n                  // WORKAROUND:\r\n                  // See https://github.com/gyrocode/jquery-datatables-checkboxes/issues/128\r\n\r\n                  // Prevent click event from propagating to parent\r\n                  e.stopPropagation();\r\n\r\n                  // Select/deselect individual row\r\n                  cell.checkboxes.select(ctrl.checked);\r\n\r\n               // Otherwise, if style is set to other than \"os\"\r\n               } else {\r\n                  // WORKAROUND:\r\n                  // Select extension may keep the row selected\r\n                  // when checkbox is unchecked with SHIFT key.\r\n                  //\r\n                  // We need to update the state of the checkbox AFTER handling\r\n                  // select/deselect event from Select extension.\r\n                  //\r\n                  // Call to setTimeout is needed to let select/deselect event handler\r\n                  // update the data first.\r\n                  setTimeout(function(){\r\n                     // Get cell data\r\n                     var cellData = cell.data();\r\n\r\n                     // Determine whether data is in the list\r\n                     var hasData = (\r\n                        Object.prototype.hasOwnProperty.call(self.s.data, colIdx)\r\n                        && Object.prototype.hasOwnProperty.call(self.s.data[colIdx], cellData)\r\n                     );\r\n\r\n                     // If state of the checkbox needs to be updated\r\n                     if(hasData !== ctrl.checked){\r\n                        self.updateCheckbox(cell, colIdx, hasData);\r\n                        self.updateSelectAll(colIdx);\r\n                     }\r\n                  }, 0);\r\n               }\r\n            }\r\n         }\r\n      },\r\n\r\n      // Handles checkbox click event\r\n      onClickSelectAll: function(e, ctrl){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // Calculate column index\r\n         var colIdx = null;\r\n         var $th = $(ctrl).closest('th');\r\n\r\n         // If column is fixed using FixedColumns extension\r\n         if($th.parents('.DTFC_Cloned').length){\r\n            var cellIdx = dt.fixedColumns().cellIndex($th);\r\n            colIdx = cellIdx.column;\r\n         } else {\r\n            colIdx = dt.column($th).index();\r\n         }\r\n\r\n         // Indicate that state of \"Select all\" control has been changed\r\n         $(ctrl).data('is-changed', true);\r\n\r\n         dt.column(colIdx, {\r\n            page: (\r\n               (ctx.aoColumns[colIdx].checkboxes && ctx.aoColumns[colIdx].checkboxes.selectAllPages)\r\n                  ? 'all'\r\n                  : 'current'\r\n            ),\r\n            search: 'applied'\r\n         }).checkboxes.select(ctrl.checked);\r\n\r\n         // Prevent click event from propagating to parent\r\n         e.stopPropagation();\r\n      },\r\n\r\n      // Loads previosly saved sate\r\n      loadState: function () {\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If state saving is enabled\r\n         if(ctx.oFeatures.bStateSave){\r\n            // Retrieve stored state\r\n            var state = dt.state.loaded();\r\n\r\n            // For every column where checkboxes are enabled\r\n            $.each(self.s.columns, function(index, colIdx){\r\n               // If state is loaded and contains data for this column\r\n               if(state && state.checkboxes && state.checkboxes.hasOwnProperty(colIdx)){\r\n                  // If checkbox state saving is enabled\r\n                  if(ctx.aoColumns[colIdx].checkboxes.stateSave){\r\n                     // Load previous state\r\n                     self.s.data[colIdx] = state.checkboxes[colIdx];\r\n                  }\r\n               }\r\n            });\r\n         }\r\n      },\r\n\r\n      // Updates state of the \"Select all\" controls\r\n      updateSelectAll: function(colIdx){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If Checkboxes extension is enabled for this column\r\n         // and \"Select all\" control is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes && ctx.aoColumns[colIdx].checkboxes.selectAll){\r\n            var cells = dt.cells('tr', colIdx, {\r\n               page: (\r\n                  (ctx.aoColumns[colIdx].checkboxes.selectAllPages)\r\n                     ? 'all'\r\n                     : 'current'\r\n               ),\r\n               search: 'applied'\r\n            });\r\n\r\n            var $tableContainer = dt.table().container();\r\n            var $checkboxesSelectAll = $('.dt-checkboxes-select-all[data-col=\"' + colIdx + '\"] input[type=\"checkbox\"]', $tableContainer);\r\n\r\n            var countChecked = 0;\r\n            var countDisabled = 0;\r\n            var cellsData = cells.data();\r\n            $.each(cellsData, function(index, cellData){\r\n               // If checkbox is not disabled\r\n               if(self.isCellSelectable(colIdx, cellData)){\r\n                  if(\r\n                     Object.prototype.hasOwnProperty.call(self.s.data, colIdx)\r\n                     && Object.prototype.hasOwnProperty.call(self.s.data[colIdx], cellData)\r\n                  ) {\r\n                     countChecked++;\r\n                  }\r\n\r\n               // Otherwise, if checkbox is disabled\r\n               } else {\r\n                  countDisabled++;\r\n               }\r\n            });\r\n\r\n            // If FixedHeader is enabled in this instance\r\n            if(ctx._fixedHeader){\r\n               // If header is floating in this instance\r\n               if(ctx._fixedHeader.dom['header'].floating){\r\n                  $checkboxesSelectAll = $('.fixedHeader-floating .dt-checkboxes-select-all[data-col=\"' + colIdx + '\"] input[type=\"checkbox\"]');\r\n               }\r\n            }\r\n\r\n            var isSelected;\r\n            var isIndeterminate;\r\n\r\n            // If none of the checkboxes are checked\r\n            if (countChecked === 0){\r\n               isSelected      = false;\r\n               isIndeterminate = false;\r\n\r\n            // If all of the checkboxes are checked\r\n            } else if ((countChecked + countDisabled) === cellsData.length){\r\n               isSelected      = true;\r\n               isIndeterminate = false;\r\n\r\n            // If some of the checkboxes are checked\r\n            } else {\r\n               isSelected      = true;\r\n               isIndeterminate = true;\r\n            }\r\n\r\n            var isChanged          = $checkboxesSelectAll.data('is-changed');\r\n            var isSelectedNow      = $checkboxesSelectAll.prop('checked');\r\n            var isIndeterminateNow = $checkboxesSelectAll.prop('indeterminate');\r\n\r\n            // If state of \"Select all\" control has been changed\r\n            if(isChanged || isSelectedNow !== isSelected || isIndeterminateNow !== isIndeterminate){\r\n               // Reset \"Select all\" control state flag\r\n               $checkboxesSelectAll.data('is-changed', false);\r\n\r\n               $checkboxesSelectAll.prop({\r\n                  // NOTE: If checkbox has indeterminate state,\r\n                  // \"checked\" property must be set to false.\r\n                  'checked': isIndeterminate ? false : isSelected,\r\n                  'indeterminate': isIndeterminate\r\n               });\r\n\r\n               // If selectAllCallback is a function\r\n               if($.isFunction(ctx.aoColumns[colIdx].checkboxes.selectAllCallback)){\r\n                  ctx.aoColumns[colIdx].checkboxes.selectAllCallback($checkboxesSelectAll.closest('th').get(0), isSelected, isIndeterminate);\r\n               }\r\n            }\r\n         }\r\n      },\r\n\r\n      // Updates the information element of the DataTable showing information about the\r\n      // items selected. Based on info() method of Select extension.\r\n      showInfoSelected: function(){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         if ( ! ctx.aanFeatures.i ) {\r\n            return;\r\n         }\r\n\r\n         // Get index of the first column that has checkbox and row selection enabled\r\n         var colIdx = self.getSelectRowColIndex();\r\n\r\n         // If there is a column that has checkbox and row selection enabled\r\n         if(colIdx !== null){\r\n            // Count number of selected rows\r\n            var countRows = 0;\r\n            for (var cellData in ctx.checkboxes.s.data[colIdx]){\r\n               if(\r\n                  Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data, colIdx)\r\n                  && Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data[colIdx], cellData)\r\n               ) {\r\n                  countRows++;\r\n               }\r\n            }\r\n\r\n            var add = function($el, name, num){\r\n               $el.append( $('<span class=\"select-item\"/>').append( dt.i18n(\r\n                  'select.'+name+'s',\r\n                  { _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },\r\n                  num\r\n               ) ) );\r\n            };\r\n\r\n            // Internal knowledge of DataTables to loop over all information elements\r\n            $.each( ctx.aanFeatures.i, function ( i, el ) {\r\n               var $el = $(el);\r\n\r\n               var $output  = $('<span class=\"select-info\"/>');\r\n               add($output, 'row', countRows);\r\n\r\n               var $existing = $el.children('span.select-info');\r\n               if($existing.length){\r\n                  $existing.remove();\r\n               }\r\n\r\n               if($output.text() !== ''){\r\n                  $el.append($output);\r\n               }\r\n            });\r\n         }\r\n      },\r\n\r\n      // Determines whether checkbox in the cell can be checked\r\n      isCellSelectable: function(colIdx, cellData){\r\n         var self = this;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If data is in the list of disabled elements\r\n         if(\r\n            Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.dataDisabled, colIdx)\r\n            && Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.dataDisabled[colIdx], cellData)\r\n         ) {\r\n            return false;\r\n\r\n         // Otherwise, if checkbox can be selected\r\n         } else {\r\n            return true;\r\n         }\r\n      },\r\n\r\n      // Gets cell index\r\n      getCellIndex: function(cell){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If FixedColumns extension is available\r\n         if(ctx._oFixedColumns){\r\n            return dt.fixedColumns().cellIndex(cell);\r\n\r\n         } else {\r\n            return dt.cell(cell).index();\r\n         }\r\n      },\r\n\r\n      // Gets index of the first column that has checkbox and row selection enabled\r\n      getSelectRowColIndex: function(){\r\n         var self = this;\r\n         var ctx = self.s.ctx;\r\n\r\n         var colIdx = null;\r\n\r\n         for(var i = 0; i < ctx.aoColumns.length; i++){\r\n            // If Checkboxes extension is enabled\r\n            // and row selection is enabled for this column\r\n            if(ctx.aoColumns[i].checkboxes && ctx.aoColumns[i].checkboxes.selectRow){\r\n               colIdx = i;\r\n               break;\r\n            }\r\n         }\r\n\r\n         return colIdx;\r\n      },\r\n\r\n      // Updates fixed column if FixedColumns extension is enabled\r\n      // and given column is inside a fixed column\r\n      updateFixedColumn: function(colIdx){\r\n         var self = this;\r\n         var dt = self.s.dt;\r\n         var ctx = self.s.ctx;\r\n\r\n         // If FixedColumns extension is enabled\r\n         if(ctx._oFixedColumns){\r\n            var leftCols = ctx._oFixedColumns.s.iLeftColumns;\r\n            var rightCols = ctx.aoColumns.length - ctx._oFixedColumns.s.iRightColumns - 1;\r\n\r\n            if (colIdx < leftCols || colIdx > rightCols){\r\n               // Update the data shown in the fixed column\r\n               dt.fixedColumns().update();\r\n\r\n               // Use delay to let FixedColumns construct the header\r\n               // before we update the \"Select all\" checkbox\r\n               setTimeout(function(){\r\n                  // For every column where checkboxes are enabled\r\n                  $.each(self.s.columns, function(index, colIdx){\r\n                     self.updateSelectAll(colIdx);\r\n                  });\r\n               }, 0);\r\n            }\r\n         }\r\n      }\r\n   };\r\n\r\n\r\n   /**\r\n   * Checkboxes default settings for initialisation\r\n   *\r\n   * @namespace\r\n   * @name Checkboxes.defaults\r\n   * @static\r\n   */\r\n   Checkboxes.defaults = {\r\n      /**\r\n      * Enable / disable checkbox state loading/saving if state saving is enabled globally\r\n      *\r\n      * @type {Boolean}\r\n      * @default `true`\r\n      */\r\n      stateSave: true,\r\n\r\n      /**\r\n      * Enable / disable row selection\r\n      *\r\n      * @type {Boolean}\r\n      * @default `false`\r\n      */\r\n      selectRow: false,\r\n\r\n      /**\r\n      * Enable / disable \"select all\" control in the header\r\n      *\r\n      * @type {Boolean}\r\n      * @default `true`\r\n      */\r\n      selectAll: true,\r\n\r\n      /**\r\n      * Enable / disable ability to select checkboxes from all pages\r\n      *\r\n      * @type {Boolean}\r\n      * @default `true`\r\n      */\r\n      selectAllPages: true,\r\n\r\n      /**\r\n      * Checkbox select/deselect callback\r\n      *\r\n      * @type {Function}\r\n      * @default  `null`\r\n      */\r\n      selectCallback: null,\r\n\r\n      /**\r\n      * \"Select all\" control select/deselect callback\r\n      *\r\n      * @type {Function}\r\n      * @default  `null`\r\n      */\r\n      selectAllCallback: null,\r\n\r\n      /**\r\n      * \"Select all\" control markup\r\n      *\r\n      * @type {mixed}\r\n      * @default `<input type=\"checkbox\">`\r\n      */\r\n      selectAllRender: '<input type=\"checkbox\" autocomplete=\"off\">'\r\n   };\r\n\r\n\r\n   /*\r\n   * API\r\n   */\r\n   var Api = $.fn.dataTable.Api;\r\n\r\n   // Doesn't do anything - work around for a bug in DT... Not documented\r\n   Api.register( 'checkboxes()', function () {\r\n      return this;\r\n   } );\r\n\r\n   Api.registerPlural( 'columns().checkboxes.select()', 'column().checkboxes.select()', function ( state ) {\r\n      if(typeof state === 'undefined'){ state = true; }\r\n\r\n      return this.iterator( 'column-rows', function ( ctx, colIdx, i, j, rowsIdx ) {\r\n         // If Checkboxes extension is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes){\r\n            // Prepare a list of all cells\r\n            var selector = [];\r\n            $.each(rowsIdx, function(index, rowIdx){\r\n               selector.push({ row: rowIdx, column: colIdx });\r\n            });\r\n\r\n            var cells = this.cells(selector);\r\n            var cellsData = cells.data();\r\n\r\n            // Prepare a list of cells that contain checkboxes that can be selected\r\n            var rowsSelectableIdx = [];\r\n            selector = [];\r\n            $.each(cellsData, function(index, cellData){\r\n               // If checkbox in the cell can be selected\r\n               if(ctx.checkboxes.isCellSelectable(colIdx, cellData)){\r\n                  selector.push({ row: rowsIdx[index], column: colIdx });\r\n                  rowsSelectableIdx.push(rowsIdx[index]);\r\n               }\r\n            });\r\n\r\n            cells = this.cells(selector);\r\n\r\n            ctx.checkboxes.updateData(cells, colIdx, state);\r\n\r\n            // If row selection is enabled\r\n            if(ctx.aoColumns[colIdx].checkboxes.selectRow){\r\n               ctx.checkboxes.updateSelect(rowsSelectableIdx, state);\r\n            }\r\n\r\n            ctx.checkboxes.updateCheckbox(cells, colIdx, state);\r\n\r\n            ctx.checkboxes.updateSelectAll(colIdx);\r\n\r\n            ctx.checkboxes.updateFixedColumn(colIdx);\r\n         }\r\n      }, 1 );\r\n   } );\r\n\r\n   Api.registerPlural( 'cells().checkboxes.select()', 'cell().checkboxes.select()', function ( state ) {\r\n      if(typeof state === 'undefined'){ state = true; }\r\n\r\n      return this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\r\n         // If Checkboxes extension is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes){\r\n            var cells = this.cells([{ row: rowIdx, column: colIdx }]);\r\n            var cellData = this.cell({ row: rowIdx, column: colIdx }).data();\r\n\r\n            // If checkbox in the cell can be selected\r\n            if(ctx.checkboxes.isCellSelectable(colIdx, cellData)){\r\n               ctx.checkboxes.updateData(cells, colIdx, state);\r\n\r\n               // If row selection is enabled\r\n               if(ctx.aoColumns[colIdx].checkboxes.selectRow){\r\n                  ctx.checkboxes.updateSelect(rowIdx, state);\r\n               }\r\n\r\n               ctx.checkboxes.updateCheckbox(cells, colIdx, state);\r\n\r\n               ctx.checkboxes.updateSelectAll(colIdx);\r\n\r\n               ctx.checkboxes.updateFixedColumn(colIdx);\r\n            }\r\n         }\r\n      }, 1 );\r\n   } );\r\n\r\n   Api.registerPlural( 'cells().checkboxes.enable()', 'cell().checkboxes.enable()', function ( state ) {\r\n      if(typeof state === 'undefined'){ state = true; }\r\n\r\n      return this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\r\n         // If Checkboxes extension is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes){\r\n            var cell = this.cell({ row: rowIdx, column: colIdx });\r\n\r\n            // Get cell data\r\n            var cellData = cell.data();\r\n\r\n            // If checkbox should be enabled\r\n            if(state){\r\n               delete ctx.checkboxes.s.dataDisabled[colIdx][cellData];\r\n\r\n            // Otherwise, if checkbox should be disabled\r\n            } else {\r\n               ctx.checkboxes.s.dataDisabled[colIdx][cellData] = 1;\r\n            }\r\n\r\n            // Determine if cell node is available\r\n            // (deferRender is not enabled or cell has been already created)\r\n            var cellNode = cell.node();\r\n            if(cellNode){\r\n               $('input.dt-checkboxes', cellNode).prop('disabled', !state);\r\n            }\r\n\r\n            // If row selection is enabled\r\n            // and checkbox can be checked\r\n            if(ctx.aoColumns[colIdx].checkboxes.selectRow){\r\n               // If data is in the list\r\n               if(\r\n                  Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data, colIdx)\r\n                  && Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data[colIdx], cellData)\r\n               ) {\r\n                  // Update selection based on current state:\r\n                  // if checkbox is enabled then select row;\r\n                  // otherwise, deselect row\r\n                  ctx.checkboxes.updateSelect(rowIdx, state);\r\n               }\r\n            }\r\n         }\r\n      }, 1 );\r\n   } );\r\n\r\n   Api.registerPlural( 'cells().checkboxes.disable()', 'cell().checkboxes.disable()', function ( state ) {\r\n      if(typeof state === 'undefined'){ state = true; }\r\n      return this.checkboxes.enable(!state);\r\n   } );\r\n\r\n   Api.registerPlural( 'columns().checkboxes.deselect()', 'column().checkboxes.deselect()', function ( state ) {\r\n      if(typeof state === 'undefined'){ state = true; }\r\n      return this.checkboxes.select(!state);\r\n   } );\r\n\r\n   Api.registerPlural( 'cells().checkboxes.deselect()', 'cell().checkboxes.deselect()', function ( state ) {\r\n      if(typeof state === 'undefined'){ state = true; }\r\n      return this.checkboxes.select(!state);\r\n   } );\r\n\r\n   Api.registerPlural( 'columns().checkboxes.deselectAll()', 'column().checkboxes.deselectAll()', function () {\r\n      return this.iterator( 'column', function (ctx, colIdx){\r\n         // If Checkboxes extension is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes){\r\n            ctx.checkboxes.s.data[colIdx] = {};\r\n\r\n            this.column(colIdx).checkboxes.select(false);\r\n         }\r\n      }, 1 );\r\n   } );\r\n\r\n   Api.registerPlural( 'columns().checkboxes.selected()', 'column().checkboxes.selected()', function () {\r\n      return this.iterator( 'column-rows', function ( ctx, colIdx, i, j, rowsIdx ) {\r\n\r\n         // If Checkboxes extension is enabled for this column\r\n         if(ctx.aoColumns[colIdx].checkboxes){\r\n            var data = [];\r\n\r\n            // If server-side processing mode is enabled\r\n            if(ctx.oFeatures.bServerSide){\r\n               $.each(ctx.checkboxes.s.data[colIdx], function(cellData){\r\n                  // If checkbox in the cell can be checked\r\n                  if(ctx.checkboxes.isCellSelectable(colIdx, cellData)){\r\n                     data.push(cellData);\r\n                  }\r\n               });\r\n\r\n            // Otherwise, if server-side processing mode is not enabled\r\n            } else {\r\n               // Prepare a list of all cells\r\n               var selector = [];\r\n               $.each(rowsIdx, function(index, rowIdx){\r\n                  selector.push({ row: rowIdx, column: colIdx });\r\n               });\r\n\r\n               // Get all cells data\r\n               var cells = this.cells(selector);\r\n               var cellsData = cells.data();\r\n\r\n               // Enumerate all cells data\r\n               $.each(cellsData, function(index, cellData){\r\n                  // If checkbox is checked\r\n                  if(\r\n                     Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data, colIdx)\r\n                     && Object.prototype.hasOwnProperty.call(ctx.checkboxes.s.data[colIdx], cellData)\r\n                  ) {\r\n                     // If checkbox in the cell can be selected\r\n                     if(ctx.checkboxes.isCellSelectable(colIdx, cellData)){\r\n                        data.push(cellData);\r\n                     }\r\n                  }\r\n               });\r\n            }\r\n\r\n            return data;\r\n\r\n         } else {\r\n            return [];\r\n         }\r\n      }, 1 );\r\n   } );\r\n\r\n\r\n   /**\r\n    * Version information\r\n    *\r\n    * @name Checkboxes.version\r\n    * @static\r\n    */\r\n   Checkboxes.version = '1.2.13';\r\n\r\n\r\n\r\n   $.fn.DataTable.Checkboxes = Checkboxes;\r\n   $.fn.dataTable.Checkboxes = Checkboxes;\r\n\r\n\r\n   // Attach a listener to the document which listens for DataTables initialisation\r\n   // events so we can automatically initialise\r\n   $(document).on( 'preInit.dt.dtCheckboxes', function (e, settings /*, json */ ) {\r\n      if ( e.namespace !== 'dt' ) {\r\n         return;\r\n      }\r\n\r\n      new Checkboxes( settings );\r\n   } );\r\n\r\n\r\n   return Checkboxes;\r\n}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5LWRhdGF0YWJsZXMtY2hlY2tib3hlcy9qcy9kYXRhVGFibGVzLmNoZWNrYm94ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQ7QUFDQSxNQUFNLGlDQUFRLENBQUMsMkNBQVEsRUFBRSwyREFBZ0IsQ0FBQyxtQ0FBRTtBQUM1QztBQUNBLE9BQU87QUFBQSxrR0FBRTtBQUNUO0FBQ0EsUUFBUSxFQWlCSjtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi9ub2RlX21vZHVsZXMvanF1ZXJ5LWRhdGF0YWJsZXMtY2hlY2tib3hlcy9qcy9kYXRhVGFibGVzLmNoZWNrYm94ZXMuanM/NDk1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogalF1ZXJ5IERhdGFUYWJsZXMgQ2hlY2tib3hlcyAoaHR0cHM6Ly93d3cuZ3lyb2NvZGUuY29tL3Byb2plY3RzL2pxdWVyeS1kYXRhdGFibGVzLWNoZWNrYm94ZXMvKVxyXG4gKiBDaGVja2JveGVzIGV4dGVuc2lvbiBmb3IgalF1ZXJ5IERhdGFUYWJsZXNcclxuICpcclxuICogQHZlcnNpb24gICAgIDEuMi4xM1xyXG4gKiBAYXV0aG9yICAgICAgR3lyb2NvZGUgTExDIChodHRwczovL3d3dy5neXJvY29kZS5jb20pXHJcbiAqIEBjb3B5cmlnaHQgICAoYykgR3lyb2NvZGUgTExDXHJcbiAqIEBsaWNlbnNlICAgICBNSVRcclxuICovXHJcbihmdW5jdGlvbiggZmFjdG9yeSApe1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4gICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuICAgICAgLy8gQU1EXHJcbiAgICAgIGRlZmluZSggWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnXSwgZnVuY3Rpb24gKCAkICkge1xyXG4gICAgICAgICByZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xyXG4gICAgICB9ICk7XHJcbiAgIH1cclxuICAgZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcclxuICAgICAgLy8gQ29tbW9uSlNcclxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xyXG4gICAgICAgICBpZiAoICEgcm9vdCApIHtcclxuICAgICAgICAgICAgcm9vdCA9IHdpbmRvdztcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgaWYgKCAhICQgfHwgISAkLmZuLmRhdGFUYWJsZSApIHtcclxuICAgICAgICAgICAgJCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jykocm9vdCwgJCkuJDtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgcmV0dXJuIGZhY3RvcnkoICQsIHJvb3QsIHJvb3QuZG9jdW1lbnQgKTtcclxuICAgICAgfTtcclxuICAgfVxyXG4gICBlbHNlIHtcclxuICAgICAgLy8gQnJvd3NlclxyXG4gICAgICBmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcclxuICAgfVxyXG4vKiBlc2xpbnQtZW5hYmxlICovXHJcbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQgKSB7XHJcbiAgICd1c2Ugc3RyaWN0JztcclxuICAgdmFyIERhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xyXG5cclxuXHJcbiAgIC8qKlxyXG4gICAqIENoZWNrYm94ZXMgaXMgYW4gZXh0ZW5zaW9uIGZvciB0aGUgalF1ZXJ5IERhdGFUYWJsZXMgbGlicmFyeSB0aGF0IHByb3ZpZGVzXHJcbiAgICogdW5pdmVyc2FsIHNvbHV0aW9uIGZvciB3b3JraW5nIHdpdGggY2hlY2tib3hlcyBpbiBhIHRhYmxlLlxyXG4gICAqXHJcbiAgICogIEBjbGFzc1xyXG4gICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXHJcbiAgICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xyXG4gICAqICBAcmVxdWlyZXMgRGF0YVRhYmxlcyAxLjEwLjgrXHJcbiAgICpcclxuICAgKiAgQGV4YW1wbGVcclxuICAgKiAgICAgJCgnI2V4YW1wbGUnKS5EYXRhVGFibGUoe1xyXG4gICAqICAgICAgICAnY29sdW1uRGVmcyc6IFtcclxuICAgKiAgICAgICAgICAge1xyXG4gICAqICAgICAgICAgICAgICAndGFyZ2V0cyc6IDAsXHJcbiAgICogICAgICAgICAgICAgICdjaGVja2JveGVzJzogdHJ1ZVxyXG4gICAqICAgICAgICAgICB9XHJcbiAgICogICAgICAgIF1cclxuICAgKiAgICAgfSk7XHJcbiAgICovXHJcbiAgIHZhciBDaGVja2JveGVzID0gZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcclxuICAgICAgLy8gU2FuaXR5IGNoZWNrIHRoYXQgd2UgYXJlIHVzaW5nIERhdGFUYWJsZXMgMS4xMC44IG9yIG5ld2VyXHJcbiAgICAgIGlmICggISBEYXRhVGFibGUudmVyc2lvbkNoZWNrIHx8ICEgRGF0YVRhYmxlLnZlcnNpb25DaGVjayggJzEuMTAuOCcgKSApIHtcclxuICAgICAgICAgdGhyb3cgJ0RhdGFUYWJsZXMgQ2hlY2tib3hlcyByZXF1aXJlcyBEYXRhVGFibGVzIDEuMTAuOCBvciBuZXdlcic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucyA9IHtcclxuICAgICAgICAgZHQ6IG5ldyBEYXRhVGFibGUuQXBpKCBzZXR0aW5ncyApLFxyXG4gICAgICAgICBjb2x1bW5zOiBbXSxcclxuICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgIGRhdGFEaXNhYmxlZDoge30sXHJcbiAgICAgICAgIGlnbm9yZVNlbGVjdDogZmFsc2VcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEdldCBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgdGhpcy5zLmN0eCA9IHRoaXMucy5kdC5zZXR0aW5ncygpWzBdO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgY2hlY2tib3hlcyBoYXZlIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCBvbiB0aGlzIHRhYmxlXHJcbiAgICAgIGlmICggdGhpcy5zLmN0eC5jaGVja2JveGVzICkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldHRpbmdzLmNoZWNrYm94ZXMgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5fY29uc3RydWN0b3IoKTtcclxuICAgfTtcclxuXHJcblxyXG4gICBDaGVja2JveGVzLnByb3RvdHlwZSA9IHtcclxuICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICAqIENvbnN0cnVjdG9yXHJcbiAgICAgICovXHJcblxyXG4gICAgICAvKipcclxuICAgICAgKiBJbml0aWFsaXNlIHRoZSBDaGVja2JveGVzIGluc3RhbmNlXHJcbiAgICAgICpcclxuICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAqL1xyXG4gICAgICBfY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpXHJcbiAgICAgIHtcclxuICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICB2YXIgZHQgPSBzZWxmLnMuZHQ7XHJcbiAgICAgICAgIHZhciBjdHggPSBzZWxmLnMuY3R4O1xyXG4gICAgICAgICB2YXIgaGFzQ2hlY2tib3hlcyA9IGZhbHNlO1xyXG4gICAgICAgICB2YXIgaGFzQ2hlY2tib3hlc1NlbGVjdFJvdyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGN0eC5hb0NvbHVtbnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBpZiAoY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzKXtcclxuICAgICAgICAgICAgICAgdmFyICRjb2xIZWFkZXIgPSAkKGR0LmNvbHVtbihpKS5oZWFkZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAvLyBJTklUSUFMSVpBVElPTlxyXG4gICAgICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgICAgaGFzQ2hlY2tib3hlcyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICBpZighJC5pc1BsYWluT2JqZWN0KGN0eC5hb0NvbHVtbnNbaV0uY2hlY2tib3hlcykpe1xyXG4gICAgICAgICAgICAgICAgICBjdHguYW9Db2x1bW5zW2ldLmNoZWNrYm94ZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzID0gJC5leHRlbmQoXHJcbiAgICAgICAgICAgICAgICAgIHt9LCBDaGVja2JveGVzLmRlZmF1bHRzLCBjdHguYW9Db2x1bW5zW2ldLmNoZWNrYm94ZXNcclxuICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgIC8vIE9QVElPTlNcclxuICAgICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgICAgIHZhciBjb2xPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAnc2VhcmNoYWJsZSc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAnb3JkZXJhYmxlJzogZmFsc2VcclxuICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbaV0uc0NsYXNzID09PSAnJyl7XHJcbiAgICAgICAgICAgICAgICAgIGNvbE9wdGlvbnNbJ2NsYXNzTmFtZSddID0gJ2R0LWNoZWNrYm94ZXMtY2VsbCc7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbE9wdGlvbnNbJ2NsYXNzTmFtZSddID0gY3R4LmFvQ29sdW1uc1tpXS5zQ2xhc3MgKyAnIGR0LWNoZWNrYm94ZXMtY2VsbCc7XHJcbiAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbaV0uc1dpZHRoT3JpZyA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgIGNvbE9wdGlvbnNbJ3dpZHRoJ10gPSAnMSUnO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICBpZihjdHguYW9Db2x1bW5zW2ldLm1SZW5kZXIgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICBjb2xPcHRpb25zWydyZW5kZXInXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiZHQtY2hlY2tib3hlc1wiIGF1dG9jb21wbGV0ZT1cIm9mZlwiPic7XHJcbiAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgIERhdGFUYWJsZS5leHQuaW50ZXJuYWwuX2ZuQ29sdW1uT3B0aW9ucyhjdHgsIGksIGNvbE9wdGlvbnMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgIC8vIFdPUktBUk9VTkQ6IFJlbW92ZSBcInNvcnRpbmdcIiBjbGFzc1xyXG4gICAgICAgICAgICAgICAkY29sSGVhZGVyLnJlbW92ZUNsYXNzKCdzb3J0aW5nJyk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBXT1JLQVJPVU5EOiBEZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICAgICAgICAkY29sSGVhZGVyLm9mZignLmR0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiB0YWJsZSBoYXMgZGF0YSBzb3VyY2Ugb3RoZXIgdGhhbiBBamF4XHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5zQWpheFNvdXJjZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFdPUktBUk9VTkQ6IEludmFsaWRhdGUgY29sdW1uIGRhdGFcclxuICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gZHQuY2VsbHMoJ3RyJywgaSk7XHJcbiAgICAgICAgICAgICAgICAgIGNlbGxzLmludmFsaWRhdGUoJ2RhdGEnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFdPUktBUk9VTkQ6IEFkZCByZXF1aXJlZCBjbGFzcyB0byBleGlzdGluZyBjZWxsc1xyXG4gICAgICAgICAgICAgICAgICAkKGNlbGxzLm5vZGVzKCkpLmFkZENsYXNzKGNvbE9wdGlvbnNbJ2NsYXNzTmFtZSddKTtcclxuICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgIC8vIERBVEFcclxuICAgICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgb2JqZWN0IGhvbGRpbmcgZGF0YSBmb3Igc2VsZWN0ZWQgY2hlY2tib3hlc1xyXG4gICAgICAgICAgICAgICBzZWxmLnMuZGF0YVtpXSA9IHt9O1xyXG4gICAgICAgICAgICAgICBzZWxmLnMuZGF0YURpc2FibGVkW2ldID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAvLyBTdG9yZSBjb2x1bW4gaW5kZXggZm9yIGVhc3kgY29sdW1uIHNlbGVjdGlvbiBsYXRlclxyXG4gICAgICAgICAgICAgICBzZWxmLnMuY29sdW1ucy5wdXNoKGkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgIC8vIENMQVNTRVNcclxuICAgICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHJvdyBzZWxlY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhpcyBjb2x1bW5cclxuICAgICAgICAgICAgICAgaWYoY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzLnNlbGVjdFJvdyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBJZiBTZWxlY3QgZXh0ZW5zaW9uIGlzIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgaWYoY3R4Ll9zZWxlY3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICBoYXNDaGVja2JveGVzU2VsZWN0Um93ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgU2VsZWN0IGV4dGVuc2lvbiBpcyBub3QgZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHJvdyBzZWxlY3Rpb24gZm9yIHRoaXMgY29sdW1uXHJcbiAgICAgICAgICAgICAgICAgICAgIGN0eC5hb0NvbHVtbnNbaV0uY2hlY2tib3hlcy5zZWxlY3RSb3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBcIlNlbGVjdCBhbGxcIiBjb250cm9sIGlzIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgaWYoY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzLnNlbGVjdEFsbCl7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFNhdmUgcHJldmlvdXMgSFRNTCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICRjb2xIZWFkZXIuZGF0YSgnaHRtbCcsICRjb2xIZWFkZXIuaHRtbCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIElmIFwiU2VsZWN0IGFsbFwiIGNvbnRyb2wgbWFya3VwIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbaV0uY2hlY2tib3hlcy5zZWxlY3RBbGxSZW5kZXIgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0QWxsSHRtbCA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgLy8gSWYgXCJzZWxlY3RBbGxSZW5kZXJcIiBvcHRpb24gaXMgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICBpZigkLmlzRnVuY3Rpb24oY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzLnNlbGVjdEFsbFJlbmRlcikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RBbGxIdG1sID0gY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzLnNlbGVjdEFsbFJlbmRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBcInNlbGVjdEFsbFJlbmRlclwiIG9wdGlvbiBpcyBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGN0eC5hb0NvbHVtbnNbaV0uY2hlY2tib3hlcy5zZWxlY3RBbGxSZW5kZXIgPT09ICdzdHJpbmcnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0QWxsSHRtbCA9IGN0eC5hb0NvbHVtbnNbaV0uY2hlY2tib3hlcy5zZWxlY3RBbGxSZW5kZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICRjb2xIZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoc2VsZWN0QWxsSHRtbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdkdC1jaGVja2JveGVzLXNlbGVjdC1hbGwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZGF0YS1jb2wnLCBpKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gSWYgdGFibGUgaGFzIGF0IGxlYXN0IG9uZSBjaGVja2JveCBjb2x1bW5cclxuICAgICAgICAgaWYoaGFzQ2hlY2tib3hlcyl7XHJcblxyXG4gICAgICAgICAgICAvLyBMb2FkIHByZXZpb3VzIHN0YXRlXHJcbiAgICAgICAgICAgIHNlbGYubG9hZFN0YXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBFVkVOVCBIQU5ETEVSU1xyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgdmFyICR0YWJsZSA9ICQoZHQudGFibGUoKS5ub2RlKCkpO1xyXG4gICAgICAgICAgICB2YXIgJHRhYmxlQm9keSA9ICQoZHQudGFibGUoKS5ib2R5KCkpO1xyXG4gICAgICAgICAgICB2YXIgJHRhYmxlQ29udGFpbmVyID0gJChkdC50YWJsZSgpLmNvbnRhaW5lcigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjb2x1bW4gdGhhdCBoYXMgcm93IHNlbGVjdGlvbiBlbmFibGVkXHJcbiAgICAgICAgICAgIGlmKGhhc0NoZWNrYm94ZXNTZWxlY3RSb3cpe1xyXG4gICAgICAgICAgICAgICAkdGFibGUuYWRkQ2xhc3MoJ2R0LWNoZWNrYm94ZXMtc2VsZWN0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBIYW5kbGUgZXZlbnQgYmVmb3JlIHJvdyBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICR0YWJsZS5vbigndXNlci1zZWxlY3QuZHQuZHRDaGVja2JveGVzJywgZnVuY3Rpb24gKGUsIGR0LCB0eXBlLCBjZWxsICwgb3JpZ2luYWxFdmVudCl7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGYub25EYXRhVGFibGVzVXNlclNlbGVjdChlLCBkdCwgdHlwZSwgY2VsbCAsIG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIEhhbmRsZSByb3cgc2VsZWN0L2Rlc2VsZWN0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICR0YWJsZS5vbignc2VsZWN0LmR0LmR0Q2hlY2tib3hlcyBkZXNlbGVjdC5kdC5kdENoZWNrYm94ZXMnLCBmdW5jdGlvbihlLCBhcGksIHR5cGUsIGluZGV4ZXMpe1xyXG4gICAgICAgICAgICAgICAgICBzZWxmLm9uRGF0YVRhYmxlc1NlbGVjdERlc2VsZWN0KGUsIHR5cGUsIGluZGV4ZXMpO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIGRpc3BsYXlpbmcgb2YgU2VsZWN0IGV4dGVuc2lvbiBpbmZvcm1hdGlvbiBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5fc2VsZWN0LmluZm8pe1xyXG4gICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIFNlbGVjdCBleHRlbnNpb24gaW5mb3JtYXRpb24gZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgICBkdC5zZWxlY3QuaW5mbyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnQgd2l0aCBzZWxlY3RlZCBpdGVtIHN1bW1hcnlcclxuICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgLy8gTk9URTogTmVlZGVkIHRvIGRpc3BsYXkgY29ycmVjdCBjb3VudCBvZiBzZWxlY3RlZCByb3dzXHJcbiAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICR0YWJsZS5vbignZHJhdy5kdC5kdENoZWNrYm94ZXMgc2VsZWN0LmR0LmR0Q2hlY2tib3hlcyBkZXNlbGVjdC5kdC5kdENoZWNrYm94ZXMnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgICBzZWxmLnNob3dJbmZvU2VsZWN0ZWQoKTtcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHRhYmxlIGRyYXcgZXZlbnRcclxuICAgICAgICAgICAgJHRhYmxlLm9uKCdkcmF3LmR0LmR0Q2hlY2tib3hlcycsIGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICBzZWxmLm9uRGF0YVRhYmxlc0RyYXcoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGNoZWNrYm94IGNsaWNrIGV2ZW50XHJcbiAgICAgICAgICAgICR0YWJsZUJvZHkub24oJ2NsaWNrLmR0Q2hlY2tib3hlcycsICdpbnB1dC5kdC1jaGVja2JveGVzJywgZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgIHNlbGYub25DbGljayhlLCB0aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2sgb24gXCJTZWxlY3QgYWxsXCIgY29udHJvbFxyXG4gICAgICAgICAgICAkdGFibGVDb250YWluZXIub24oJ2NsaWNrLmR0Q2hlY2tib3hlcycsICd0aGVhZCB0aC5kdC1jaGVja2JveGVzLXNlbGVjdC1hbGwgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgIHNlbGYub25DbGlja1NlbGVjdEFsbChlLCB0aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2sgb24gaGVhZGluZyBjb250YWluaW5nIFwiU2VsZWN0IGFsbFwiIGNvbnRyb2xcclxuICAgICAgICAgICAgJHRhYmxlQ29udGFpbmVyLm9uKCdjbGljay5kdENoZWNrYm94ZXMnLCAndGhlYWQgdGguZHQtY2hlY2tib3hlcy1zZWxlY3QtYWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScsIHRoaXMpLm5vdCgnOmRpc2FibGVkJykudHJpZ2dlcignY2xpY2snKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByb3cgc2VsZWN0aW9uIGlzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIGlmKCFoYXNDaGVja2JveGVzU2VsZWN0Um93KXtcclxuICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNsaWNrIG9uIGNlbGwgY29udGFpbmluZyBjaGVja2JveFxyXG4gICAgICAgICAgICAgICAkdGFibGVDb250YWluZXIub24oJ2NsaWNrLmR0Q2hlY2tib3hlcycsICd0Ym9keSB0ZC5kdC1jaGVja2JveGVzLWNlbGwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgJCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgdGhpcykubm90KCc6ZGlzYWJsZWQnKS50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGNsaWNrIG9uIGxhYmVsIG5vZGUgaW4gaGVhZGluZyBjb250YWluaW5nIFwiU2VsZWN0IGFsbFwiIGNvbnRyb2xcclxuICAgICAgICAgICAgLy8gYW5kIGluIGNlbGwgY29udGFpbmluZyBjaGVja2JveFxyXG4gICAgICAgICAgICAkdGFibGVDb250YWluZXIub24oJ2NsaWNrLmR0Q2hlY2tib3hlcycsICd0aGVhZCB0aC5kdC1jaGVja2JveGVzLXNlbGVjdC1hbGwgbGFiZWwsIHRib2R5IHRkLmR0LWNoZWNrYm94ZXMtY2VsbCBsYWJlbCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGJlaGF2aW9yXHJcbiAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2sgb24gXCJTZWxlY3QgYWxsXCIgY29udHJvbCBpbiBmbG9hdGluZyBmaXhlZCBoZWFkZXJcclxuICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmR0Q2hlY2tib3hlcycsICcuZml4ZWRIZWFkZXItZmxvYXRpbmcgdGhlYWQgdGguZHQtY2hlY2tib3hlcy1zZWxlY3QtYWxsIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScsIGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAvLyBJZiBGaXhlZEhlYWRlciBpcyBlbmFibGVkIGluIHRoaXMgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgaWYoY3R4Ll9maXhlZEhlYWRlcil7XHJcbiAgICAgICAgICAgICAgICAgIC8vIElmIGhlYWRlciBpcyBmbG9hdGluZyBpbiB0aGlzIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgIGlmKGN0eC5fZml4ZWRIZWFkZXIuZG9tWydoZWFkZXInXS5mbG9hdGluZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHNlbGYub25DbGlja1NlbGVjdEFsbChlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGNsaWNrIG9uIGhlYWRpbmcgY29udGFpbmluZyBcIlNlbGVjdCBhbGxcIiBjb250cm9sIGluIGZsb2F0aW5nIGZpeGVkIGhlYWRlclxyXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2suZHRDaGVja2JveGVzJywgJy5maXhlZEhlYWRlci1mbG9hdGluZyB0aGVhZCB0aC5kdC1jaGVja2JveGVzLXNlbGVjdC1hbGwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgLy8gSWYgRml4ZWRIZWFkZXIgaXMgZW5hYmxlZCBpbiB0aGlzIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5fZml4ZWRIZWFkZXIpe1xyXG4gICAgICAgICAgICAgICAgICAvLyBJZiBoZWFkZXIgaXMgZmxvYXRpbmcgaW4gdGhpcyBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICBpZihjdHguX2ZpeGVkSGVhZGVyLmRvbVsnaGVhZGVyJ10uZmxvYXRpbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAkKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nLCB0aGlzKS50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGFibGUgaW5pdGlhbGl6YXRpb24gZXZlbnRcclxuICAgICAgICAgICAgJHRhYmxlLm9uKCdpbml0LmR0LmR0Q2hlY2tib3hlcycsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgIC8vIFVzZSBkZWxheSB0byBoYW5kbGUgaW5pdGlhbGl6YXRpb24gZXZlbnRcclxuICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBjZXJ0YWluIGV4dGVuc2lvbnMgKEZpeGVkQ29sdW1ucykgYXJlIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgIC8vIG9ubHkgd2hlbiBpbml0aWFsaXphdGlvbiBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgIHNlbGYub25EYXRhVGFibGVzSW5pdCgpO1xyXG4gICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgc3RhdGUgc2F2aW5nIGV2ZW50XHJcbiAgICAgICAgICAgICR0YWJsZS5vbignc3RhdGVTYXZlUGFyYW1zLmR0LmR0Q2hlY2tib3hlcycsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGF0YSkge1xyXG4gICAgICAgICAgICAgICBzZWxmLm9uRGF0YVRhYmxlc1N0YXRlU2F2ZShlLCBzZXR0aW5ncywgZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHRhYmxlIGRlc3Ryb3kgZXZlbnRcclxuICAgICAgICAgICAgJHRhYmxlLm9uZSgnZGVzdHJveS5kdC5kdENoZWNrYm94ZXMnLCBmdW5jdGlvbihlLCBzZXR0aW5ncyl7XHJcbiAgICAgICAgICAgICAgIHNlbGYub25EYXRhVGFibGVzRGVzdHJveShlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBIYW5kbGVzIERhdGFUYWJsZXMgaW5pdGlhbGl6YXRpb24gZXZlbnRcclxuICAgICAgb25EYXRhVGFibGVzSW5pdDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICB2YXIgZHQgPSBzZWxmLnMuZHQ7XHJcbiAgICAgICAgIHZhciBjdHggPSBzZWxmLnMuY3R4O1xyXG5cclxuICAgICAgICAgLy8gSWYgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlIGlzIG5vdCBlbmFibGVkXHJcbiAgICAgICAgIC8vIE5PVEU6IE5lZWRlZCB0byBhdm9pZCBkdXBsaWNhdGUgY2FsbCB0byB1cGRhdGVTdGF0ZUNoZWNrYm94ZXMoKSBpbiBvbkRhdGFUYWJsZXNEcmF3KClcclxuICAgICAgICAgaWYoIWN0eC5vRmVhdHVyZXMuYlNlcnZlclNpZGUpe1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgc3RhdGUgc2F2aW5nIGlzIGVuYWJsZWRcclxuICAgICAgICAgICAgaWYoY3R4Lm9GZWF0dXJlcy5iU3RhdGVTYXZlKXtcclxuICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgQWpheCByZXF1ZXN0IGNvbXBsZXRpb24gZXZlbnRcclxuICAgICAgICAgICAgLy8gTk9URTogTmVlZGVkIHRvIHVwZGF0ZSB0YWJsZSBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBpZiB0YWJsZSBpcyByZWxvYWRlZCB2aWEgYWpheC5yZWxvYWQoKSBBUEkgbWV0aG9kXHJcbiAgICAgICAgICAgICQoZHQudGFibGUoKS5ub2RlKCkpLm9uKCd4aHIuZHQuZHRDaGVja2JveGVzJywgZnVuY3Rpb24gKCBlLCBzZXR0aW5ncyAsIGpzb24sIHhociApIHtcclxuICAgICAgICAgICAgICAgc2VsZi5vbkRhdGFUYWJsZXNYaHIoZS4gc2V0dGluZ3MsIGpzb24sIHhocik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBIYW5kbGVzIERhdGFUYWJsZXMgdXNlciBpbml0aWF0ZWQgc2VsZWN0IGV2ZW50XHJcbiAgICAgIG9uRGF0YVRhYmxlc1VzZXJTZWxlY3Q6IGZ1bmN0aW9uICggZSwgZHQsIHR5cGUsIGNlbGwgLyosIG9yaWdpbmFsRXZlbnQqLyApe1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICB2YXIgY2VsbElkeCA9IGNlbGwuaW5kZXgoKTtcclxuICAgICAgICAgdmFyIHJvd0lkeCA9IGNlbGxJZHgucm93O1xyXG4gICAgICAgICB2YXIgY29sSWR4ID0gc2VsZi5nZXRTZWxlY3RSb3dDb2xJbmRleCgpO1xyXG4gICAgICAgICB2YXIgY2VsbERhdGEgPSBkdC5jZWxsKHsgcm93OiByb3dJZHgsIGNvbHVtbjogY29sSWR4IH0pLmRhdGEoKTtcclxuXHJcbiAgICAgICAgIC8vIElmIGNoZWNrYm94IGluIHRoZSBjZWxsIGNhbm5vdCBiZSBjaGVja2VkXHJcbiAgICAgICAgIGlmKCFzZWxmLmlzQ2VsbFNlbGVjdGFibGUoY29sSWR4LCBjZWxsRGF0YSkpe1xyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHJvdyBzZWxlY3Rpb25cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBIYW5kbGVzIERhdGFUYWJsZXMgcm93IHNlbGVjdC9kZXNlbGVjdCBldmVudFxyXG4gICAgICBvbkRhdGFUYWJsZXNTZWxlY3REZXNlbGVjdDogZnVuY3Rpb24oZSwgdHlwZSwgaW5kZXhlcyl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG5cclxuICAgICAgICAgaWYoc2VsZi5zLmlnbm9yZVNlbGVjdCl7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAgaWYodHlwZSA9PT0gJ3Jvdycpe1xyXG4gICAgICAgICAgICAvLyBHZXQgaW5kZXggb2YgdGhlIGZpcnN0IGNvbHVtbiB0aGF0IGhhcyBjaGVja2JveCBhbmQgcm93IHNlbGVjdGlvbiBlbmFibGVkXHJcbiAgICAgICAgICAgIHZhciBjb2xJZHggPSBzZWxmLmdldFNlbGVjdFJvd0NvbEluZGV4KCk7XHJcbiAgICAgICAgICAgIGlmKGNvbElkeCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgIHZhciBjZWxscyA9IGR0LmNlbGxzKGluZGV4ZXMsIGNvbElkeCk7XHJcblxyXG4gICAgICAgICAgICAgICBzZWxmLnVwZGF0ZURhdGEoY2VsbHMsIGNvbElkeCwgKGUudHlwZSA9PT0gJ3NlbGVjdCcpID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDaGVja2JveChjZWxscywgY29sSWR4LCAoZS50eXBlID09PSAnc2VsZWN0JykgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVNlbGVjdEFsbChjb2xJZHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIEhhbmRsZXMgRGF0YVRhYmxlcyBzdGF0ZSBzYXZlIGV2ZW50XHJcbiAgICAgIG9uRGF0YVRhYmxlc1N0YXRlU2F2ZTogZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBkYXRhKSB7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBGb3IgZXZlcnkgY29sdW1uIHdoZXJlIGNoZWNrYm94ZXMgYXJlIGVuYWJsZWRcclxuICAgICAgICAgJC5lYWNoKHNlbGYucy5jb2x1bW5zLCBmdW5jdGlvbihpbmRleCwgY29sSWR4KXtcclxuICAgICAgICAgICAgLy8gSWYgY2hlY2tib3ggc3RhdGUgc2F2aW5nIGlzIGVuYWJsZWRcclxuICAgICAgICAgICAgaWYoY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMuc3RhdGVTYXZlKXtcclxuICAgICAgICAgICAgICAgLy8gSWYgY2hlY2tib3hlcyBzdGF0ZSBoYXNuJ3QgYmVlbiBzYXZlZCBiZWZvcmVcclxuICAgICAgICAgICAgICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCAnY2hlY2tib3hlcycpKXtcclxuICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcnJheSB0byBzYXZlIGNoZWNrYm94ZXMgc3RhdGUgZm9yIGVhY2ggY29sdW1uXHJcbiAgICAgICAgICAgICAgICAgIGRhdGEuY2hlY2tib3hlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAvLyBTYXZlIGNoZWNrYm94ZXMgc3RhdGVcclxuICAgICAgICAgICAgICAgZGF0YS5jaGVja2JveGVzW2NvbElkeF0gPSBzZWxmLnMuZGF0YVtjb2xJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gSGFuZGxlcyBEYXRhVGFibGVzIGRlc3Ryb3kgZXZlbnRcclxuICAgICAgb25EYXRhVGFibGVzRGVzdHJveTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICB2YXIgZHQgPSBzZWxmLnMuZHQ7XHJcblxyXG4gICAgICAgICAvLyBHZXQgdGFibGUgZWxlbWVudHNcclxuICAgICAgICAgdmFyICR0YWJsZSA9ICQoZHQudGFibGUoKS5ub2RlKCkpO1xyXG4gICAgICAgICB2YXIgJHRhYmxlQm9keSA9ICQoZHQudGFibGUoKS5ib2R5KCkpO1xyXG4gICAgICAgICB2YXIgJHRhYmxlQ29udGFpbmVyID0gJChkdC50YWJsZSgpLmNvbnRhaW5lcigpKTtcclxuXHJcbiAgICAgICAgIC8vIERldGFjaCBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ2NsaWNrLmR0Q2hlY2tib3hlcycpO1xyXG4gICAgICAgICAkdGFibGVDb250YWluZXIub2ZmKCcuZHRDaGVja2JveGVzJyk7XHJcbiAgICAgICAgICR0YWJsZUJvZHkub2ZmKCcuZHRDaGVja2JveGVzJyk7XHJcbiAgICAgICAgICR0YWJsZS5vZmYoJy5kdENoZWNrYm94ZXMnKTtcclxuXHJcbiAgICAgICAgIC8vIENsZWFyIGRhdGFcclxuICAgICAgICAgLy9cclxuICAgICAgICAgLy8gTk9URTogTmVlZGVkIG9ubHkgdG8gcmVkdWNlIG1lbW9yeSBmb290cHJpbnRcclxuICAgICAgICAgLy8gaW4gY2FzZSB1c2VyIHNhdmVzIGluc3RhbmNlIG9mIERhdGFUYWJsZSBvYmplY3QuXHJcbiAgICAgICAgIHNlbGYucy5kYXRhID0ge307XHJcbiAgICAgICAgIHNlbGYucy5kYXRhRGlzYWJsZWQgPSB7fTtcclxuXHJcbiAgICAgICAgIC8vIFJlbW92ZSBhZGRlZCBlbGVtZW50c1xyXG4gICAgICAgICAkKCcuZHQtY2hlY2tib3hlcy1zZWxlY3QtYWxsJywgJHRhYmxlKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbCl7XHJcbiAgICAgICAgICAgICQoZWwpXHJcbiAgICAgICAgICAgICAgIC5odG1sKCQoZWwpLmRhdGEoJ2h0bWwnKSlcclxuICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdkdC1jaGVja2JveGVzLXNlbGVjdC1hbGwnKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBIYW5kbGVzIERhdGFUYWJsZXMgZHJhdyBldmVudFxyXG4gICAgICBvbkRhdGFUYWJsZXNEcmF3OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBjdHggPSBzZWxmLnMuY3R4O1xyXG5cclxuICAgICAgICAgLy8gSWYgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBpcyBlbmFibGVkXHJcbiAgICAgICAgIC8vIG9yIGRlZmVycmVkIHJlbmRlciBpcyBlbmFibGVkXHJcbiAgICAgICAgIC8vXHJcbiAgICAgICAgIC8vIFRPRE86IGl0J3Mgbm90IG9wdGltYWwgdG8gdXBkYXRlIHN0YXRlIG9mIGNoZWNrYm94ZXNcclxuICAgICAgICAgLy8gZm9yIGFscmVhZHkgY3JlYXRlZCByb3dzIGluIGRlZmVycmVkIHJlbmRlcmluZyBtb2RlXHJcbiAgICAgICAgIGlmKGN0eC5vRmVhdHVyZXMuYlNlcnZlclNpZGUgfHwgY3R4Lm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIpe1xyXG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXRlQ2hlY2tib3hlcyh7IHBhZ2U6ICdjdXJyZW50Jywgc2VhcmNoOiAnbm9uZScgfSk7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICQuZWFjaChzZWxmLnMuY29sdW1ucywgZnVuY3Rpb24oaW5kZXgsIGNvbElkeCl7XHJcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0QWxsKGNvbElkeCk7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gSGFuZGxlcyBEYXRhVGFibGVzIEFqYXggcmVxdWVzdCBjb21wbGV0aW9uIGV2ZW50XHJcbiAgICAgIG9uRGF0YVRhYmxlc1hocjogZnVuY3Rpb24oIC8qIGUsIHNldHRpbmdzICwganNvbiwgeGhyICovICl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIC8vIEdldCB0YWJsZSBlbGVtZW50c1xyXG4gICAgICAgICB2YXIgJHRhYmxlID0gJChkdC50YWJsZSgpLm5vZGUoKSk7XHJcblxyXG4gICAgICAgICAvLyBGb3IgZXZlcnkgY29sdW1uIHdoZXJlIGNoZWNrYm94ZXMgYXJlIGVuYWJsZWRcclxuICAgICAgICAgJC5lYWNoKHNlbGYucy5jb2x1bW5zLCBmdW5jdGlvbihpbmRleCwgY29sSWR4KXtcclxuICAgICAgICAgICAgLy8gUmVzZXQgZGF0YVxyXG4gICAgICAgICAgICBzZWxmLnMuZGF0YVtjb2xJZHhdID0ge307XHJcbiAgICAgICAgICAgIHNlbGYucy5kYXRhRGlzYWJsZWRbY29sSWR4XSA9IHt9O1xyXG4gICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgIC8vIElmIHN0YXRlIHNhdmluZyBpcyBlbmFibGVkXHJcbiAgICAgICAgIGlmKGN0eC5vRmVhdHVyZXMuYlN0YXRlU2F2ZSl7XHJcbiAgICAgICAgICAgIC8vIExvYWQgcHJldmlvdXMgc3RhdGVcclxuICAgICAgICAgICAgc2VsZi5sb2FkU3RhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0YWJsZSBzdGF0ZSBvbiBuZXh0IHJlZHJhd1xyXG4gICAgICAgICAgICAkdGFibGUub25lKCdkcmF3LmR0LmR0Q2hlY2tib3hlcycsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFVwZGF0ZXMgYXJyYXkgaG9sZGluZyBkYXRhIGZvciBzZWxlY3RlZCBjaGVja2JveGVzXHJcbiAgICAgIHVwZGF0ZURhdGE6IGZ1bmN0aW9uKGNlbGxzLCBjb2xJZHgsIGlzU2VsZWN0ZWQpe1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBkdCA9IHNlbGYucy5kdDtcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBJZiBDaGVja2JveGVzIGV4dGVuc2lvbiBpcyBlbmFibGVkIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICBpZihjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcyl7XHJcbiAgICAgICAgICAgIHZhciBjZWxsc0RhdGEgPSBjZWxscy5kYXRhKCk7XHJcbiAgICAgICAgICAgIGNlbGxzRGF0YS5lYWNoKGZ1bmN0aW9uKGNlbGxEYXRhKXtcclxuICAgICAgICAgICAgICAgLy8gSWYgY2hlY2tib3ggaXMgY2hlY2tlZFxyXG4gICAgICAgICAgICAgICBpZihpc1NlbGVjdGVkKXtcclxuICAgICAgICAgICAgICAgICAgY3R4LmNoZWNrYm94ZXMucy5kYXRhW2NvbElkeF1bY2VsbERhdGFdID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgY2hlY2tib3ggaXMgbm90IGNoZWNrZWRcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZGVsZXRlIGN0eC5jaGVja2JveGVzLnMuZGF0YVtjb2xJZHhdW2NlbGxEYXRhXTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHN0YXRlIHNhdmluZyBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgIGlmKGN0eC5vRmVhdHVyZXMuYlN0YXRlU2F2ZSl7XHJcbiAgICAgICAgICAgICAgIC8vIElmIGNoZWNrYm94IHN0YXRlIHNhdmluZyBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzLnN0YXRlU2F2ZSl7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFNhdmUgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgZHQuc3RhdGUuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVXBkYXRlcyByb3cgc2VsZWN0aW9uXHJcbiAgICAgIHVwZGF0ZVNlbGVjdDogZnVuY3Rpb24oc2VsZWN0b3IsIGlzU2VsZWN0ZWQpe1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBkdCA9IHNlbGYucy5kdDtcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBJZiBTZWxlY3QgZXh0ZW5zaW9uIGlzIGVuYWJsZWRcclxuICAgICAgICAgaWYoY3R4Ll9zZWxlY3Qpe1xyXG4gICAgICAgICAgICAvLyBEaXNhYmxlIHNlbGVjdCBldmVudCBoYW5sZGVyIHRlbXBvcmFyaWx5XHJcbiAgICAgICAgICAgIHNlbGYucy5pZ25vcmVTZWxlY3QgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYoaXNTZWxlY3RlZCl7XHJcbiAgICAgICAgICAgICAgIGR0LnJvd3Moc2VsZWN0b3IpLnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBkdC5yb3dzKHNlbGVjdG9yKS5kZXNlbGVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1lbmFibGUgc2VsZWN0IGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAgICAgc2VsZi5zLmlnbm9yZVNlbGVjdCA9IGZhbHNlO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBVcGRhdGVzIHN0YXRlIG9mIHNpbmdsZSBjaGVja2JveFxyXG4gICAgICB1cGRhdGVDaGVja2JveDogZnVuY3Rpb24oY2VsbHMsIGNvbElkeCwgaXNTZWxlY3RlZCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICB2YXIgY2VsbE5vZGVzID0gY2VsbHMubm9kZXMoKTtcclxuICAgICAgICAgaWYoY2VsbE5vZGVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICQoJ2lucHV0LmR0LWNoZWNrYm94ZXMnLCBjZWxsTm9kZXMpLm5vdCgnOmRpc2FibGVkJykucHJvcCgnY2hlY2tlZCcsIGlzU2VsZWN0ZWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0Q2FsbGJhY2sgaXMgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICBpZigkLmlzRnVuY3Rpb24oY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMuc2VsZWN0Q2FsbGJhY2spKXtcclxuICAgICAgICAgICAgICAgY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMuc2VsZWN0Q2FsbGJhY2soY2VsbE5vZGVzLCBpc1NlbGVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGFibGUgc3RhdGVcclxuICAgICAgdXBkYXRlU3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIHNlbGYudXBkYXRlU3RhdGVDaGVja2JveGVzKHsgcGFnZTogJ2FsbCcsIHNlYXJjaDogJ25vbmUnIH0pO1xyXG5cclxuICAgICAgICAgLy8gSWYgRml4ZWRDb2x1bW5zIGV4dGVuc2lvbiBpcyBlbmFibGVkXHJcbiAgICAgICAgIGlmKGN0eC5fb0ZpeGVkQ29sdW1ucyl7XHJcbiAgICAgICAgICAgIC8vIFVzZSBkZWxheSB0byBsZXQgRml4ZWRDb2x1bW5zIGNvbnN0cnVjdCB0aGUgaGVhZGVyXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSB1cGRhdGUgdGhlIFwiU2VsZWN0IGFsbFwiIGNoZWNrYm94XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGNvbHVtbiB3aGVyZSBjaGVja2JveGVzIGFyZSBlbmFibGVkXHJcbiAgICAgICAgICAgICAgICQuZWFjaChzZWxmLnMuY29sdW1ucywgZnVuY3Rpb24oaW5kZXgsIGNvbElkeCl7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0QWxsKGNvbElkeCk7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVXBkYXRlcyBzdGF0ZSBvZiBtdWx0aXBsZSBjaGVja2JveGVzXHJcbiAgICAgIHVwZGF0ZVN0YXRlQ2hlY2tib3hlczogZnVuY3Rpb24ob3B0cyl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIC8vIEVudW1lcmF0ZSBhbGwgY2VsbHNcclxuICAgICAgICAgZHQuY2VsbHMoJ3RyJywgc2VsZi5zLmNvbHVtbnMsIG9wdHMpLmV2ZXJ5KGZ1bmN0aW9uKHJvd0lkeCwgY29sSWR4KXtcclxuICAgICAgICAgICAgLy8gR2V0IGNlbGwgZGF0YVxyXG4gICAgICAgICAgICB2YXIgY2VsbERhdGEgPSB0aGlzLmRhdGEoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBjaGVja2JveCBpbiB0aGUgY2VsbCBjYW4gYmUgc2VsZWN0ZWRcclxuICAgICAgICAgICAgdmFyIGlzQ2VsbFNlbGVjdGFibGUgPSBzZWxmLmlzQ2VsbFNlbGVjdGFibGUoY29sSWR4LCBjZWxsRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBjaGVja2JveCBpcyBjaGVja2VkXHJcbiAgICAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4LmNoZWNrYm94ZXMucy5kYXRhLCBjb2xJZHgpXHJcbiAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdHguY2hlY2tib3hlcy5zLmRhdGFbY29sSWR4XSwgY2VsbERhdGEpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAvLyBJZiByb3cgc2VsZWN0aW9uIGlzIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgLy8gYW5kIGNoZWNrYm94IGNhbiBiZSBjaGVja2VkXHJcbiAgICAgICAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzLnNlbGVjdFJvdyAmJiBpc0NlbGxTZWxlY3RhYmxlKXtcclxuICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTZWxlY3Qocm93SWR4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDaGVja2JveCh0aGlzLCBjb2xJZHgsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBjaGVja2JveCBpcyBkaXNhYmxlZFxyXG4gICAgICAgICAgICBpZighaXNDZWxsU2VsZWN0YWJsZSl7XHJcbiAgICAgICAgICAgICAgICQoJ2lucHV0LmR0LWNoZWNrYm94ZXMnLCB0aGlzLm5vZGUoKSkucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9KTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIEhhbmRsZXMgY2hlY2tib3ggY2xpY2sgZXZlbnRcclxuICAgICAgb25DbGljazogZnVuY3Rpb24oZSwgY3RybCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIHZhciBjZWxsU2VsZWN0b3I7XHJcblxyXG4gICAgICAgICAvLyBHZXQgY2VsbFxyXG4gICAgICAgICB2YXIgJGNlbGwgPSAkKGN0cmwpLmNsb3Nlc3QoJ3RkJyk7XHJcblxyXG4gICAgICAgICAvLyBJZiBjZWxsIGlzIGluIGEgZml4ZWQgY29sdW1uIHVzaW5nIEZpeGVkQ29sdW1ucyBleHRlbnNpb25cclxuICAgICAgICAgaWYoJGNlbGwucGFyZW50cygnLkRURkNfQ2xvbmVkJykubGVuZ3RoKXtcclxuICAgICAgICAgICAgY2VsbFNlbGVjdG9yID0gZHQuZml4ZWRDb2x1bW5zKCkuY2VsbEluZGV4KCRjZWxsKTtcclxuXHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNlbGxTZWxlY3RvciA9ICRjZWxsO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICB2YXIgY2VsbCAgICA9IGR0LmNlbGwoY2VsbFNlbGVjdG9yKTtcclxuICAgICAgICAgdmFyIGNlbGxJZHggPSBjZWxsLmluZGV4KCk7XHJcbiAgICAgICAgIHZhciBjb2xJZHggID0gY2VsbElkeC5jb2x1bW47XHJcbiAgICAgICAgIHZhciByb3dJZHggID0gY2VsbElkeC5yb3c7XHJcblxyXG4gICAgICAgICAvLyBJZiByb3cgc2VsZWN0aW9uIGlzIG5vdCBlbmFibGVkXHJcbiAgICAgICAgIC8vIE5PVEU6IGlmIHJvdyBzZWxlY3Rpb24gaXMgZW5hYmxlZCwgY2hlY2tib3ggc2VsZWN0aW9uL2Rlc2VsZWN0aW9uXHJcbiAgICAgICAgIC8vIHdvdWxkIGJlIGhhbmRsZWQgYnkgb25EYXRhVGFibGVzU2VsZWN0RGVzZWxlY3QgZXZlbnQgaGFuZGxlciBpbnN0ZWFkXHJcbiAgICAgICAgIGlmKCFjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcy5zZWxlY3RSb3cpe1xyXG4gICAgICAgICAgICBjZWxsLmNoZWNrYm94ZXMuc2VsZWN0KGN0cmwuY2hlY2tlZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGNsaWNrIGV2ZW50IGZyb20gcHJvcGFnYXRpbmcgdG8gcGFyZW50XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgU2VsZWN0IGV4dGVuc2lvbiBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgIGlmKGN0eC5fc2VsZWN0KXtcclxuICAgICAgICAgICAgICAgLy8gSWYgc3R5bGUgaXMgc2V0IHRvIFwib3NcIlxyXG4gICAgICAgICAgICAgICBpZihjdHguX3NlbGVjdC5zdHlsZSA9PT0gJ29zJyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBXT1JLQVJPVU5EOlxyXG4gICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2d5cm9jb2RlL2pxdWVyeS1kYXRhdGFibGVzLWNoZWNrYm94ZXMvaXNzdWVzLzEyOFxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBjbGljayBldmVudCBmcm9tIHByb3BhZ2F0aW5nIHRvIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0L2Rlc2VsZWN0IGluZGl2aWR1YWwgcm93XHJcbiAgICAgICAgICAgICAgICAgIGNlbGwuY2hlY2tib3hlcy5zZWxlY3QoY3RybC5jaGVja2VkKTtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgc3R5bGUgaXMgc2V0IHRvIG90aGVyIHRoYW4gXCJvc1wiXHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFdPUktBUk9VTkQ6XHJcbiAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBleHRlbnNpb24gbWF5IGtlZXAgdGhlIHJvdyBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAvLyB3aGVuIGNoZWNrYm94IGlzIHVuY2hlY2tlZCB3aXRoIFNISUZUIGtleS5cclxuICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBjaGVja2JveCBBRlRFUiBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAvLyBzZWxlY3QvZGVzZWxlY3QgZXZlbnQgZnJvbSBTZWxlY3QgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAvLyBDYWxsIHRvIHNldFRpbWVvdXQgaXMgbmVlZGVkIHRvIGxldCBzZWxlY3QvZGVzZWxlY3QgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGRhdGEgZmlyc3QuXHJcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNlbGwgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbERhdGEgPSBjZWxsLmRhdGEoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGRhdGEgaXMgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0RhdGEgPSAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLnMuZGF0YSwgY29sSWR4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi5zLmRhdGFbY29sSWR4XSwgY2VsbERhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGF0ZSBvZiB0aGUgY2hlY2tib3ggbmVlZHMgdG8gYmUgdXBkYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICBpZihoYXNEYXRhICE9PSBjdHJsLmNoZWNrZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUNoZWNrYm94KGNlbGwsIGNvbElkeCwgaGFzRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0QWxsKGNvbElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBIYW5kbGVzIGNoZWNrYm94IGNsaWNrIGV2ZW50XHJcbiAgICAgIG9uQ2xpY2tTZWxlY3RBbGw6IGZ1bmN0aW9uKGUsIGN0cmwpe1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBkdCA9IHNlbGYucy5kdDtcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBDYWxjdWxhdGUgY29sdW1uIGluZGV4XHJcbiAgICAgICAgIHZhciBjb2xJZHggPSBudWxsO1xyXG4gICAgICAgICB2YXIgJHRoID0gJChjdHJsKS5jbG9zZXN0KCd0aCcpO1xyXG5cclxuICAgICAgICAgLy8gSWYgY29sdW1uIGlzIGZpeGVkIHVzaW5nIEZpeGVkQ29sdW1ucyBleHRlbnNpb25cclxuICAgICAgICAgaWYoJHRoLnBhcmVudHMoJy5EVEZDX0Nsb25lZCcpLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHZhciBjZWxsSWR4ID0gZHQuZml4ZWRDb2x1bW5zKCkuY2VsbEluZGV4KCR0aCk7XHJcbiAgICAgICAgICAgIGNvbElkeCA9IGNlbGxJZHguY29sdW1uO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xJZHggPSBkdC5jb2x1bW4oJHRoKS5pbmRleCgpO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBJbmRpY2F0ZSB0aGF0IHN0YXRlIG9mIFwiU2VsZWN0IGFsbFwiIGNvbnRyb2wgaGFzIGJlZW4gY2hhbmdlZFxyXG4gICAgICAgICAkKGN0cmwpLmRhdGEoJ2lzLWNoYW5nZWQnLCB0cnVlKTtcclxuXHJcbiAgICAgICAgIGR0LmNvbHVtbihjb2xJZHgsIHtcclxuICAgICAgICAgICAgcGFnZTogKFxyXG4gICAgICAgICAgICAgICAoY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMgJiYgY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMuc2VsZWN0QWxsUGFnZXMpXHJcbiAgICAgICAgICAgICAgICAgID8gJ2FsbCdcclxuICAgICAgICAgICAgICAgICAgOiAnY3VycmVudCdcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgc2VhcmNoOiAnYXBwbGllZCdcclxuICAgICAgICAgfSkuY2hlY2tib3hlcy5zZWxlY3QoY3RybC5jaGVja2VkKTtcclxuXHJcbiAgICAgICAgIC8vIFByZXZlbnQgY2xpY2sgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byBwYXJlbnRcclxuICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIExvYWRzIHByZXZpb3NseSBzYXZlZCBzYXRlXHJcbiAgICAgIGxvYWRTdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBkdCA9IHNlbGYucy5kdDtcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBJZiBzdGF0ZSBzYXZpbmcgaXMgZW5hYmxlZFxyXG4gICAgICAgICBpZihjdHgub0ZlYXR1cmVzLmJTdGF0ZVNhdmUpe1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBzdG9yZWQgc3RhdGVcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gZHQuc3RhdGUubG9hZGVkKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgZXZlcnkgY29sdW1uIHdoZXJlIGNoZWNrYm94ZXMgYXJlIGVuYWJsZWRcclxuICAgICAgICAgICAgJC5lYWNoKHNlbGYucy5jb2x1bW5zLCBmdW5jdGlvbihpbmRleCwgY29sSWR4KXtcclxuICAgICAgICAgICAgICAgLy8gSWYgc3RhdGUgaXMgbG9hZGVkIGFuZCBjb250YWlucyBkYXRhIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICAgICAgICBpZihzdGF0ZSAmJiBzdGF0ZS5jaGVja2JveGVzICYmIHN0YXRlLmNoZWNrYm94ZXMuaGFzT3duUHJvcGVydHkoY29sSWR4KSl7XHJcbiAgICAgICAgICAgICAgICAgIC8vIElmIGNoZWNrYm94IHN0YXRlIHNhdmluZyBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzLnN0YXRlU2F2ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgcHJldmlvdXMgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgc2VsZi5zLmRhdGFbY29sSWR4XSA9IHN0YXRlLmNoZWNrYm94ZXNbY29sSWR4XTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBVcGRhdGVzIHN0YXRlIG9mIHRoZSBcIlNlbGVjdCBhbGxcIiBjb250cm9sc1xyXG4gICAgICB1cGRhdGVTZWxlY3RBbGw6IGZ1bmN0aW9uKGNvbElkeCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIC8vIElmIENoZWNrYm94ZXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQgZm9yIHRoaXMgY29sdW1uXHJcbiAgICAgICAgIC8vIGFuZCBcIlNlbGVjdCBhbGxcIiBjb250cm9sIGlzIGVuYWJsZWQgZm9yIHRoaXMgY29sdW1uXHJcbiAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzICYmIGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzLnNlbGVjdEFsbCl7XHJcbiAgICAgICAgICAgIHZhciBjZWxscyA9IGR0LmNlbGxzKCd0cicsIGNvbElkeCwge1xyXG4gICAgICAgICAgICAgICBwYWdlOiAoXHJcbiAgICAgICAgICAgICAgICAgIChjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcy5zZWxlY3RBbGxQYWdlcylcclxuICAgICAgICAgICAgICAgICAgICAgPyAnYWxsJ1xyXG4gICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW50J1xyXG4gICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICBzZWFyY2g6ICdhcHBsaWVkJ1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciAkdGFibGVDb250YWluZXIgPSBkdC50YWJsZSgpLmNvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICB2YXIgJGNoZWNrYm94ZXNTZWxlY3RBbGwgPSAkKCcuZHQtY2hlY2tib3hlcy1zZWxlY3QtYWxsW2RhdGEtY29sPVwiJyArIGNvbElkeCArICdcIl0gaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgJHRhYmxlQ29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb3VudENoZWNrZWQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgY291bnREaXNhYmxlZCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBjZWxsc0RhdGEgPSBjZWxscy5kYXRhKCk7XHJcbiAgICAgICAgICAgICQuZWFjaChjZWxsc0RhdGEsIGZ1bmN0aW9uKGluZGV4LCBjZWxsRGF0YSl7XHJcbiAgICAgICAgICAgICAgIC8vIElmIGNoZWNrYm94IGlzIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICBpZihzZWxmLmlzQ2VsbFNlbGVjdGFibGUoY29sSWR4LCBjZWxsRGF0YSkpe1xyXG4gICAgICAgICAgICAgICAgICBpZihcclxuICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYucy5kYXRhLCBjb2xJZHgpXHJcbiAgICAgICAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLnMuZGF0YVtjb2xJZHhdLCBjZWxsRGF0YSlcclxuICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvdW50Q2hlY2tlZCsrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGNoZWNrYm94IGlzIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvdW50RGlzYWJsZWQrKztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIEZpeGVkSGVhZGVyIGlzIGVuYWJsZWQgaW4gdGhpcyBpbnN0YW5jZVxyXG4gICAgICAgICAgICBpZihjdHguX2ZpeGVkSGVhZGVyKXtcclxuICAgICAgICAgICAgICAgLy8gSWYgaGVhZGVyIGlzIGZsb2F0aW5nIGluIHRoaXMgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgaWYoY3R4Ll9maXhlZEhlYWRlci5kb21bJ2hlYWRlciddLmZsb2F0aW5nKXtcclxuICAgICAgICAgICAgICAgICAgJGNoZWNrYm94ZXNTZWxlY3RBbGwgPSAkKCcuZml4ZWRIZWFkZXItZmxvYXRpbmcgLmR0LWNoZWNrYm94ZXMtc2VsZWN0LWFsbFtkYXRhLWNvbD1cIicgKyBjb2xJZHggKyAnXCJdIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGVkO1xyXG4gICAgICAgICAgICB2YXIgaXNJbmRldGVybWluYXRlO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgY2hlY2tib3hlcyBhcmUgY2hlY2tlZFxyXG4gICAgICAgICAgICBpZiAoY291bnRDaGVja2VkID09PSAwKXtcclxuICAgICAgICAgICAgICAgaXNTZWxlY3RlZCAgICAgID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgIGlzSW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYWxsIG9mIHRoZSBjaGVja2JveGVzIGFyZSBjaGVja2VkXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGNvdW50Q2hlY2tlZCArIGNvdW50RGlzYWJsZWQpID09PSBjZWxsc0RhdGEubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgaXNTZWxlY3RlZCAgICAgID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgaXNJbmRldGVybWluYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBzb21lIG9mIHRoZSBjaGVja2JveGVzIGFyZSBjaGVja2VkXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgICAgICA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIGlzSW5kZXRlcm1pbmF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgICAgICAgICAgPSAkY2hlY2tib3hlc1NlbGVjdEFsbC5kYXRhKCdpcy1jaGFuZ2VkJyk7XHJcbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGVkTm93ICAgICAgPSAkY2hlY2tib3hlc1NlbGVjdEFsbC5wcm9wKCdjaGVja2VkJyk7XHJcbiAgICAgICAgICAgIHZhciBpc0luZGV0ZXJtaW5hdGVOb3cgPSAkY2hlY2tib3hlc1NlbGVjdEFsbC5wcm9wKCdpbmRldGVybWluYXRlJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBzdGF0ZSBvZiBcIlNlbGVjdCBhbGxcIiBjb250cm9sIGhhcyBiZWVuIGNoYW5nZWRcclxuICAgICAgICAgICAgaWYoaXNDaGFuZ2VkIHx8IGlzU2VsZWN0ZWROb3cgIT09IGlzU2VsZWN0ZWQgfHwgaXNJbmRldGVybWluYXRlTm93ICE9PSBpc0luZGV0ZXJtaW5hdGUpe1xyXG4gICAgICAgICAgICAgICAvLyBSZXNldCBcIlNlbGVjdCBhbGxcIiBjb250cm9sIHN0YXRlIGZsYWdcclxuICAgICAgICAgICAgICAgJGNoZWNrYm94ZXNTZWxlY3RBbGwuZGF0YSgnaXMtY2hhbmdlZCcsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICRjaGVja2JveGVzU2VsZWN0QWxsLnByb3Aoe1xyXG4gICAgICAgICAgICAgICAgICAvLyBOT1RFOiBJZiBjaGVja2JveCBoYXMgaW5kZXRlcm1pbmF0ZSBzdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgLy8gXCJjaGVja2VkXCIgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gZmFsc2UuXHJcbiAgICAgICAgICAgICAgICAgICdjaGVja2VkJzogaXNJbmRldGVybWluYXRlID8gZmFsc2UgOiBpc1NlbGVjdGVkLFxyXG4gICAgICAgICAgICAgICAgICAnaW5kZXRlcm1pbmF0ZSc6IGlzSW5kZXRlcm1pbmF0ZVxyXG4gICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdEFsbENhbGxiYWNrIGlzIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgaWYoJC5pc0Z1bmN0aW9uKGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzLnNlbGVjdEFsbENhbGxiYWNrKSl7XHJcbiAgICAgICAgICAgICAgICAgIGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzLnNlbGVjdEFsbENhbGxiYWNrKCRjaGVja2JveGVzU2VsZWN0QWxsLmNsb3Nlc3QoJ3RoJykuZ2V0KDApLCBpc1NlbGVjdGVkLCBpc0luZGV0ZXJtaW5hdGUpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVXBkYXRlcyB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBvZiB0aGUgRGF0YVRhYmxlIHNob3dpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXHJcbiAgICAgIC8vIGl0ZW1zIHNlbGVjdGVkLiBCYXNlZCBvbiBpbmZvKCkgbWV0aG9kIG9mIFNlbGVjdCBleHRlbnNpb24uXHJcbiAgICAgIHNob3dJbmZvU2VsZWN0ZWQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIGlmICggISBjdHguYWFuRmVhdHVyZXMuaSApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBHZXQgaW5kZXggb2YgdGhlIGZpcnN0IGNvbHVtbiB0aGF0IGhhcyBjaGVja2JveCBhbmQgcm93IHNlbGVjdGlvbiBlbmFibGVkXHJcbiAgICAgICAgIHZhciBjb2xJZHggPSBzZWxmLmdldFNlbGVjdFJvd0NvbEluZGV4KCk7XHJcblxyXG4gICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGNvbHVtbiB0aGF0IGhhcyBjaGVja2JveCBhbmQgcm93IHNlbGVjdGlvbiBlbmFibGVkXHJcbiAgICAgICAgIGlmKGNvbElkeCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8vIENvdW50IG51bWJlciBvZiBzZWxlY3RlZCByb3dzXHJcbiAgICAgICAgICAgIHZhciBjb3VudFJvd3MgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjZWxsRGF0YSBpbiBjdHguY2hlY2tib3hlcy5zLmRhdGFbY29sSWR4XSl7XHJcbiAgICAgICAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4LmNoZWNrYm94ZXMucy5kYXRhLCBjb2xJZHgpXHJcbiAgICAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdHguY2hlY2tib3hlcy5zLmRhdGFbY29sSWR4XSwgY2VsbERhdGEpXHJcbiAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICBjb3VudFJvd3MrKztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYWRkID0gZnVuY3Rpb24oJGVsLCBuYW1lLCBudW0pe1xyXG4gICAgICAgICAgICAgICAkZWwuYXBwZW5kKCAkKCc8c3BhbiBjbGFzcz1cInNlbGVjdC1pdGVtXCIvPicpLmFwcGVuZCggZHQuaTE4bihcclxuICAgICAgICAgICAgICAgICAgJ3NlbGVjdC4nK25hbWUrJ3MnLFxyXG4gICAgICAgICAgICAgICAgICB7IF86ICclZCAnK25hbWUrJ3Mgc2VsZWN0ZWQnLCAwOiAnJywgMTogJzEgJytuYW1lKycgc2VsZWN0ZWQnIH0sXHJcbiAgICAgICAgICAgICAgICAgIG51bVxyXG4gICAgICAgICAgICAgICApICkgKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVybmFsIGtub3dsZWRnZSBvZiBEYXRhVGFibGVzIHRvIGxvb3Agb3ZlciBhbGwgaW5mb3JtYXRpb24gZWxlbWVudHNcclxuICAgICAgICAgICAgJC5lYWNoKCBjdHguYWFuRmVhdHVyZXMuaSwgZnVuY3Rpb24gKCBpLCBlbCApIHtcclxuICAgICAgICAgICAgICAgdmFyICRlbCA9ICQoZWwpO1xyXG5cclxuICAgICAgICAgICAgICAgdmFyICRvdXRwdXQgID0gJCgnPHNwYW4gY2xhc3M9XCJzZWxlY3QtaW5mb1wiLz4nKTtcclxuICAgICAgICAgICAgICAgYWRkKCRvdXRwdXQsICdyb3cnLCBjb3VudFJvd3MpO1xyXG5cclxuICAgICAgICAgICAgICAgdmFyICRleGlzdGluZyA9ICRlbC5jaGlsZHJlbignc3Bhbi5zZWxlY3QtaW5mbycpO1xyXG4gICAgICAgICAgICAgICBpZigkZXhpc3RpbmcubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgJGV4aXN0aW5nLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICBpZigkb3V0cHV0LnRleHQoKSAhPT0gJycpe1xyXG4gICAgICAgICAgICAgICAgICAkZWwuYXBwZW5kKCRvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgY2hlY2tib3ggaW4gdGhlIGNlbGwgY2FuIGJlIGNoZWNrZWRcclxuICAgICAgaXNDZWxsU2VsZWN0YWJsZTogZnVuY3Rpb24oY29sSWR4LCBjZWxsRGF0YSl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBJZiBkYXRhIGlzIGluIHRoZSBsaXN0IG9mIGRpc2FibGVkIGVsZW1lbnRzXHJcbiAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4LmNoZWNrYm94ZXMucy5kYXRhRGlzYWJsZWQsIGNvbElkeClcclxuICAgICAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN0eC5jaGVja2JveGVzLnMuZGF0YURpc2FibGVkW2NvbElkeF0sIGNlbGxEYXRhKVxyXG4gICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBjaGVja2JveCBjYW4gYmUgc2VsZWN0ZWRcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIEdldHMgY2VsbCBpbmRleFxyXG4gICAgICBnZXRDZWxsSW5kZXg6IGZ1bmN0aW9uKGNlbGwpe1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBkdCA9IHNlbGYucy5kdDtcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICAvLyBJZiBGaXhlZENvbHVtbnMgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZVxyXG4gICAgICAgICBpZihjdHguX29GaXhlZENvbHVtbnMpe1xyXG4gICAgICAgICAgICByZXR1cm4gZHQuZml4ZWRDb2x1bW5zKCkuY2VsbEluZGV4KGNlbGwpO1xyXG5cclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR0LmNlbGwoY2VsbCkuaW5kZXgoKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gR2V0cyBpbmRleCBvZiB0aGUgZmlyc3QgY29sdW1uIHRoYXQgaGFzIGNoZWNrYm94IGFuZCByb3cgc2VsZWN0aW9uIGVuYWJsZWRcclxuICAgICAgZ2V0U2VsZWN0Um93Q29sSW5kZXg6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGN0eCA9IHNlbGYucy5jdHg7XHJcblxyXG4gICAgICAgICB2YXIgY29sSWR4ID0gbnVsbDtcclxuXHJcbiAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjdHguYW9Db2x1bW5zLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgLy8gSWYgQ2hlY2tib3hlcyBleHRlbnNpb24gaXMgZW5hYmxlZFxyXG4gICAgICAgICAgICAvLyBhbmQgcm93IHNlbGVjdGlvbiBpcyBlbmFibGVkIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICAgICBpZihjdHguYW9Db2x1bW5zW2ldLmNoZWNrYm94ZXMgJiYgY3R4LmFvQ29sdW1uc1tpXS5jaGVja2JveGVzLnNlbGVjdFJvdyl7XHJcbiAgICAgICAgICAgICAgIGNvbElkeCA9IGk7XHJcbiAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIHJldHVybiBjb2xJZHg7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBVcGRhdGVzIGZpeGVkIGNvbHVtbiBpZiBGaXhlZENvbHVtbnMgZXh0ZW5zaW9uIGlzIGVuYWJsZWRcclxuICAgICAgLy8gYW5kIGdpdmVuIGNvbHVtbiBpcyBpbnNpZGUgYSBmaXhlZCBjb2x1bW5cclxuICAgICAgdXBkYXRlRml4ZWRDb2x1bW46IGZ1bmN0aW9uKGNvbElkeCl7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgdmFyIGR0ID0gc2VsZi5zLmR0O1xyXG4gICAgICAgICB2YXIgY3R4ID0gc2VsZi5zLmN0eDtcclxuXHJcbiAgICAgICAgIC8vIElmIEZpeGVkQ29sdW1ucyBleHRlbnNpb24gaXMgZW5hYmxlZFxyXG4gICAgICAgICBpZihjdHguX29GaXhlZENvbHVtbnMpe1xyXG4gICAgICAgICAgICB2YXIgbGVmdENvbHMgPSBjdHguX29GaXhlZENvbHVtbnMucy5pTGVmdENvbHVtbnM7XHJcbiAgICAgICAgICAgIHZhciByaWdodENvbHMgPSBjdHguYW9Db2x1bW5zLmxlbmd0aCAtIGN0eC5fb0ZpeGVkQ29sdW1ucy5zLmlSaWdodENvbHVtbnMgLSAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbElkeCA8IGxlZnRDb2xzIHx8IGNvbElkeCA+IHJpZ2h0Q29scyl7XHJcbiAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBzaG93biBpbiB0aGUgZml4ZWQgY29sdW1uXHJcbiAgICAgICAgICAgICAgIGR0LmZpeGVkQ29sdW1ucygpLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gVXNlIGRlbGF5IHRvIGxldCBGaXhlZENvbHVtbnMgY29uc3RydWN0IHRoZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgLy8gYmVmb3JlIHdlIHVwZGF0ZSB0aGUgXCJTZWxlY3QgYWxsXCIgY2hlY2tib3hcclxuICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAvLyBGb3IgZXZlcnkgY29sdW1uIHdoZXJlIGNoZWNrYm94ZXMgYXJlIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgJC5lYWNoKHNlbGYucy5jb2x1bW5zLCBmdW5jdGlvbihpbmRleCwgY29sSWR4KXtcclxuICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTZWxlY3RBbGwoY29sSWR4KTtcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9O1xyXG5cclxuXHJcbiAgIC8qKlxyXG4gICAqIENoZWNrYm94ZXMgZGVmYXVsdCBzZXR0aW5ncyBmb3IgaW5pdGlhbGlzYXRpb25cclxuICAgKlxyXG4gICAqIEBuYW1lc3BhY2VcclxuICAgKiBAbmFtZSBDaGVja2JveGVzLmRlZmF1bHRzXHJcbiAgICogQHN0YXRpY1xyXG4gICAqL1xyXG4gICBDaGVja2JveGVzLmRlZmF1bHRzID0ge1xyXG4gICAgICAvKipcclxuICAgICAgKiBFbmFibGUgLyBkaXNhYmxlIGNoZWNrYm94IHN0YXRlIGxvYWRpbmcvc2F2aW5nIGlmIHN0YXRlIHNhdmluZyBpcyBlbmFibGVkIGdsb2JhbGx5XHJcbiAgICAgICpcclxuICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgKiBAZGVmYXVsdCBgdHJ1ZWBcclxuICAgICAgKi9cclxuICAgICAgc3RhdGVTYXZlOiB0cnVlLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICogRW5hYmxlIC8gZGlzYWJsZSByb3cgc2VsZWN0aW9uXHJcbiAgICAgICpcclxuICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXHJcbiAgICAgICovXHJcbiAgICAgIHNlbGVjdFJvdzogZmFsc2UsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgKiBFbmFibGUgLyBkaXNhYmxlIFwic2VsZWN0IGFsbFwiIGNvbnRyb2wgaW4gdGhlIGhlYWRlclxyXG4gICAgICAqXHJcbiAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICogQGRlZmF1bHQgYHRydWVgXHJcbiAgICAgICovXHJcbiAgICAgIHNlbGVjdEFsbDogdHJ1ZSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAqIEVuYWJsZSAvIGRpc2FibGUgYWJpbGl0eSB0byBzZWxlY3QgY2hlY2tib3hlcyBmcm9tIGFsbCBwYWdlc1xyXG4gICAgICAqXHJcbiAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICogQGRlZmF1bHQgYHRydWVgXHJcbiAgICAgICovXHJcbiAgICAgIHNlbGVjdEFsbFBhZ2VzOiB0cnVlLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICogQ2hlY2tib3ggc2VsZWN0L2Rlc2VsZWN0IGNhbGxiYWNrXHJcbiAgICAgICpcclxuICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICogQGRlZmF1bHQgIGBudWxsYFxyXG4gICAgICAqL1xyXG4gICAgICBzZWxlY3RDYWxsYmFjazogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAqIFwiU2VsZWN0IGFsbFwiIGNvbnRyb2wgc2VsZWN0L2Rlc2VsZWN0IGNhbGxiYWNrXHJcbiAgICAgICpcclxuICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICogQGRlZmF1bHQgIGBudWxsYFxyXG4gICAgICAqL1xyXG4gICAgICBzZWxlY3RBbGxDYWxsYmFjazogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAqIFwiU2VsZWN0IGFsbFwiIGNvbnRyb2wgbWFya3VwXHJcbiAgICAgICpcclxuICAgICAgKiBAdHlwZSB7bWl4ZWR9XHJcbiAgICAgICogQGRlZmF1bHQgYDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIj5gXHJcbiAgICAgICovXHJcbiAgICAgIHNlbGVjdEFsbFJlbmRlcjogJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBhdXRvY29tcGxldGU9XCJvZmZcIj4nXHJcbiAgIH07XHJcblxyXG5cclxuICAgLypcclxuICAgKiBBUElcclxuICAgKi9cclxuICAgdmFyIEFwaSA9ICQuZm4uZGF0YVRhYmxlLkFwaTtcclxuXHJcbiAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgLSB3b3JrIGFyb3VuZCBmb3IgYSBidWcgaW4gRFQuLi4gTm90IGRvY3VtZW50ZWRcclxuICAgQXBpLnJlZ2lzdGVyKCAnY2hlY2tib3hlcygpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgfSApO1xyXG5cclxuICAgQXBpLnJlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmNoZWNrYm94ZXMuc2VsZWN0KCknLCAnY29sdW1uKCkuY2hlY2tib3hlcy5zZWxlY3QoKScsIGZ1bmN0aW9uICggc3RhdGUgKSB7XHJcbiAgICAgIGlmKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpeyBzdGF0ZSA9IHRydWU7IH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIGN0eCwgY29sSWR4LCBpLCBqLCByb3dzSWR4ICkge1xyXG4gICAgICAgICAvLyBJZiBDaGVja2JveGVzIGV4dGVuc2lvbiBpcyBlbmFibGVkIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICBpZihjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcyl7XHJcbiAgICAgICAgICAgIC8vIFByZXBhcmUgYSBsaXN0IG9mIGFsbCBjZWxsc1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBbXTtcclxuICAgICAgICAgICAgJC5lYWNoKHJvd3NJZHgsIGZ1bmN0aW9uKGluZGV4LCByb3dJZHgpe1xyXG4gICAgICAgICAgICAgICBzZWxlY3Rvci5wdXNoKHsgcm93OiByb3dJZHgsIGNvbHVtbjogY29sSWR4IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuY2VsbHMoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgY2VsbHNEYXRhID0gY2VsbHMuZGF0YSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcGFyZSBhIGxpc3Qgb2YgY2VsbHMgdGhhdCBjb250YWluIGNoZWNrYm94ZXMgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcclxuICAgICAgICAgICAgdmFyIHJvd3NTZWxlY3RhYmxlSWR4ID0gW107XHJcbiAgICAgICAgICAgIHNlbGVjdG9yID0gW107XHJcbiAgICAgICAgICAgICQuZWFjaChjZWxsc0RhdGEsIGZ1bmN0aW9uKGluZGV4LCBjZWxsRGF0YSl7XHJcbiAgICAgICAgICAgICAgIC8vIElmIGNoZWNrYm94IGluIHRoZSBjZWxsIGNhbiBiZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgICBpZihjdHguY2hlY2tib3hlcy5pc0NlbGxTZWxlY3RhYmxlKGNvbElkeCwgY2VsbERhdGEpKXtcclxuICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaCh7IHJvdzogcm93c0lkeFtpbmRleF0sIGNvbHVtbjogY29sSWR4IH0pO1xyXG4gICAgICAgICAgICAgICAgICByb3dzU2VsZWN0YWJsZUlkeC5wdXNoKHJvd3NJZHhbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNlbGxzID0gdGhpcy5jZWxscyhzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgICAgICBjdHguY2hlY2tib3hlcy51cGRhdGVEYXRhKGNlbGxzLCBjb2xJZHgsIHN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJvdyBzZWxlY3Rpb24gaXMgZW5hYmxlZFxyXG4gICAgICAgICAgICBpZihjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcy5zZWxlY3RSb3cpe1xyXG4gICAgICAgICAgICAgICBjdHguY2hlY2tib3hlcy51cGRhdGVTZWxlY3Qocm93c1NlbGVjdGFibGVJZHgsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3R4LmNoZWNrYm94ZXMudXBkYXRlQ2hlY2tib3goY2VsbHMsIGNvbElkeCwgc3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgY3R4LmNoZWNrYm94ZXMudXBkYXRlU2VsZWN0QWxsKGNvbElkeCk7XHJcblxyXG4gICAgICAgICAgICBjdHguY2hlY2tib3hlcy51cGRhdGVGaXhlZENvbHVtbihjb2xJZHgpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sIDEgKTtcclxuICAgfSApO1xyXG5cclxuICAgQXBpLnJlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jaGVja2JveGVzLnNlbGVjdCgpJywgJ2NlbGwoKS5jaGVja2JveGVzLnNlbGVjdCgpJywgZnVuY3Rpb24gKCBzdGF0ZSApIHtcclxuICAgICAgaWYodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJyl7IHN0YXRlID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBjdHgsIHJvd0lkeCwgY29sSWR4ICkge1xyXG4gICAgICAgICAvLyBJZiBDaGVja2JveGVzIGV4dGVuc2lvbiBpcyBlbmFibGVkIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICBpZihjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcyl7XHJcbiAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuY2VsbHMoW3sgcm93OiByb3dJZHgsIGNvbHVtbjogY29sSWR4IH1dKTtcclxuICAgICAgICAgICAgdmFyIGNlbGxEYXRhID0gdGhpcy5jZWxsKHsgcm93OiByb3dJZHgsIGNvbHVtbjogY29sSWR4IH0pLmRhdGEoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGNoZWNrYm94IGluIHRoZSBjZWxsIGNhbiBiZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICBpZihjdHguY2hlY2tib3hlcy5pc0NlbGxTZWxlY3RhYmxlKGNvbElkeCwgY2VsbERhdGEpKXtcclxuICAgICAgICAgICAgICAgY3R4LmNoZWNrYm94ZXMudXBkYXRlRGF0YShjZWxscywgY29sSWR4LCBzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiByb3cgc2VsZWN0aW9uIGlzIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgaWYoY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMuc2VsZWN0Um93KXtcclxuICAgICAgICAgICAgICAgICAgY3R4LmNoZWNrYm94ZXMudXBkYXRlU2VsZWN0KHJvd0lkeCwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICBjdHguY2hlY2tib3hlcy51cGRhdGVDaGVja2JveChjZWxscywgY29sSWR4LCBzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICBjdHguY2hlY2tib3hlcy51cGRhdGVTZWxlY3RBbGwoY29sSWR4KTtcclxuXHJcbiAgICAgICAgICAgICAgIGN0eC5jaGVja2JveGVzLnVwZGF0ZUZpeGVkQ29sdW1uKGNvbElkeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9LCAxICk7XHJcbiAgIH0gKTtcclxuXHJcbiAgIEFwaS5yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuY2hlY2tib3hlcy5lbmFibGUoKScsICdjZWxsKCkuY2hlY2tib3hlcy5lbmFibGUoKScsIGZ1bmN0aW9uICggc3RhdGUgKSB7XHJcbiAgICAgIGlmKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpeyBzdGF0ZSA9IHRydWU7IH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggY3R4LCByb3dJZHgsIGNvbElkeCApIHtcclxuICAgICAgICAgLy8gSWYgQ2hlY2tib3hlcyBleHRlbnNpb24gaXMgZW5hYmxlZCBmb3IgdGhpcyBjb2x1bW5cclxuICAgICAgICAgaWYoY3R4LmFvQ29sdW1uc1tjb2xJZHhdLmNoZWNrYm94ZXMpe1xyXG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbCh7IHJvdzogcm93SWR4LCBjb2x1bW46IGNvbElkeCB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBjZWxsIGRhdGFcclxuICAgICAgICAgICAgdmFyIGNlbGxEYXRhID0gY2VsbC5kYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBjaGVja2JveCBzaG91bGQgYmUgZW5hYmxlZFxyXG4gICAgICAgICAgICBpZihzdGF0ZSl7XHJcbiAgICAgICAgICAgICAgIGRlbGV0ZSBjdHguY2hlY2tib3hlcy5zLmRhdGFEaXNhYmxlZFtjb2xJZHhdW2NlbGxEYXRhXTtcclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgY2hlY2tib3ggc2hvdWxkIGJlIGRpc2FibGVkXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGN0eC5jaGVja2JveGVzLnMuZGF0YURpc2FibGVkW2NvbElkeF1bY2VsbERhdGFdID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGNlbGwgbm9kZSBpcyBhdmFpbGFibGVcclxuICAgICAgICAgICAgLy8gKGRlZmVyUmVuZGVyIGlzIG5vdCBlbmFibGVkIG9yIGNlbGwgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkKVxyXG4gICAgICAgICAgICB2YXIgY2VsbE5vZGUgPSBjZWxsLm5vZGUoKTtcclxuICAgICAgICAgICAgaWYoY2VsbE5vZGUpe1xyXG4gICAgICAgICAgICAgICAkKCdpbnB1dC5kdC1jaGVja2JveGVzJywgY2VsbE5vZGUpLnByb3AoJ2Rpc2FibGVkJywgIXN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgcm93IHNlbGVjdGlvbiBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgIC8vIGFuZCBjaGVja2JveCBjYW4gYmUgY2hlY2tlZFxyXG4gICAgICAgICAgICBpZihjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcy5zZWxlY3RSb3cpe1xyXG4gICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4LmNoZWNrYm94ZXMucy5kYXRhLCBjb2xJZHgpXHJcbiAgICAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdHguY2hlY2tib3hlcy5zLmRhdGFbY29sSWR4XSwgY2VsbERhdGEpXHJcbiAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGU6XHJcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGNoZWNrYm94IGlzIGVuYWJsZWQgdGhlbiBzZWxlY3Qgcm93O1xyXG4gICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGRlc2VsZWN0IHJvd1xyXG4gICAgICAgICAgICAgICAgICBjdHguY2hlY2tib3hlcy51cGRhdGVTZWxlY3Qocm93SWR4LCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH0sIDEgKTtcclxuICAgfSApO1xyXG5cclxuICAgQXBpLnJlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jaGVja2JveGVzLmRpc2FibGUoKScsICdjZWxsKCkuY2hlY2tib3hlcy5kaXNhYmxlKCknLCBmdW5jdGlvbiAoIHN0YXRlICkge1xyXG4gICAgICBpZih0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKXsgc3RhdGUgPSB0cnVlOyB9XHJcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrYm94ZXMuZW5hYmxlKCFzdGF0ZSk7XHJcbiAgIH0gKTtcclxuXHJcbiAgIEFwaS5yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5jaGVja2JveGVzLmRlc2VsZWN0KCknLCAnY29sdW1uKCkuY2hlY2tib3hlcy5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCBzdGF0ZSApIHtcclxuICAgICAgaWYodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJyl7IHN0YXRlID0gdHJ1ZTsgfVxyXG4gICAgICByZXR1cm4gdGhpcy5jaGVja2JveGVzLnNlbGVjdCghc3RhdGUpO1xyXG4gICB9ICk7XHJcblxyXG4gICBBcGkucmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmNoZWNrYm94ZXMuZGVzZWxlY3QoKScsICdjZWxsKCkuY2hlY2tib3hlcy5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCBzdGF0ZSApIHtcclxuICAgICAgaWYodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJyl7IHN0YXRlID0gdHJ1ZTsgfVxyXG4gICAgICByZXR1cm4gdGhpcy5jaGVja2JveGVzLnNlbGVjdCghc3RhdGUpO1xyXG4gICB9ICk7XHJcblxyXG4gICBBcGkucmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuY2hlY2tib3hlcy5kZXNlbGVjdEFsbCgpJywgJ2NvbHVtbigpLmNoZWNrYm94ZXMuZGVzZWxlY3RBbGwoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoY3R4LCBjb2xJZHgpe1xyXG4gICAgICAgICAvLyBJZiBDaGVja2JveGVzIGV4dGVuc2lvbiBpcyBlbmFibGVkIGZvciB0aGlzIGNvbHVtblxyXG4gICAgICAgICBpZihjdHguYW9Db2x1bW5zW2NvbElkeF0uY2hlY2tib3hlcyl7XHJcbiAgICAgICAgICAgIGN0eC5jaGVja2JveGVzLnMuZGF0YVtjb2xJZHhdID0ge307XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbihjb2xJZHgpLmNoZWNrYm94ZXMuc2VsZWN0KGZhbHNlKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9LCAxICk7XHJcbiAgIH0gKTtcclxuXHJcbiAgIEFwaS5yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5jaGVja2JveGVzLnNlbGVjdGVkKCknLCAnY29sdW1uKCkuY2hlY2tib3hlcy5zZWxlY3RlZCgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKCBjdHgsIGNvbElkeCwgaSwgaiwgcm93c0lkeCApIHtcclxuXHJcbiAgICAgICAgIC8vIElmIENoZWNrYm94ZXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQgZm9yIHRoaXMgY29sdW1uXHJcbiAgICAgICAgIGlmKGN0eC5hb0NvbHVtbnNbY29sSWR4XS5jaGVja2JveGVzKXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgbW9kZSBpcyBlbmFibGVkXHJcbiAgICAgICAgICAgIGlmKGN0eC5vRmVhdHVyZXMuYlNlcnZlclNpZGUpe1xyXG4gICAgICAgICAgICAgICAkLmVhY2goY3R4LmNoZWNrYm94ZXMucy5kYXRhW2NvbElkeF0sIGZ1bmN0aW9uKGNlbGxEYXRhKXtcclxuICAgICAgICAgICAgICAgICAgLy8gSWYgY2hlY2tib3ggaW4gdGhlIGNlbGwgY2FuIGJlIGNoZWNrZWRcclxuICAgICAgICAgICAgICAgICAgaWYoY3R4LmNoZWNrYm94ZXMuaXNDZWxsU2VsZWN0YWJsZShjb2xJZHgsIGNlbGxEYXRhKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChjZWxsRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgbW9kZSBpcyBub3QgZW5hYmxlZFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAvLyBQcmVwYXJlIGEgbGlzdCBvZiBhbGwgY2VsbHNcclxuICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gW107XHJcbiAgICAgICAgICAgICAgICQuZWFjaChyb3dzSWR4LCBmdW5jdGlvbihpbmRleCwgcm93SWR4KXtcclxuICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaCh7IHJvdzogcm93SWR4LCBjb2x1bW46IGNvbElkeCB9KTtcclxuICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBHZXQgYWxsIGNlbGxzIGRhdGFcclxuICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5jZWxscyhzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgIHZhciBjZWxsc0RhdGEgPSBjZWxscy5kYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBFbnVtZXJhdGUgYWxsIGNlbGxzIGRhdGFcclxuICAgICAgICAgICAgICAgJC5lYWNoKGNlbGxzRGF0YSwgZnVuY3Rpb24oaW5kZXgsIGNlbGxEYXRhKXtcclxuICAgICAgICAgICAgICAgICAgLy8gSWYgY2hlY2tib3ggaXMgY2hlY2tlZFxyXG4gICAgICAgICAgICAgICAgICBpZihcclxuICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN0eC5jaGVja2JveGVzLnMuZGF0YSwgY29sSWR4KVxyXG4gICAgICAgICAgICAgICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4LmNoZWNrYm94ZXMucy5kYXRhW2NvbElkeF0sIGNlbGxEYXRhKVxyXG4gICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY2hlY2tib3ggaW4gdGhlIGNlbGwgY2FuIGJlIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKGN0eC5jaGVja2JveGVzLmlzQ2VsbFNlbGVjdGFibGUoY29sSWR4LCBjZWxsRGF0YSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2VsbERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG5cclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0sIDEgKTtcclxuICAgfSApO1xyXG5cclxuXHJcbiAgIC8qKlxyXG4gICAgKiBWZXJzaW9uIGluZm9ybWF0aW9uXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIENoZWNrYm94ZXMudmVyc2lvblxyXG4gICAgKiBAc3RhdGljXHJcbiAgICAqL1xyXG4gICBDaGVja2JveGVzLnZlcnNpb24gPSAnMS4yLjEzJztcclxuXHJcblxyXG5cclxuICAgJC5mbi5EYXRhVGFibGUuQ2hlY2tib3hlcyA9IENoZWNrYm94ZXM7XHJcbiAgICQuZm4uZGF0YVRhYmxlLkNoZWNrYm94ZXMgPSBDaGVja2JveGVzO1xyXG5cclxuXHJcbiAgIC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBkb2N1bWVudCB3aGljaCBsaXN0ZW5zIGZvciBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uXHJcbiAgIC8vIGV2ZW50cyBzbyB3ZSBjYW4gYXV0b21hdGljYWxseSBpbml0aWFsaXNlXHJcbiAgICQoZG9jdW1lbnQpLm9uKCAncHJlSW5pdC5kdC5kdENoZWNrYm94ZXMnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MgLyosIGpzb24gKi8gKSB7XHJcbiAgICAgIGlmICggZS5uYW1lc3BhY2UgIT09ICdkdCcgKSB7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmV3IENoZWNrYm94ZXMoIHNldHRpbmdzICk7XHJcbiAgIH0gKTtcclxuXHJcblxyXG4gICByZXR1cm4gQ2hlY2tib3hlcztcclxufSkpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jquery-datatables-checkboxes/js/dataTables.checkboxes.js\n");

/***/ }),

/***/ "datatables.net":
/*!*********************************!*\
  !*** external "$.fn.dataTable" ***!
  \*********************************/
/***/ (function(module) {

"use strict";
module.exports = window["$.fn.dataTable"];

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module) {

"use strict";
module.exports = window["jQuery"];

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/datatables-checkboxes-jquery/datatables.checkboxes.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;