/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/datatables-select/datatables-select.js":
/*!*****************************************************!*\
  !*** ./libs/datatables-select/datatables-select.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var datatables_net_select_js_dataTables_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datatables.net-select/js/dataTables.select */ "./node_modules/datatables.net-select/js/dataTables.select.js");
/* harmony import */ var datatables_net_select_js_dataTables_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datatables_net_select_js_dataTables_select__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/datatables.net-select/js/dataTables.select.js":
/*!********************************************************************!*\
  !*** ./node_modules/datatables.net-select/js/dataTables.select.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Select for DataTables 1.4.0-dev\n * 2015-2021 SpryMedia Ltd - datatables.net/license/mit\n */\n\n/**\n * @summary     Select for DataTables\n * @description A collection of API methods, events and buttons for DataTables\n *   that provides selection options of the items in a DataTable\n * @version     1.4.0-dev\n * @file        dataTables.select.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     datatables.net/forums\n * @copyright   Copyright 2015-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net/extensions/select\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n// Version information for debugger\nDataTable.select = {};\n\nDataTable.select.version = '1.4.0-dev';\n\nDataTable.select.init = function ( dt ) {\n\tvar ctx = dt.settings()[0];\n\n\tif (ctx._select) {\n\t\treturn;\n\t}\n\n\tvar savedSelected = dt.state.loaded();\n\n\tvar selectAndSave = function(e, settings, data) {\n\t\tif(data === null || data.select === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear any currently selected rows, before restoring state\n\t\t// None will be selected on first initialisation\n\t\tif (dt.rows({selected: true}).any()) {\n\t\t\tdt.rows().deselect();\n\t\t}\n\t\tif (data.select.rows !== undefined) {\n\t\t\tdt.rows(data.select.rows).select();\n\t\t}\n\n\t\tif (dt.columns({selected: true}).any()) {\n\t\t\tdt.columns().deselect();\n\t\t}\n\t\tif (data.select.columns !== undefined) {\n\t\t\tdt.columns(data.select.columns).select();\n\t\t}\n\n\t\tif (dt.cells({selected: true}).any()) {\n\t\t\tdt.cells().deselect();\n\t\t}\n\t\tif (data.select.cells !== undefined) {\n\t\t\tfor(var i = 0; i < data.select.cells.length; i++) {\n\t\t\t\tdt.cell(data.select.cells[i].row, data.select.cells[i].column).select();\n\t\t\t}\n\t\t}\n\t\tdt.state.save();\n\t}\n\t\n\tdt.one('init', function() {\n\t\tdt.on('stateSaveParams', function(e, settings, data) {\n\t\t\tdata.select = {};\n\t\t\tdata.select.rows = dt.rows({selected:true}).ids(true).toArray();\n\t\t\tdata.select.columns = dt.columns({selected:true})[0];\n\t\t\tdata.select.cells = dt.cells({selected:true})[0].map(function(coords) {\n\t\t\t\treturn {row: dt.row(coords.row).id(true), column: coords.column}\n\t\t\t});\n\t\t})\n\t\t\n\t\tselectAndSave(undefined, undefined, savedSelected)\n\t\tdt.on('stateLoaded stateLoadParams', selectAndSave)\n\t})\n\n\tvar init = ctx.oInit.select;\n\tvar defaults = DataTable.defaults.select;\n\tvar opts = init === undefined ?\n\t\tdefaults :\n\t\tinit;\n\n\t// Set defaults\n\tvar items = 'row';\n\tvar style = 'api';\n\tvar blurable = false;\n\tvar toggleable = true;\n\tvar info = true;\n\tvar selector = 'td, th';\n\tvar className = 'selected';\n\tvar setStyle = false;\n\n\tctx._select = {};\n\n\t// Initialisation customisations\n\tif ( opts === true ) {\n\t\tstyle = 'os';\n\t\tsetStyle = true;\n\t}\n\telse if ( typeof opts === 'string' ) {\n\t\tstyle = opts;\n\t\tsetStyle = true;\n\t}\n\telse if ( $.isPlainObject( opts ) ) {\n\t\tif ( opts.blurable !== undefined ) {\n\t\t\tblurable = opts.blurable;\n\t\t}\n\t\t\n\t\tif ( opts.toggleable !== undefined ) {\n\t\t\ttoggleable = opts.toggleable;\n\t\t}\n\n\t\tif ( opts.info !== undefined ) {\n\t\t\tinfo = opts.info;\n\t\t}\n\n\t\tif ( opts.items !== undefined ) {\n\t\t\titems = opts.items;\n\t\t}\n\n\t\tif ( opts.style !== undefined ) {\n\t\t\tstyle = opts.style;\n\t\t\tsetStyle = true;\n\t\t}\n\t\telse {\n\t\t\tstyle = 'os';\n\t\t\tsetStyle = true;\n\t\t}\n\n\t\tif ( opts.selector !== undefined ) {\n\t\t\tselector = opts.selector;\n\t\t}\n\n\t\tif ( opts.className !== undefined ) {\n\t\t\tclassName = opts.className;\n\t\t}\n\t}\n\n\tdt.select.selector( selector );\n\tdt.select.items( items );\n\tdt.select.style( style );\n\tdt.select.blurable( blurable );\n\tdt.select.toggleable( toggleable );\n\tdt.select.info( info );\n\tctx._select.className = className;\n\n\n\t// Sort table based on selected rows. Requires Select Datatables extension\n\t$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {\n\t\treturn this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {\n\t\t\tif ( settings._select.items === 'row' ) {\n\t\t\t\treturn $( td ).parent().hasClass( settings._select.className );\n\t\t\t} else if ( settings._select.items === 'cell' ) {\n\t\t\t\treturn $( td ).hasClass( settings._select.className );\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t};\n\n\t// If the init options haven't enabled select, but there is a selectable\n\t// class name, then enable\n\tif ( ! setStyle && $( dt.table().node() ).hasClass( 'selectable' ) ) {\n\t\tdt.select.style( 'os' );\n\t}\n};\n\n/*\n\nSelect is a collection of API methods, event handlers, event emitters and\nbuttons (for the `Buttons` extension) for DataTables. It provides the following\nfeatures, with an overview of how they are implemented:\n\n## Selection of rows, columns and cells. Whether an item is selected or not is\n   stored in:\n\n* rows: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoData` object for each row\n* columns: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoColumns` object for each column\n* cells: a `_selected_cells` property which contains an array of boolean values\n  of the `aoData` object for each row. The array is the same length as the\n  columns array, with each element of it representing a cell.\n\nThis method of using boolean flags allows Select to operate when nodes have not\nbeen created for rows / cells (DataTables' defer rendering feature).\n\n## API methods\n\nA range of API methods are available for triggering selection and de-selection\nof rows. Methods are also available to configure the selection events that can\nbe triggered by an end user (such as which items are to be selected). To a large\nextent, these of API methods *is* Select. It is basically a collection of helper\nfunctions that can be used to select items in a DataTable.\n\nConfiguration of select is held in the object `_select` which is attached to the\nDataTables settings object on initialisation. Select being available on a table\nis not optional when Select is loaded, but its default is for selection only to\nbe available via the API - so the end user wouldn't be able to select rows\nwithout additional configuration.\n\nThe `_select` object contains the following properties:\n\n```\n{\n\titems:string       - Can be `rows`, `columns` or `cells`. Defines what item \n\t                     will be selected if the user is allowed to activate row\n\t                     selection using the mouse.\n\tstyle:string       - Can be `none`, `single`, `multi` or `os`. Defines the\n\t                     interaction style when selecting items\n\tblurable:boolean   - If row selection can be cleared by clicking outside of\n\t                     the table\n\ttoggleable:boolean - If row selection can be cancelled by repeated clicking\n\t                     on the row\n\tinfo:boolean       - If the selection summary should be shown in the table\n\t                     information elements\n}\n```\n\nIn addition to the API methods, Select also extends the DataTables selector\noptions for rows, columns and cells adding a `selected` option to the selector\noptions object, allowing the developer to select only selected items or\nunselected items.\n\n## Mouse selection of items\n\nClicking on items can be used to select items. This is done by a simple event\nhandler that will select the items using the API methods.\n\n */\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Local functions\n */\n\n/**\n * Add one or more cells to the selection when shift clicking in OS selection\n * style cell selection.\n *\n * Cell range is more complicated than row and column as we want to select\n * in the visible grid rather than by index in sequence. For example, if you\n * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1\n * should also be selected (and not 1-3, 1-4. etc)\n * \n * @param  {DataTable.Api} dt   DataTable\n * @param  {object}        idx  Cell index to select to\n * @param  {object}        last Cell index to select from\n * @private\n */\nfunction cellRange( dt, idx, last )\n{\n\tvar indexes;\n\tvar columnIndexes;\n\tvar rowIndexes;\n\tvar selectColumns = function ( start, end ) {\n\t\tif ( start > end ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\t\t\n\t\tvar record = false;\n\t\treturn dt.columns( ':visible' ).indexes().filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) { // not else if, as start might === end\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tvar selectRows = function ( start, end ) {\n\t\tvar indexes = dt.rows( { search: 'applied' } ).indexes();\n\n\t\t// Which comes first - might need to swap\n\t\tif ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\n\t\tvar record = false;\n\t\treturn indexes.filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) {\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tif ( ! dt.cells( { selected: true } ).any() && ! last ) {\n\t\t// select from the top left cell to this one\n\t\tcolumnIndexes = selectColumns( 0, idx.column );\n\t\trowIndexes = selectRows( 0 , idx.row );\n\t}\n\telse {\n\t\t// Get column indexes between old and new\n\t\tcolumnIndexes = selectColumns( last.column, idx.column );\n\t\trowIndexes = selectRows( last.row , idx.row );\n\t}\n\n\tindexes = dt.cells( rowIndexes, columnIndexes ).flatten();\n\n\tif ( ! dt.cells( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt.cells( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range\n\t\tdt.cells( indexes ).deselect();\n\t}\n}\n\n/**\n * Disable mouse selection by removing the selectors\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction disableMouseSelection( dt )\n{\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\n\t$( dt.table().container() )\n\t\t.off( 'mousedown.dtSelect', selector )\n\t\t.off( 'mouseup.dtSelect', selector )\n\t\t.off( 'click.dtSelect', selector );\n\n\t$('body').off( 'click.dtSelect' + _safeId(dt.table().node()) );\n}\n\n/**\n * Attach mouse listeners to the table to allow mouse selection of items\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction enableMouseSelection ( dt )\n{\n\tvar container = $( dt.table().container() );\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\tvar matchSelection;\n\n\tcontainer\n\t\t.on( 'mousedown.dtSelect', selector, function(e) {\n\t\t\t// Disallow text selection for shift clicking on the table so multi\n\t\t\t// element selection doesn't look terrible!\n\t\t\tif ( e.shiftKey || e.metaKey || e.ctrlKey ) {\n\t\t\t\tcontainer\n\t\t\t\t\t.css( '-moz-user-select', 'none' )\n\t\t\t\t\t.one('selectstart.dtSelect', selector, function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} );\n\t\t\t}\n\n\t\t\tif ( window.getSelection ) {\n\t\t\t\tmatchSelection = window.getSelection();\n\t\t\t}\n\t\t} )\n\t\t.on( 'mouseup.dtSelect', selector, function() {\n\t\t\t// Allow text selection to occur again, Mozilla style (tested in FF\n\t\t\t// 35.0.1 - still required)\n\t\t\tcontainer.css( '-moz-user-select', '' );\n\t\t} )\n\t\t.on( 'click.dtSelect', selector, function ( e ) {\n\t\t\tvar items = dt.select.items();\n\t\t\tvar idx;\n\n\t\t\t// If text was selected (click and drag), then we shouldn't change\n\t\t\t// the row's selected state\n\t\t\tif ( matchSelection ) {\n\t\t\t\tvar selection = window.getSelection();\n\n\t\t\t\t// If the element that contains the selection is not in the table, we can ignore it\n\t\t\t\t// This can happen if the developer selects text from the click event\n\t\t\t\tif ( ! selection.anchorNode || $(selection.anchorNode).closest('table')[0] === dt.table().node() ) {\n\t\t\t\t\tif ( selection !== matchSelection ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = dt.settings()[0];\n\t\t\tvar wrapperClass = dt.settings()[0].oClasses.sWrapper.trim().replace(/ +/g, '.');\n\n\t\t\t// Ignore clicks inside a sub-table\n\t\t\tif ( $(e.target).closest('div.'+wrapperClass)[0] != dt.table().container() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cell = dt.cell( $(e.target).closest('td, th') );\n\n\t\t\t// Check the cell actually belongs to the host DataTable (so child\n\t\t\t// rows, etc, are ignored)\n\t\t\tif ( ! cell.any() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('user-select.dt');\n\t\t\teventTrigger( dt, event, [ items, cell, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cellIndex = cell.index();\n\t\t\tif ( items === 'row' ) {\n\t\t\t\tidx = cellIndex.row;\n\t\t\t\ttypeSelect( e, dt, ctx, 'row', idx );\n\t\t\t}\n\t\t\telse if ( items === 'column' ) {\n\t\t\t\tidx = cell.index().column;\n\t\t\t\ttypeSelect( e, dt, ctx, 'column', idx );\n\t\t\t}\n\t\t\telse if ( items === 'cell' ) {\n\t\t\t\tidx = cell.index();\n\t\t\t\ttypeSelect( e, dt, ctx, 'cell', idx );\n\t\t\t}\n\n\t\t\tctx._select_lastCell = cellIndex;\n\t\t} );\n\n\t// Blurable\n\t$('body').on( 'click.dtSelect' + _safeId(dt.table().node()), function ( e ) {\n\t\tif ( ctx._select.blurable ) {\n\t\t\t// If the click was inside the DataTables container, don't blur\n\t\t\tif ( $(e.target).parents().filter( dt.table().container() ).length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore elements which have been removed from the DOM (i.e. paging\n\t\t\t// buttons)\n\t\t\tif ( $(e.target).parents('html').length === 0 ) {\n\t\t\t \treturn;\n\t\t\t}\n\n\t\t\t// Don't blur in Editor form\n\t\t\tif ( $(e.target).parents('div.DTE').length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('select-blur.dt');\n\t\t\teventTrigger( dt, event, [ e.target, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclear( ctx, true );\n\t\t}\n\t} );\n}\n\n/**\n * Trigger an event on a DataTable\n *\n * @param {DataTable.Api} api      DataTable to trigger events on\n * @param  {boolean}      selected true if selected, false if deselected\n * @param  {string}       type     Item type acting on\n * @param  {boolean}      any      Require that there are values before\n *     triggering\n * @private\n */\nfunction eventTrigger ( api, type, args, any )\n{\n\tif ( any && ! api.flatten().length ) {\n\t\treturn;\n\t}\n\n\tif ( typeof type === 'string' ) {\n\t\ttype = type +'.dt';\n\t}\n\n\targs.unshift( api );\n\n\t$(api.table().node()).trigger( type, args );\n}\n\n/**\n * Update the information element of the DataTable showing information about the\n * items selected. This is done by adding tags to the existing text\n * \n * @param {DataTable.Api} api DataTable to update\n * @private\n */\nfunction info ( api )\n{\n\tvar ctx = api.settings()[0];\n\n\tif ( ! ctx._select.info || ! ctx.aanFeatures.i ) {\n\t\treturn;\n\t}\n\n\tif ( api.select.style() === 'api' ) {\n\t\treturn;\n\t}\n\n\tvar rows    = api.rows( { selected: true } ).flatten().length;\n\tvar columns = api.columns( { selected: true } ).flatten().length;\n\tvar cells   = api.cells( { selected: true } ).flatten().length;\n\n\tvar add = function ( el, name, num ) {\n\t\tel.append( $('<span class=\"select-item\"/>').append( api.i18n(\n\t\t\t'select.'+name+'s',\n\t\t\t{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },\n\t\t\tnum\n\t\t) ) );\n\t};\n\n\t// Internal knowledge of DataTables to loop over all information elements\n\t$.each( ctx.aanFeatures.i, function ( i, el ) {\n\t\tel = $(el);\n\n\t\tvar output  = $('<span class=\"select-info\"/>');\n\t\tadd( output, 'row', rows );\n\t\tadd( output, 'column', columns );\n\t\tadd( output, 'cell', cells  );\n\n\t\tvar exisiting = el.children('span.select-info');\n\t\tif ( exisiting.length ) {\n\t\t\texisiting.remove();\n\t\t}\n\n\t\tif ( output.text() !== '' ) {\n\t\t\tel.append( output );\n\t\t}\n\t} );\n}\n\n/**\n * Initialisation of a new table. Attach event handlers and callbacks to allow\n * Select to operate correctly.\n *\n * This will occur _after_ the initial DataTables initialisation, although\n * before Ajax data is rendered, if there is ajax data\n *\n * @param  {DataTable.settings} ctx Settings object to operate on\n * @private\n */\nfunction init ( ctx ) {\n\tvar api = new DataTable.Api( ctx );\n\tctx._select_init = true;\n\n\t// Row callback so that classes can be added to rows and cells if the item\n\t// was selected before the element was created. This will happen with the\n\t// `deferRender` option enabled.\n\t// \n\t// This method of attaching to `aoRowCreatedCallback` is a hack until\n\t// DataTables has proper events for row manipulation If you are reviewing\n\t// this code to create your own plug-ins, please do not do this!\n\tctx.aoRowCreatedCallback.push( {\n\t\tfn: function ( row, data, index ) {\n\t\t\tvar i, ien;\n\t\t\tvar d = ctx.aoData[ index ];\n\n\t\t\t// Row\n\t\t\tif ( d._select_selected ) {\n\t\t\t\t$( row ).addClass( ctx._select.className );\n\t\t\t}\n\n\t\t\t// Cells and columns - if separated out, we would need to do two\n\t\t\t// loops, so it makes sense to combine them into a single one\n\t\t\tfor ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {\n\t\t\t\tif ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {\n\t\t\t\t\t$(d.anCells[i]).addClass( ctx._select.className );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsName: 'select-deferRender'\n\t} );\n\n\t// On Ajax reload we want to reselect all rows which are currently selected,\n\t// if there is an rowId (i.e. a unique value to identify each row with)\n\tapi.on( 'preXhr.dt.dtSelect', function (e, settings) {\n\t\tif (settings !== api.settings()[0]) {\n\t\t\t// Not triggered by our DataTable!\n\t\t\treturn;\n\t\t}\n\n\t\t// note that column selection doesn't need to be cached and then\n\t\t// reselected, as they are already selected\n\t\tvar rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\tvar cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {\n\t\t\tvar id = api.row( cellIdx.row ).id( true );\n\t\t\treturn id ?\n\t\t\t\t{ row: id, column: cellIdx.column } :\n\t\t\t\tundefined;\n\t\t} ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\t// On the next draw, reselect the currently selected items\n\t\tapi.one( 'draw.dt.dtSelect', function () {\n\t\t\tapi.rows( rows ).select();\n\n\t\t\t// `cells` is not a cell index selector, so it needs a loop\n\t\t\tif ( cells.any() ) {\n\t\t\t\tcells.each( function ( id ) {\n\t\t\t\t\tapi.cells( id.row, id.column ).select();\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t} );\n\n\t// Update the table information element with selected item summary\n\tapi.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {\n\t\tinfo( api );\n\t\tapi.state.save();\n\t} );\n\n\t// Clean up and release\n\tapi.on( 'destroy.dtSelect', function () {\n\t\tapi.rows({selected: true}).deselect();\n\n\t\tdisableMouseSelection( api );\n\t\tapi.off( '.dtSelect' );\n\t\t$('body').off('.dtSelect' + _safeId(api.table().node()));\n\t} );\n}\n\n/**\n * Add one or more items (rows or columns) to the selection when shift clicking\n * in OS selection style\n *\n * @param  {DataTable.Api} dt   DataTable\n * @param  {string}        type Row or column range selector\n * @param  {object}        idx  Item index to select to\n * @param  {object}        last Item index to select from\n * @private\n */\nfunction rowColumnRange( dt, type, idx, last )\n{\n\t// Add a range of rows from the last selected row to this one\n\tvar indexes = dt[type+'s']( { search: 'applied' } ).indexes();\n\tvar idx1 = $.inArray( last, indexes );\n\tvar idx2 = $.inArray( idx, indexes );\n\n\tif ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {\n\t\t// select from top to here - slightly odd, but both Windows and Mac OS\n\t\t// do this\n\t\tindexes.splice( $.inArray( idx, indexes )+1, indexes.length );\n\t}\n\telse {\n\t\t// reverse so we can shift click 'up' as well as down\n\t\tif ( idx1 > idx2 ) {\n\t\t\tvar tmp = idx2;\n\t\t\tidx2 = idx1;\n\t\t\tidx1 = tmp;\n\t\t}\n\n\t\tindexes.splice( idx2+1, indexes.length );\n\t\tindexes.splice( 0, idx1 );\n\t}\n\n\tif ( ! dt[type]( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt[type+'s']( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range - need to keep the clicked on row selected\n\t\tindexes.splice( $.inArray( idx, indexes ), 1 );\n\t\tdt[type+'s']( indexes ).deselect();\n\t}\n}\n\n/**\n * Clear all selected items\n *\n * @param  {DataTable.settings} ctx Settings object of the host DataTable\n * @param  {boolean} [force=false] Force the de-selection to happen, regardless\n *     of selection style\n * @private\n */\nfunction clear( ctx, force )\n{\n\tif ( force || ctx._select.style === 'single' ) {\n\t\tvar api = new DataTable.Api( ctx );\n\t\t\n\t\tapi.rows( { selected: true } ).deselect();\n\t\tapi.columns( { selected: true } ).deselect();\n\t\tapi.cells( { selected: true } ).deselect();\n\t}\n}\n\n/**\n * Select items based on the current configuration for style and items.\n *\n * @param  {object}             e    Mouse event object\n * @param  {DataTables.Api}     dt   DataTable\n * @param  {DataTable.settings} ctx  Settings object of the host DataTable\n * @param  {string}             type Items to select\n * @param  {int|object}         idx  Index of the item to select\n * @private\n */\nfunction typeSelect ( e, dt, ctx, type, idx )\n{\n\tvar style = dt.select.style();\n\tvar toggleable = dt.select.toggleable();\n\tvar isSelected = dt[type]( idx, { selected: true } ).any();\n\t\n\tif ( isSelected && ! toggleable ) {\n\t\treturn;\n\t}\n\n\tif ( style === 'os' ) {\n\t\tif ( e.ctrlKey || e.metaKey ) {\n\t\t\t// Add or remove from the selection\n\t\t\tdt[type]( idx ).select( ! isSelected );\n\t\t}\n\t\telse if ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No cmd or shift click - deselect if selected, or select\n\t\t\t// this row only\n\t\t\tvar selected = dt[type+'s']( { selected: true } );\n\n\t\t\tif ( isSelected && selected.flatten().length === 1 ) {\n\t\t\t\tdt[type]( idx ).deselect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselected.deselect();\n\t\t\t\tdt[type]( idx ).select();\n\t\t\t}\n\t\t}\n\t} else if ( style == 'multi+shift' ) {\n\t\tif ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdt[ type ]( idx ).select( ! isSelected );\n\t\t}\n\t}\n\telse {\n\t\tdt[ type ]( idx ).select( ! isSelected );\n\t}\n}\n\nfunction _safeId( node ) {\n\treturn node.id.replace(/[^a-zA-Z0-9\\-\\_]/g, '-');\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables selectors\n */\n\n// row and column are basically identical just assigned to different properties\n// and checking a different array, so we can dynamically create the functions to\n// reduce the code size\n$.each( [\n\t{ type: 'row', prop: 'aoData' },\n\t{ type: 'column', prop: 'aoColumns' }\n], function ( i, o ) {\n\tDataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {\n\t\tvar selected = opts.selected;\n\t\tvar data;\n\t\tvar out = [];\n\n\t\tif ( selected !== true && selected !== false ) {\n\t\t\treturn indexes;\n\t\t}\n\n\t\tfor ( var i=0, ien=indexes.length ; i<ien ; i++ ) {\n\t\t\tdata = settings[ o.prop ][ indexes[i] ];\n\n\t\t\tif ( (selected === true && data._select_selected === true) ||\n\t\t\t     (selected === false && ! data._select_selected )\n\t\t\t) {\n\t\t\t\tout.push( indexes[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t} );\n} );\n\nDataTable.ext.selector.cell.push( function ( settings, opts, cells ) {\n\tvar selected = opts.selected;\n\tvar rowData;\n\tvar out = [];\n\n\tif ( selected === undefined ) {\n\t\treturn cells;\n\t}\n\n\tfor ( var i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\trowData = settings.aoData[ cells[i].row ];\n\n\t\tif ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||\n\t\t     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )\n\t\t) {\n\t\t\tout.push( cells[i] );\n\t\t}\n\t}\n\n\treturn out;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API\n *\n * For complete documentation, please refer to the docs/api directory or the\n * DataTables site\n */\n\n// Local variables to improve compression\nvar apiRegister = DataTable.Api.register;\nvar apiRegisterPlural = DataTable.Api.registerPlural;\n\napiRegister( 'select()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tDataTable.select.init( new DataTable.Api( ctx ) );\n\t} );\n} );\n\napiRegister( 'select.blurable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.blurable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.blurable = flag;\n\t} );\n} );\n\napiRegister( 'select.toggleable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.toggleable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.toggleable = flag;\n\t} );\n} );\n\napiRegister( 'select.info()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.info;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.info = flag;\n\t} );\n} );\n\napiRegister( 'select.items()', function ( items ) {\n\tif ( items === undefined ) {\n\t\treturn this.context[0]._select.items;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.items = items;\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );\n\t} );\n} );\n\n// Takes effect from the _next_ selection. None disables future selection, but\n// does not clear the current selection. Use the `deselect` methods for that\napiRegister( 'select.style()', function ( style ) {\n\tif ( style === undefined ) {\n\t\treturn this.context[0]._select.style;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ! ctx._select ) {\n\t\t\tDataTable.select.init( new DataTable.Api(ctx) );\n\t\t}\n\n\t\tif ( ! ctx._select_init ) {\n\t\t\tinit(ctx);\n\t\t}\n\n\t\tctx._select.style = style;\n\n\t\t// Add / remove mouse event handlers. They aren't required when only\n\t\t// API selection is available\n\t\tvar dt = new DataTable.Api( ctx );\n\t\tdisableMouseSelection( dt );\n\t\t\n\t\tif ( style !== 'api' ) {\n\t\t\tenableMouseSelection( dt );\n\t\t}\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );\n\t} );\n} );\n\napiRegister( 'select.selector()', function ( selector ) {\n\tif ( selector === undefined ) {\n\t\treturn this.context[0]._select.selector;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tdisableMouseSelection( new DataTable.Api( ctx ) );\n\n\t\tctx._select.selector = selector;\n\n\t\tif ( ctx._select.style !== 'api' ) {\n\t\t\tenableMouseSelection( new DataTable.Api( ctx ) );\n\t\t}\n\t} );\n} );\n\n\n\napiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoData[ idx ]._select_selected = true;\n\t\t$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'row().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (\n\t\tctx &&\n\t\tthis.length &&\n\t\tctx.aoData[this[0]] &&\n\t\tctx.aoData[this[0]]._select_selected\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n} );\n\napiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoColumns[ idx ]._select_selected = true;\n\n\t\tvar column = new DataTable.Api( ctx ).column( idx );\n\n\t\t$( column.header() ).addClass( ctx._select.className );\n\t\t$( column.footer() ).addClass( ctx._select.className );\n\n\t\tcolumn.nodes().to$().addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'column().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (\n\t\tctx &&\n\t\tthis.length &&\n\t\tctx.aoColumns[this[0]] &&\n\t\tctx.aoColumns[this[0]]._select_selected\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n} );\n\napiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tclear( ctx );\n\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif ( data._selected_cells === undefined ) {\n\t\t\tdata._selected_cells = [];\n\t\t}\n\n\t\tdata._selected_cells[ colIdx ] = true;\n\n\t\tif ( data.anCells ) {\n\t\t\t$( data.anCells[ colIdx ] ).addClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'cell', api.cells(api[i]).indexes().toArray() ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'cell().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length) {\n\t\tvar row = ctx.aoData[this[0][0].row];\n\n\t\tif (row && row._selected_cells && row._selected_cells[this[0][0].column]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n} );\n\n\napiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tctx.aoData[ idx ]._select_selected = false;\n\t\tctx._select_lastCell = null;\n\t\t$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tctx.aoColumns[ idx ]._select_selected = false;\n\n\t\tvar api = new DataTable.Api( ctx );\n\t\tvar column = api.column( idx );\n\n\t\t$( column.header() ).removeClass( ctx._select.className );\n\t\t$( column.footer() ).removeClass( ctx._select.className );\n\n\t\t// Need to loop over each cell, rather than just using\n\t\t// `column().nodes()` as cells which are individually selected should\n\t\t// not have the `selected` class removed from them\n\t\tapi.cells( null, idx ).indexes().each( function (cellIdx) {\n\t\t\tvar data = ctx.aoData[ cellIdx.row ];\n\t\t\tvar cellSelected = data._selected_cells;\n\n\t\t\tif ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {\n\t\t\t\t$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );\n\t\t\t}\n\t\t} );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif(data._selected_cells !== undefined) {\n\t\t\tdata._selected_cells[ colIdx ] = false;\n\t\t}\n\n\t\t// Remove class only if the cells exist, and the cell is not column\n\t\t// selected, in which case the class should remain (since it is selected\n\t\t// in the column)\n\t\tif ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {\n\t\t\t$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'cell', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Buttons\n */\nfunction i18n( label, def ) {\n\treturn function (dt) {\n\t\treturn dt.i18n( 'buttons.'+label, def );\n\t};\n}\n\n// Common events with suitable namespaces\nfunction namespacedEvents ( config ) {\n\tvar unique = config._eventNamespace;\n\n\treturn 'draw.dt.DT'+unique+' select.dt.DT'+unique+' deselect.dt.DT'+unique;\n}\n\nfunction enabled ( dt, config ) {\n\tif ( $.inArray( 'rows', config.limitTo ) !== -1 && dt.rows( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'columns', config.limitTo ) !== -1 && dt.columns( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'cells', config.limitTo ) !== -1 && dt.cells( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvar _buttonNamespace = 0;\n\n$.extend( DataTable.ext.buttons, {\n\tselected: {\n\t\ttext: i18n( 'selected', 'Selected' ),\n\t\tclassName: 'buttons-selected',\n\t\tlimitTo: [ 'rows', 'columns', 'cells' ],\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\t// .DT namespace listeners are removed by DataTables automatically\n\t\t\t// on table destroy\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tthat.enable( enabled(dt, config) );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectedSingle: {\n\t\ttext: i18n( 'selectedSingle', 'Selected single' ),\n\t\tclassName: 'buttons-selected-single',\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count === 1 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectAll: {\n\t\ttext: i18n( 'selectAll', 'Select all' ),\n\t\tclassName: 'buttons-select-all',\n\t\taction: function () {\n\t\t\tvar items = this.select.items();\n\t\t\tthis[ items+'s' ]().select();\n\t\t}\n\t},\n\tselectNone: {\n\t\ttext: i18n( 'selectNone', 'Deselect all' ),\n\t\tclassName: 'buttons-select-none',\n\t\taction: function () {\n\t\t\tclear( this.settings()[0], true );\n\t\t},\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count > 0 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t}\n} );\n\n$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {\n\tvar lc = item.toLowerCase();\n\n\tDataTable.ext.buttons[ 'select'+item+'s' ] = {\n\t\ttext: i18n( 'select'+item+'s', 'Select '+lc+'s' ),\n\t\tclassName: 'buttons-select-'+lc+'s',\n\t\taction: function () {\n\t\t\tthis.select.items( lc );\n\t\t},\n\t\tinit: function ( dt ) {\n\t\t\tvar that = this;\n\n\t\t\tdt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {\n\t\t\t\tthat.active( items === lc );\n\t\t\t} );\n\t\t}\n\t};\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n */\n\n// DataTables creation - check if select has been defined in the options. Note\n// this required that the table be in the document! If it isn't then something\n// needs to trigger this method unfortunately. The next major release of\n// DataTables will rework the events and address this.\n$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tDataTable.select.init( new DataTable.Api( ctx ) );\n} );\n\n\nreturn DataTable.select;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0L2pzL2RhdGFUYWJsZXMuc2VsZWN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLDJDQUFRLEVBQUUsMkRBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFpQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLHFDQUFxQyxjQUFjO0FBQ25ELGlDQUFpQyxjQUFjO0FBQy9DLFlBQVk7QUFDWixJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7OztBQUlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBOztBQUVBLHFFQUFxRSxpQkFBaUI7QUFDdEY7QUFDQTs7QUFFQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1Qyw4QkFBOEIsaUJBQWlCO0FBQy9DLDRCQUE0QixpQkFBaUI7O0FBRTdDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDLDhCQUE4QixpQkFBaUI7QUFDL0MsNEJBQTRCLGlCQUFpQjs7QUFFN0M7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1zZWxlY3QvanMvZGF0YVRhYmxlcy5zZWxlY3QuanM/MjhhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgU2VsZWN0IGZvciBEYXRhVGFibGVzIDEuNC4wLWRldlxuICogMjAxNS0yMDIxIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIFNlbGVjdCBmb3IgRGF0YVRhYmxlc1xuICogQGRlc2NyaXB0aW9uIEEgY29sbGVjdGlvbiBvZiBBUEkgbWV0aG9kcywgZXZlbnRzIGFuZCBidXR0b25zIGZvciBEYXRhVGFibGVzXG4gKiAgIHRoYXQgcHJvdmlkZXMgc2VsZWN0aW9uIG9wdGlvbnMgb2YgdGhlIGl0ZW1zIGluIGEgRGF0YVRhYmxlXG4gKiBAdmVyc2lvbiAgICAgMS40LjAtZGV2XG4gKiBAZmlsZSAgICAgICAgZGF0YVRhYmxlcy5zZWxlY3QuanNcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkICh3d3cuc3ByeW1lZGlhLmNvLnVrKVxuICogQGNvbnRhY3QgICAgIGRhdGF0YWJsZXMubmV0L2ZvcnVtc1xuICogQGNvcHlyaWdodCAgIENvcHlyaWdodCAyMDE1LTIwMjEgU3ByeU1lZGlhIEx0ZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIGF2YWlsYWJsZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKiAgIE1JVCBsaWNlbnNlIC0gaHR0cDovL2RhdGF0YWJsZXMubmV0L2xpY2Vuc2UvbWl0XG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldC9leHRlbnNpb25zL3NlbGVjdFxuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vLyBWZXJzaW9uIGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dlclxuRGF0YVRhYmxlLnNlbGVjdCA9IHt9O1xuXG5EYXRhVGFibGUuc2VsZWN0LnZlcnNpb24gPSAnMS40LjAtZGV2JztcblxuRGF0YVRhYmxlLnNlbGVjdC5pbml0ID0gZnVuY3Rpb24gKCBkdCApIHtcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cblx0aWYgKGN0eC5fc2VsZWN0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHNhdmVkU2VsZWN0ZWQgPSBkdC5zdGF0ZS5sb2FkZWQoKTtcblxuXHR2YXIgc2VsZWN0QW5kU2F2ZSA9IGZ1bmN0aW9uKGUsIHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0aWYoZGF0YSA9PT0gbnVsbCB8fCBkYXRhLnNlbGVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYXIgYW55IGN1cnJlbnRseSBzZWxlY3RlZCByb3dzLCBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlXG5cdFx0Ly8gTm9uZSB3aWxsIGJlIHNlbGVjdGVkIG9uIGZpcnN0IGluaXRpYWxpc2F0aW9uXG5cdFx0aWYgKGR0LnJvd3Moe3NlbGVjdGVkOiB0cnVlfSkuYW55KCkpIHtcblx0XHRcdGR0LnJvd3MoKS5kZXNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3Qucm93cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdC5yb3dzKGRhdGEuc2VsZWN0LnJvd3MpLnNlbGVjdCgpO1xuXHRcdH1cblxuXHRcdGlmIChkdC5jb2x1bW5zKHtzZWxlY3RlZDogdHJ1ZX0pLmFueSgpKSB7XG5cdFx0XHRkdC5jb2x1bW5zKCkuZGVzZWxlY3QoKTtcblx0XHR9XG5cdFx0aWYgKGRhdGEuc2VsZWN0LmNvbHVtbnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZHQuY29sdW1ucyhkYXRhLnNlbGVjdC5jb2x1bW5zKS5zZWxlY3QoKTtcblx0XHR9XG5cblx0XHRpZiAoZHQuY2VsbHMoe3NlbGVjdGVkOiB0cnVlfSkuYW55KCkpIHtcblx0XHRcdGR0LmNlbGxzKCkuZGVzZWxlY3QoKTtcblx0XHR9XG5cdFx0aWYgKGRhdGEuc2VsZWN0LmNlbGxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLnNlbGVjdC5jZWxscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkdC5jZWxsKGRhdGEuc2VsZWN0LmNlbGxzW2ldLnJvdywgZGF0YS5zZWxlY3QuY2VsbHNbaV0uY29sdW1uKS5zZWxlY3QoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZHQuc3RhdGUuc2F2ZSgpO1xuXHR9XG5cdFxuXHRkdC5vbmUoJ2luaXQnLCBmdW5jdGlvbigpIHtcblx0XHRkdC5vbignc3RhdGVTYXZlUGFyYW1zJywgZnVuY3Rpb24oZSwgc2V0dGluZ3MsIGRhdGEpIHtcblx0XHRcdGRhdGEuc2VsZWN0ID0ge307XG5cdFx0XHRkYXRhLnNlbGVjdC5yb3dzID0gZHQucm93cyh7c2VsZWN0ZWQ6dHJ1ZX0pLmlkcyh0cnVlKS50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnNlbGVjdC5jb2x1bW5zID0gZHQuY29sdW1ucyh7c2VsZWN0ZWQ6dHJ1ZX0pWzBdO1xuXHRcdFx0ZGF0YS5zZWxlY3QuY2VsbHMgPSBkdC5jZWxscyh7c2VsZWN0ZWQ6dHJ1ZX0pWzBdLm1hcChmdW5jdGlvbihjb29yZHMpIHtcblx0XHRcdFx0cmV0dXJuIHtyb3c6IGR0LnJvdyhjb29yZHMucm93KS5pZCh0cnVlKSwgY29sdW1uOiBjb29yZHMuY29sdW1ufVxuXHRcdFx0fSk7XG5cdFx0fSlcblx0XHRcblx0XHRzZWxlY3RBbmRTYXZlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzYXZlZFNlbGVjdGVkKVxuXHRcdGR0Lm9uKCdzdGF0ZUxvYWRlZCBzdGF0ZUxvYWRQYXJhbXMnLCBzZWxlY3RBbmRTYXZlKVxuXHR9KVxuXG5cdHZhciBpbml0ID0gY3R4Lm9Jbml0LnNlbGVjdDtcblx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLnNlbGVjdDtcblx0dmFyIG9wdHMgPSBpbml0ID09PSB1bmRlZmluZWQgP1xuXHRcdGRlZmF1bHRzIDpcblx0XHRpbml0O1xuXG5cdC8vIFNldCBkZWZhdWx0c1xuXHR2YXIgaXRlbXMgPSAncm93Jztcblx0dmFyIHN0eWxlID0gJ2FwaSc7XG5cdHZhciBibHVyYWJsZSA9IGZhbHNlO1xuXHR2YXIgdG9nZ2xlYWJsZSA9IHRydWU7XG5cdHZhciBpbmZvID0gdHJ1ZTtcblx0dmFyIHNlbGVjdG9yID0gJ3RkLCB0aCc7XG5cdHZhciBjbGFzc05hbWUgPSAnc2VsZWN0ZWQnO1xuXHR2YXIgc2V0U3R5bGUgPSBmYWxzZTtcblxuXHRjdHguX3NlbGVjdCA9IHt9O1xuXG5cdC8vIEluaXRpYWxpc2F0aW9uIGN1c3RvbWlzYXRpb25zXG5cdGlmICggb3B0cyA9PT0gdHJ1ZSApIHtcblx0XHRzdHlsZSA9ICdvcyc7XG5cdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0c3R5bGUgPSBvcHRzO1xuXHRcdHNldFN0eWxlID0gdHJ1ZTtcblx0fVxuXHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KCBvcHRzICkgKSB7XG5cdFx0aWYgKCBvcHRzLmJsdXJhYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRibHVyYWJsZSA9IG9wdHMuYmx1cmFibGU7XG5cdFx0fVxuXHRcdFxuXHRcdGlmICggb3B0cy50b2dnbGVhYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0b2dnbGVhYmxlID0gb3B0cy50b2dnbGVhYmxlO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5pbmZvICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpbmZvID0gb3B0cy5pbmZvO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5pdGVtcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aXRlbXMgPSBvcHRzLml0ZW1zO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5zdHlsZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c3R5bGUgPSBvcHRzLnN0eWxlO1xuXHRcdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHN0eWxlID0gJ29zJztcblx0XHRcdHNldFN0eWxlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gb3B0cy5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjbGFzc05hbWUgPSBvcHRzLmNsYXNzTmFtZTtcblx0XHR9XG5cdH1cblxuXHRkdC5zZWxlY3Quc2VsZWN0b3IoIHNlbGVjdG9yICk7XG5cdGR0LnNlbGVjdC5pdGVtcyggaXRlbXMgKTtcblx0ZHQuc2VsZWN0LnN0eWxlKCBzdHlsZSApO1xuXHRkdC5zZWxlY3QuYmx1cmFibGUoIGJsdXJhYmxlICk7XG5cdGR0LnNlbGVjdC50b2dnbGVhYmxlKCB0b2dnbGVhYmxlICk7XG5cdGR0LnNlbGVjdC5pbmZvKCBpbmZvICk7XG5cdGN0eC5fc2VsZWN0LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuXG5cdC8vIFNvcnQgdGFibGUgYmFzZWQgb24gc2VsZWN0ZWQgcm93cy4gUmVxdWlyZXMgU2VsZWN0IERhdGF0YWJsZXMgZXh0ZW5zaW9uXG5cdCQuZm4uZGF0YVRhYmxlLmV4dC5vcmRlclsnc2VsZWN0LWNoZWNrYm94J10gPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2wgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBpKCkuY29sdW1uKCBjb2wsIHtvcmRlcjogJ2luZGV4J30gKS5ub2RlcygpLm1hcCggZnVuY3Rpb24gKCB0ZCApIHtcblx0XHRcdGlmICggc2V0dGluZ3MuX3NlbGVjdC5pdGVtcyA9PT0gJ3JvdycgKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0ZCApLnBhcmVudCgpLmhhc0NsYXNzKCBzZXR0aW5ncy5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0fSBlbHNlIGlmICggc2V0dGluZ3MuX3NlbGVjdC5pdGVtcyA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGQgKS5oYXNDbGFzcyggc2V0dGluZ3MuX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9KTtcblx0fTtcblxuXHQvLyBJZiB0aGUgaW5pdCBvcHRpb25zIGhhdmVuJ3QgZW5hYmxlZCBzZWxlY3QsIGJ1dCB0aGVyZSBpcyBhIHNlbGVjdGFibGVcblx0Ly8gY2xhc3MgbmFtZSwgdGhlbiBlbmFibGVcblx0aWYgKCAhIHNldFN0eWxlICYmICQoIGR0LnRhYmxlKCkubm9kZSgpICkuaGFzQ2xhc3MoICdzZWxlY3RhYmxlJyApICkge1xuXHRcdGR0LnNlbGVjdC5zdHlsZSggJ29zJyApO1xuXHR9XG59O1xuXG4vKlxuXG5TZWxlY3QgaXMgYSBjb2xsZWN0aW9uIG9mIEFQSSBtZXRob2RzLCBldmVudCBoYW5kbGVycywgZXZlbnQgZW1pdHRlcnMgYW5kXG5idXR0b25zIChmb3IgdGhlIGBCdXR0b25zYCBleHRlbnNpb24pIGZvciBEYXRhVGFibGVzLiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nXG5mZWF0dXJlcywgd2l0aCBhbiBvdmVydmlldyBvZiBob3cgdGhleSBhcmUgaW1wbGVtZW50ZWQ6XG5cbiMjIFNlbGVjdGlvbiBvZiByb3dzLCBjb2x1bW5zIGFuZCBjZWxscy4gV2hldGhlciBhbiBpdGVtIGlzIHNlbGVjdGVkIG9yIG5vdCBpc1xuICAgc3RvcmVkIGluOlxuXG4qIHJvd3M6IGEgYF9zZWxlY3Rfc2VsZWN0ZWRgIHByb3BlcnR5IHdoaWNoIGNvbnRhaW5zIGEgYm9vbGVhbiB2YWx1ZSBvZiB0aGVcbiAgRGF0YVRhYmxlcycgYGFvRGF0YWAgb2JqZWN0IGZvciBlYWNoIHJvd1xuKiBjb2x1bW5zOiBhIGBfc2VsZWN0X3NlbGVjdGVkYCBwcm9wZXJ0eSB3aGljaCBjb250YWlucyBhIGJvb2xlYW4gdmFsdWUgb2YgdGhlXG4gIERhdGFUYWJsZXMnIGBhb0NvbHVtbnNgIG9iamVjdCBmb3IgZWFjaCBjb2x1bW5cbiogY2VsbHM6IGEgYF9zZWxlY3RlZF9jZWxsc2AgcHJvcGVydHkgd2hpY2ggY29udGFpbnMgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXNcbiAgb2YgdGhlIGBhb0RhdGFgIG9iamVjdCBmb3IgZWFjaCByb3cuIFRoZSBhcnJheSBpcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG4gIGNvbHVtbnMgYXJyYXksIHdpdGggZWFjaCBlbGVtZW50IG9mIGl0IHJlcHJlc2VudGluZyBhIGNlbGwuXG5cblRoaXMgbWV0aG9kIG9mIHVzaW5nIGJvb2xlYW4gZmxhZ3MgYWxsb3dzIFNlbGVjdCB0byBvcGVyYXRlIHdoZW4gbm9kZXMgaGF2ZSBub3RcbmJlZW4gY3JlYXRlZCBmb3Igcm93cyAvIGNlbGxzIChEYXRhVGFibGVzJyBkZWZlciByZW5kZXJpbmcgZmVhdHVyZSkuXG5cbiMjIEFQSSBtZXRob2RzXG5cbkEgcmFuZ2Ugb2YgQVBJIG1ldGhvZHMgYXJlIGF2YWlsYWJsZSBmb3IgdHJpZ2dlcmluZyBzZWxlY3Rpb24gYW5kIGRlLXNlbGVjdGlvblxub2Ygcm93cy4gTWV0aG9kcyBhcmUgYWxzbyBhdmFpbGFibGUgdG8gY29uZmlndXJlIHRoZSBzZWxlY3Rpb24gZXZlbnRzIHRoYXQgY2FuXG5iZSB0cmlnZ2VyZWQgYnkgYW4gZW5kIHVzZXIgKHN1Y2ggYXMgd2hpY2ggaXRlbXMgYXJlIHRvIGJlIHNlbGVjdGVkKS4gVG8gYSBsYXJnZVxuZXh0ZW50LCB0aGVzZSBvZiBBUEkgbWV0aG9kcyAqaXMqIFNlbGVjdC4gSXQgaXMgYmFzaWNhbGx5IGEgY29sbGVjdGlvbiBvZiBoZWxwZXJcbmZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlbGVjdCBpdGVtcyBpbiBhIERhdGFUYWJsZS5cblxuQ29uZmlndXJhdGlvbiBvZiBzZWxlY3QgaXMgaGVsZCBpbiB0aGUgb2JqZWN0IGBfc2VsZWN0YCB3aGljaCBpcyBhdHRhY2hlZCB0byB0aGVcbkRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IG9uIGluaXRpYWxpc2F0aW9uLiBTZWxlY3QgYmVpbmcgYXZhaWxhYmxlIG9uIGEgdGFibGVcbmlzIG5vdCBvcHRpb25hbCB3aGVuIFNlbGVjdCBpcyBsb2FkZWQsIGJ1dCBpdHMgZGVmYXVsdCBpcyBmb3Igc2VsZWN0aW9uIG9ubHkgdG9cbmJlIGF2YWlsYWJsZSB2aWEgdGhlIEFQSSAtIHNvIHRoZSBlbmQgdXNlciB3b3VsZG4ndCBiZSBhYmxlIHRvIHNlbGVjdCByb3dzXG53aXRob3V0IGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbi5cblxuVGhlIGBfc2VsZWN0YCBvYmplY3QgY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG5gYGBcbntcblx0aXRlbXM6c3RyaW5nICAgICAgIC0gQ2FuIGJlIGByb3dzYCwgYGNvbHVtbnNgIG9yIGBjZWxsc2AuIERlZmluZXMgd2hhdCBpdGVtIFxuXHQgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHNlbGVjdGVkIGlmIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gYWN0aXZhdGUgcm93XG5cdCAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiB1c2luZyB0aGUgbW91c2UuXG5cdHN0eWxlOnN0cmluZyAgICAgICAtIENhbiBiZSBgbm9uZWAsIGBzaW5nbGVgLCBgbXVsdGlgIG9yIGBvc2AuIERlZmluZXMgdGhlXG5cdCAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uIHN0eWxlIHdoZW4gc2VsZWN0aW5nIGl0ZW1zXG5cdGJsdXJhYmxlOmJvb2xlYW4gICAtIElmIHJvdyBzZWxlY3Rpb24gY2FuIGJlIGNsZWFyZWQgYnkgY2xpY2tpbmcgb3V0c2lkZSBvZlxuXHQgICAgICAgICAgICAgICAgICAgICB0aGUgdGFibGVcblx0dG9nZ2xlYWJsZTpib29sZWFuIC0gSWYgcm93IHNlbGVjdGlvbiBjYW4gYmUgY2FuY2VsbGVkIGJ5IHJlcGVhdGVkIGNsaWNraW5nXG5cdCAgICAgICAgICAgICAgICAgICAgIG9uIHRoZSByb3dcblx0aW5mbzpib29sZWFuICAgICAgIC0gSWYgdGhlIHNlbGVjdGlvbiBzdW1tYXJ5IHNob3VsZCBiZSBzaG93biBpbiB0aGUgdGFibGVcblx0ICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gZWxlbWVudHNcbn1cbmBgYFxuXG5JbiBhZGRpdGlvbiB0byB0aGUgQVBJIG1ldGhvZHMsIFNlbGVjdCBhbHNvIGV4dGVuZHMgdGhlIERhdGFUYWJsZXMgc2VsZWN0b3Jcbm9wdGlvbnMgZm9yIHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzIGFkZGluZyBhIGBzZWxlY3RlZGAgb3B0aW9uIHRvIHRoZSBzZWxlY3Rvclxub3B0aW9ucyBvYmplY3QsIGFsbG93aW5nIHRoZSBkZXZlbG9wZXIgdG8gc2VsZWN0IG9ubHkgc2VsZWN0ZWQgaXRlbXMgb3JcbnVuc2VsZWN0ZWQgaXRlbXMuXG5cbiMjIE1vdXNlIHNlbGVjdGlvbiBvZiBpdGVtc1xuXG5DbGlja2luZyBvbiBpdGVtcyBjYW4gYmUgdXNlZCB0byBzZWxlY3QgaXRlbXMuIFRoaXMgaXMgZG9uZSBieSBhIHNpbXBsZSBldmVudFxuaGFuZGxlciB0aGF0IHdpbGwgc2VsZWN0IHRoZSBpdGVtcyB1c2luZyB0aGUgQVBJIG1ldGhvZHMuXG5cbiAqL1xuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBMb2NhbCBmdW5jdGlvbnNcbiAqL1xuXG4vKipcbiAqIEFkZCBvbmUgb3IgbW9yZSBjZWxscyB0byB0aGUgc2VsZWN0aW9uIHdoZW4gc2hpZnQgY2xpY2tpbmcgaW4gT1Mgc2VsZWN0aW9uXG4gKiBzdHlsZSBjZWxsIHNlbGVjdGlvbi5cbiAqXG4gKiBDZWxsIHJhbmdlIGlzIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiByb3cgYW5kIGNvbHVtbiBhcyB3ZSB3YW50IHRvIHNlbGVjdFxuICogaW4gdGhlIHZpc2libGUgZ3JpZCByYXRoZXIgdGhhbiBieSBpbmRleCBpbiBzZXF1ZW5jZS4gRm9yIGV4YW1wbGUsIGlmIHlvdVxuICogY2xpY2sgZmlyc3QgaW4gY2VsbCAxLTEgYW5kIHRoZW4gc2hpZnQgY2xpY2sgaW4gMi0yIC0gY2VsbHMgMS0yIGFuZCAyLTFcbiAqIHNob3VsZCBhbHNvIGJlIHNlbGVjdGVkIChhbmQgbm90IDEtMywgMS00LiBldGMpXG4gKiBcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5BcGl9IGR0ICAgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICBpZHggIENlbGwgaW5kZXggdG8gc2VsZWN0IHRvXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICBsYXN0IENlbGwgaW5kZXggdG8gc2VsZWN0IGZyb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNlbGxSYW5nZSggZHQsIGlkeCwgbGFzdCApXG57XG5cdHZhciBpbmRleGVzO1xuXHR2YXIgY29sdW1uSW5kZXhlcztcblx0dmFyIHJvd0luZGV4ZXM7XG5cdHZhciBzZWxlY3RDb2x1bW5zID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXHRcdGlmICggc3RhcnQgPiBlbmQgKSB7XG5cdFx0XHR2YXIgdG1wID0gZW5kO1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IHRtcDtcblx0XHR9XG5cdFx0XG5cdFx0dmFyIHJlY29yZCA9IGZhbHNlO1xuXHRcdHJldHVybiBkdC5jb2x1bW5zKCAnOnZpc2libGUnICkuaW5kZXhlcygpLmZpbHRlciggZnVuY3Rpb24gKGkpIHtcblx0XHRcdGlmICggaSA9PT0gc3RhcnQgKSB7XG5cdFx0XHRcdHJlY29yZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggaSA9PT0gZW5kICkgeyAvLyBub3QgZWxzZSBpZiwgYXMgc3RhcnQgbWlnaHQgPT09IGVuZFxuXHRcdFx0XHRyZWNvcmQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWNvcmQ7XG5cdFx0fSApO1xuXHR9O1xuXG5cdHZhciBzZWxlY3RSb3dzID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXHRcdHZhciBpbmRleGVzID0gZHQucm93cyggeyBzZWFyY2g6ICdhcHBsaWVkJyB9ICkuaW5kZXhlcygpO1xuXG5cdFx0Ly8gV2hpY2ggY29tZXMgZmlyc3QgLSBtaWdodCBuZWVkIHRvIHN3YXBcblx0XHRpZiAoIGluZGV4ZXMuaW5kZXhPZiggc3RhcnQgKSA+IGluZGV4ZXMuaW5kZXhPZiggZW5kICkgKSB7XG5cdFx0XHR2YXIgdG1wID0gZW5kO1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IHRtcDtcblx0XHR9XG5cblx0XHR2YXIgcmVjb3JkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGluZGV4ZXMuZmlsdGVyKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0aWYgKCBpID09PSBzdGFydCApIHtcblx0XHRcdFx0cmVjb3JkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCBpID09PSBlbmQgKSB7XG5cdFx0XHRcdHJlY29yZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlY29yZDtcblx0XHR9ICk7XG5cdH07XG5cblx0aWYgKCAhIGR0LmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSAmJiAhIGxhc3QgKSB7XG5cdFx0Ly8gc2VsZWN0IGZyb20gdGhlIHRvcCBsZWZ0IGNlbGwgdG8gdGhpcyBvbmVcblx0XHRjb2x1bW5JbmRleGVzID0gc2VsZWN0Q29sdW1ucyggMCwgaWR4LmNvbHVtbiApO1xuXHRcdHJvd0luZGV4ZXMgPSBzZWxlY3RSb3dzKCAwICwgaWR4LnJvdyApO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdldCBjb2x1bW4gaW5kZXhlcyBiZXR3ZWVuIG9sZCBhbmQgbmV3XG5cdFx0Y29sdW1uSW5kZXhlcyA9IHNlbGVjdENvbHVtbnMoIGxhc3QuY29sdW1uLCBpZHguY29sdW1uICk7XG5cdFx0cm93SW5kZXhlcyA9IHNlbGVjdFJvd3MoIGxhc3Qucm93ICwgaWR4LnJvdyApO1xuXHR9XG5cblx0aW5kZXhlcyA9IGR0LmNlbGxzKCByb3dJbmRleGVzLCBjb2x1bW5JbmRleGVzICkuZmxhdHRlbigpO1xuXG5cdGlmICggISBkdC5jZWxscyggaWR4LCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSApIHtcblx0XHQvLyBTZWxlY3QgcmFuZ2Vcblx0XHRkdC5jZWxscyggaW5kZXhlcyApLnNlbGVjdCgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIERlc2VsZWN0IHJhbmdlXG5cdFx0ZHQuY2VsbHMoIGluZGV4ZXMgKS5kZXNlbGVjdCgpO1xuXHR9XG59XG5cbi8qKlxuICogRGlzYWJsZSBtb3VzZSBzZWxlY3Rpb24gYnkgcmVtb3ZpbmcgdGhlIHNlbGVjdG9yc1xuICpcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gZHQgRGF0YVRhYmxlIHRvIHJlbW92ZSBldmVudHMgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZU1vdXNlU2VsZWN0aW9uKCBkdCApXG57XG5cdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHR2YXIgc2VsZWN0b3IgPSBjdHguX3NlbGVjdC5zZWxlY3RvcjtcblxuXHQkKCBkdC50YWJsZSgpLmNvbnRhaW5lcigpIClcblx0XHQub2ZmKCAnbW91c2Vkb3duLmR0U2VsZWN0Jywgc2VsZWN0b3IgKVxuXHRcdC5vZmYoICdtb3VzZXVwLmR0U2VsZWN0Jywgc2VsZWN0b3IgKVxuXHRcdC5vZmYoICdjbGljay5kdFNlbGVjdCcsIHNlbGVjdG9yICk7XG5cblx0JCgnYm9keScpLm9mZiggJ2NsaWNrLmR0U2VsZWN0JyArIF9zYWZlSWQoZHQudGFibGUoKS5ub2RlKCkpICk7XG59XG5cbi8qKlxuICogQXR0YWNoIG1vdXNlIGxpc3RlbmVycyB0byB0aGUgdGFibGUgdG8gYWxsb3cgbW91c2Ugc2VsZWN0aW9uIG9mIGl0ZW1zXG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBkdCBEYXRhVGFibGUgdG8gcmVtb3ZlIGV2ZW50cyBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmFibGVNb3VzZVNlbGVjdGlvbiAoIGR0IClcbntcblx0dmFyIGNvbnRhaW5lciA9ICQoIGR0LnRhYmxlKCkuY29udGFpbmVyKCkgKTtcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cdHZhciBzZWxlY3RvciA9IGN0eC5fc2VsZWN0LnNlbGVjdG9yO1xuXHR2YXIgbWF0Y2hTZWxlY3Rpb247XG5cblx0Y29udGFpbmVyXG5cdFx0Lm9uKCAnbW91c2Vkb3duLmR0U2VsZWN0Jywgc2VsZWN0b3IsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vIERpc2FsbG93IHRleHQgc2VsZWN0aW9uIGZvciBzaGlmdCBjbGlja2luZyBvbiB0aGUgdGFibGUgc28gbXVsdGlcblx0XHRcdC8vIGVsZW1lbnQgc2VsZWN0aW9uIGRvZXNuJ3QgbG9vayB0ZXJyaWJsZSFcblx0XHRcdGlmICggZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5ICkge1xuXHRcdFx0XHRjb250YWluZXJcblx0XHRcdFx0XHQuY3NzKCAnLW1vei11c2VyLXNlbGVjdCcsICdub25lJyApXG5cdFx0XHRcdFx0Lm9uZSgnc2VsZWN0c3RhcnQuZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW5kb3cuZ2V0U2VsZWN0aW9uICkge1xuXHRcdFx0XHRtYXRjaFNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdH1cblx0XHR9IClcblx0XHQub24oICdtb3VzZXVwLmR0U2VsZWN0Jywgc2VsZWN0b3IsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQWxsb3cgdGV4dCBzZWxlY3Rpb24gdG8gb2NjdXIgYWdhaW4sIE1vemlsbGEgc3R5bGUgKHRlc3RlZCBpbiBGRlxuXHRcdFx0Ly8gMzUuMC4xIC0gc3RpbGwgcmVxdWlyZWQpXG5cdFx0XHRjb250YWluZXIuY3NzKCAnLW1vei11c2VyLXNlbGVjdCcsICcnICk7XG5cdFx0fSApXG5cdFx0Lm9uKCAnY2xpY2suZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0dmFyIGl0ZW1zID0gZHQuc2VsZWN0Lml0ZW1zKCk7XG5cdFx0XHR2YXIgaWR4O1xuXG5cdFx0XHQvLyBJZiB0ZXh0IHdhcyBzZWxlY3RlZCAoY2xpY2sgYW5kIGRyYWcpLCB0aGVuIHdlIHNob3VsZG4ndCBjaGFuZ2Vcblx0XHRcdC8vIHRoZSByb3cncyBzZWxlY3RlZCBzdGF0ZVxuXHRcdFx0aWYgKCBtYXRjaFNlbGVjdGlvbiApIHtcblx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBzZWxlY3Rpb24gaXMgbm90IGluIHRoZSB0YWJsZSwgd2UgY2FuIGlnbm9yZSBpdFxuXHRcdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGRldmVsb3BlciBzZWxlY3RzIHRleHQgZnJvbSB0aGUgY2xpY2sgZXZlbnRcblx0XHRcdFx0aWYgKCAhIHNlbGVjdGlvbi5hbmNob3JOb2RlIHx8ICQoc2VsZWN0aW9uLmFuY2hvck5vZGUpLmNsb3Nlc3QoJ3RhYmxlJylbMF0gPT09IGR0LnRhYmxlKCkubm9kZSgpICkge1xuXHRcdFx0XHRcdGlmICggc2VsZWN0aW9uICE9PSBtYXRjaFNlbGVjdGlvbiApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cdFx0XHR2YXIgd3JhcHBlckNsYXNzID0gZHQuc2V0dGluZ3MoKVswXS5vQ2xhc3Nlcy5zV3JhcHBlci50cmltKCkucmVwbGFjZSgvICsvZywgJy4nKTtcblxuXHRcdFx0Ly8gSWdub3JlIGNsaWNrcyBpbnNpZGUgYSBzdWItdGFibGVcblx0XHRcdGlmICggJChlLnRhcmdldCkuY2xvc2VzdCgnZGl2Licrd3JhcHBlckNsYXNzKVswXSAhPSBkdC50YWJsZSgpLmNvbnRhaW5lcigpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjZWxsID0gZHQuY2VsbCggJChlLnRhcmdldCkuY2xvc2VzdCgndGQsIHRoJykgKTtcblxuXHRcdFx0Ly8gQ2hlY2sgdGhlIGNlbGwgYWN0dWFsbHkgYmVsb25ncyB0byB0aGUgaG9zdCBEYXRhVGFibGUgKHNvIGNoaWxkXG5cdFx0XHQvLyByb3dzLCBldGMsIGFyZSBpZ25vcmVkKVxuXHRcdFx0aWYgKCAhIGNlbGwuYW55KCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCgndXNlci1zZWxlY3QuZHQnKTtcblx0XHRcdGV2ZW50VHJpZ2dlciggZHQsIGV2ZW50LCBbIGl0ZW1zLCBjZWxsLCBlIF0gKTtcblxuXHRcdFx0aWYgKCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2VsbEluZGV4ID0gY2VsbC5pbmRleCgpO1xuXHRcdFx0aWYgKCBpdGVtcyA9PT0gJ3JvdycgKSB7XG5cdFx0XHRcdGlkeCA9IGNlbGxJbmRleC5yb3c7XG5cdFx0XHRcdHR5cGVTZWxlY3QoIGUsIGR0LCBjdHgsICdyb3cnLCBpZHggKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBpdGVtcyA9PT0gJ2NvbHVtbicgKSB7XG5cdFx0XHRcdGlkeCA9IGNlbGwuaW5kZXgoKS5jb2x1bW47XG5cdFx0XHRcdHR5cGVTZWxlY3QoIGUsIGR0LCBjdHgsICdjb2x1bW4nLCBpZHggKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBpdGVtcyA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRpZHggPSBjZWxsLmluZGV4KCk7XG5cdFx0XHRcdHR5cGVTZWxlY3QoIGUsIGR0LCBjdHgsICdjZWxsJywgaWR4ICk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5fc2VsZWN0X2xhc3RDZWxsID0gY2VsbEluZGV4O1xuXHRcdH0gKTtcblxuXHQvLyBCbHVyYWJsZVxuXHQkKCdib2R5Jykub24oICdjbGljay5kdFNlbGVjdCcgKyBfc2FmZUlkKGR0LnRhYmxlKCkubm9kZSgpKSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdGlmICggY3R4Ll9zZWxlY3QuYmx1cmFibGUgKSB7XG5cdFx0XHQvLyBJZiB0aGUgY2xpY2sgd2FzIGluc2lkZSB0aGUgRGF0YVRhYmxlcyBjb250YWluZXIsIGRvbid0IGJsdXJcblx0XHRcdGlmICggJChlLnRhcmdldCkucGFyZW50cygpLmZpbHRlciggZHQudGFibGUoKS5jb250YWluZXIoKSApLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZ25vcmUgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NIChpLmUuIHBhZ2luZ1xuXHRcdFx0Ly8gYnV0dG9ucylcblx0XHRcdGlmICggJChlLnRhcmdldCkucGFyZW50cygnaHRtbCcpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdCBcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRG9uJ3QgYmx1ciBpbiBFZGl0b3IgZm9ybVxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5wYXJlbnRzKCdkaXYuRFRFJykubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBldmVudCA9ICQuRXZlbnQoJ3NlbGVjdC1ibHVyLmR0Jyk7XG5cdFx0XHRldmVudFRyaWdnZXIoIGR0LCBldmVudCwgWyBlLnRhcmdldCwgZSBdICk7XG5cblx0XHRcdGlmICggZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2xlYXIoIGN0eCwgdHJ1ZSApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgb24gYSBEYXRhVGFibGVcbiAqXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGFwaSAgICAgIERhdGFUYWJsZSB0byB0cmlnZ2VyIGV2ZW50cyBvblxuICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBzZWxlY3RlZCB0cnVlIGlmIHNlbGVjdGVkLCBmYWxzZSBpZiBkZXNlbGVjdGVkXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIHR5cGUgICAgIEl0ZW0gdHlwZSBhY3Rpbmcgb25cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgYW55ICAgICAgUmVxdWlyZSB0aGF0IHRoZXJlIGFyZSB2YWx1ZXMgYmVmb3JlXG4gKiAgICAgdHJpZ2dlcmluZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRUcmlnZ2VyICggYXBpLCB0eXBlLCBhcmdzLCBhbnkgKVxue1xuXHRpZiAoIGFueSAmJiAhIGFwaS5mbGF0dGVuKCkubGVuZ3RoICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICkge1xuXHRcdHR5cGUgPSB0eXBlICsnLmR0Jztcblx0fVxuXG5cdGFyZ3MudW5zaGlmdCggYXBpICk7XG5cblx0JChhcGkudGFibGUoKS5ub2RlKCkpLnRyaWdnZXIoIHR5cGUsIGFyZ3MgKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgb2YgdGhlIERhdGFUYWJsZSBzaG93aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogaXRlbXMgc2VsZWN0ZWQuIFRoaXMgaXMgZG9uZSBieSBhZGRpbmcgdGFncyB0byB0aGUgZXhpc3RpbmcgdGV4dFxuICogXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGFwaSBEYXRhVGFibGUgdG8gdXBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZvICggYXBpIClcbntcblx0dmFyIGN0eCA9IGFwaS5zZXR0aW5ncygpWzBdO1xuXG5cdGlmICggISBjdHguX3NlbGVjdC5pbmZvIHx8ICEgY3R4LmFhbkZlYXR1cmVzLmkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBhcGkuc2VsZWN0LnN0eWxlKCkgPT09ICdhcGknICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciByb3dzICAgID0gYXBpLnJvd3MoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cdHZhciBjb2x1bW5zID0gYXBpLmNvbHVtbnMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cdHZhciBjZWxscyAgID0gYXBpLmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdHZhciBhZGQgPSBmdW5jdGlvbiAoIGVsLCBuYW1lLCBudW0gKSB7XG5cdFx0ZWwuYXBwZW5kKCAkKCc8c3BhbiBjbGFzcz1cInNlbGVjdC1pdGVtXCIvPicpLmFwcGVuZCggYXBpLmkxOG4oXG5cdFx0XHQnc2VsZWN0LicrbmFtZSsncycsXG5cdFx0XHR7IF86ICclZCAnK25hbWUrJ3Mgc2VsZWN0ZWQnLCAwOiAnJywgMTogJzEgJytuYW1lKycgc2VsZWN0ZWQnIH0sXG5cdFx0XHRudW1cblx0XHQpICkgKTtcblx0fTtcblxuXHQvLyBJbnRlcm5hbCBrbm93bGVkZ2Ugb2YgRGF0YVRhYmxlcyB0byBsb29wIG92ZXIgYWxsIGluZm9ybWF0aW9uIGVsZW1lbnRzXG5cdCQuZWFjaCggY3R4LmFhbkZlYXR1cmVzLmksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0ZWwgPSAkKGVsKTtcblxuXHRcdHZhciBvdXRwdXQgID0gJCgnPHNwYW4gY2xhc3M9XCJzZWxlY3QtaW5mb1wiLz4nKTtcblx0XHRhZGQoIG91dHB1dCwgJ3JvdycsIHJvd3MgKTtcblx0XHRhZGQoIG91dHB1dCwgJ2NvbHVtbicsIGNvbHVtbnMgKTtcblx0XHRhZGQoIG91dHB1dCwgJ2NlbGwnLCBjZWxscyAgKTtcblxuXHRcdHZhciBleGlzaXRpbmcgPSBlbC5jaGlsZHJlbignc3Bhbi5zZWxlY3QtaW5mbycpO1xuXHRcdGlmICggZXhpc2l0aW5nLmxlbmd0aCApIHtcblx0XHRcdGV4aXNpdGluZy5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRpZiAoIG91dHB1dC50ZXh0KCkgIT09ICcnICkge1xuXHRcdFx0ZWwuYXBwZW5kKCBvdXRwdXQgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXNhdGlvbiBvZiBhIG5ldyB0YWJsZS4gQXR0YWNoIGV2ZW50IGhhbmRsZXJzIGFuZCBjYWxsYmFja3MgdG8gYWxsb3dcbiAqIFNlbGVjdCB0byBvcGVyYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBUaGlzIHdpbGwgb2NjdXIgX2FmdGVyXyB0aGUgaW5pdGlhbCBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uLCBhbHRob3VnaFxuICogYmVmb3JlIEFqYXggZGF0YSBpcyByZW5kZXJlZCwgaWYgdGhlcmUgaXMgYWpheCBkYXRhXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggU2V0dGluZ3Mgb2JqZWN0IHRvIG9wZXJhdGUgb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXQgKCBjdHggKSB7XG5cdHZhciBhcGkgPSBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICk7XG5cdGN0eC5fc2VsZWN0X2luaXQgPSB0cnVlO1xuXG5cdC8vIFJvdyBjYWxsYmFjayBzbyB0aGF0IGNsYXNzZXMgY2FuIGJlIGFkZGVkIHRvIHJvd3MgYW5kIGNlbGxzIGlmIHRoZSBpdGVtXG5cdC8vIHdhcyBzZWxlY3RlZCBiZWZvcmUgdGhlIGVsZW1lbnQgd2FzIGNyZWF0ZWQuIFRoaXMgd2lsbCBoYXBwZW4gd2l0aCB0aGVcblx0Ly8gYGRlZmVyUmVuZGVyYCBvcHRpb24gZW5hYmxlZC5cblx0Ly8gXG5cdC8vIFRoaXMgbWV0aG9kIG9mIGF0dGFjaGluZyB0byBgYW9Sb3dDcmVhdGVkQ2FsbGJhY2tgIGlzIGEgaGFjayB1bnRpbFxuXHQvLyBEYXRhVGFibGVzIGhhcyBwcm9wZXIgZXZlbnRzIGZvciByb3cgbWFuaXB1bGF0aW9uIElmIHlvdSBhcmUgcmV2aWV3aW5nXG5cdC8vIHRoaXMgY29kZSB0byBjcmVhdGUgeW91ciBvd24gcGx1Zy1pbnMsIHBsZWFzZSBkbyBub3QgZG8gdGhpcyFcblx0Y3R4LmFvUm93Q3JlYXRlZENhbGxiYWNrLnB1c2goIHtcblx0XHRmbjogZnVuY3Rpb24gKCByb3csIGRhdGEsIGluZGV4ICkge1xuXHRcdFx0dmFyIGksIGllbjtcblx0XHRcdHZhciBkID0gY3R4LmFvRGF0YVsgaW5kZXggXTtcblxuXHRcdFx0Ly8gUm93XG5cdFx0XHRpZiAoIGQuX3NlbGVjdF9zZWxlY3RlZCApIHtcblx0XHRcdFx0JCggcm93ICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDZWxscyBhbmQgY29sdW1ucyAtIGlmIHNlcGFyYXRlZCBvdXQsIHdlIHdvdWxkIG5lZWQgdG8gZG8gdHdvXG5cdFx0XHQvLyBsb29wcywgc28gaXQgbWFrZXMgc2Vuc2UgdG8gY29tYmluZSB0aGVtIGludG8gYSBzaW5nbGUgb25lXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jdHguYW9Db2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGN0eC5hb0NvbHVtbnNbaV0uX3NlbGVjdF9zZWxlY3RlZCB8fCAoZC5fc2VsZWN0ZWRfY2VsbHMgJiYgZC5fc2VsZWN0ZWRfY2VsbHNbaV0pICkge1xuXHRcdFx0XHRcdCQoZC5hbkNlbGxzW2ldKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNOYW1lOiAnc2VsZWN0LWRlZmVyUmVuZGVyJ1xuXHR9ICk7XG5cblx0Ly8gT24gQWpheCByZWxvYWQgd2Ugd2FudCB0byByZXNlbGVjdCBhbGwgcm93cyB3aGljaCBhcmUgY3VycmVudGx5IHNlbGVjdGVkLFxuXHQvLyBpZiB0aGVyZSBpcyBhbiByb3dJZCAoaS5lLiBhIHVuaXF1ZSB2YWx1ZSB0byBpZGVudGlmeSBlYWNoIHJvdyB3aXRoKVxuXHRhcGkub24oICdwcmVYaHIuZHQuZHRTZWxlY3QnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MpIHtcblx0XHRpZiAoc2V0dGluZ3MgIT09IGFwaS5zZXR0aW5ncygpWzBdKSB7XG5cdFx0XHQvLyBOb3QgdHJpZ2dlcmVkIGJ5IG91ciBEYXRhVGFibGUhXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gbm90ZSB0aGF0IGNvbHVtbiBzZWxlY3Rpb24gZG9lc24ndCBuZWVkIHRvIGJlIGNhY2hlZCBhbmQgdGhlblxuXHRcdC8vIHJlc2VsZWN0ZWQsIGFzIHRoZXkgYXJlIGFscmVhZHkgc2VsZWN0ZWRcblx0XHR2YXIgcm93cyA9IGFwaS5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5pZHMoIHRydWUgKS5maWx0ZXIoIGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBkICE9PSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0dmFyIGNlbGxzID0gYXBpLmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5lcSgwKS5tYXAoIGZ1bmN0aW9uICggY2VsbElkeCApIHtcblx0XHRcdHZhciBpZCA9IGFwaS5yb3coIGNlbGxJZHgucm93ICkuaWQoIHRydWUgKTtcblx0XHRcdHJldHVybiBpZCA/XG5cdFx0XHRcdHsgcm93OiBpZCwgY29sdW1uOiBjZWxsSWR4LmNvbHVtbiB9IDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBkICE9PSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gT24gdGhlIG5leHQgZHJhdywgcmVzZWxlY3QgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtc1xuXHRcdGFwaS5vbmUoICdkcmF3LmR0LmR0U2VsZWN0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0YXBpLnJvd3MoIHJvd3MgKS5zZWxlY3QoKTtcblxuXHRcdFx0Ly8gYGNlbGxzYCBpcyBub3QgYSBjZWxsIGluZGV4IHNlbGVjdG9yLCBzbyBpdCBuZWVkcyBhIGxvb3Bcblx0XHRcdGlmICggY2VsbHMuYW55KCkgKSB7XG5cdFx0XHRcdGNlbGxzLmVhY2goIGZ1bmN0aW9uICggaWQgKSB7XG5cdFx0XHRcdFx0YXBpLmNlbGxzKCBpZC5yb3csIGlkLmNvbHVtbiApLnNlbGVjdCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0Ly8gVXBkYXRlIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50IHdpdGggc2VsZWN0ZWQgaXRlbSBzdW1tYXJ5XG5cdGFwaS5vbiggJ2RyYXcuZHRTZWxlY3QuZHQgc2VsZWN0LmR0U2VsZWN0LmR0IGRlc2VsZWN0LmR0U2VsZWN0LmR0IGluZm8uZHQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aW5mbyggYXBpICk7XG5cdFx0YXBpLnN0YXRlLnNhdmUoKTtcblx0fSApO1xuXG5cdC8vIENsZWFuIHVwIGFuZCByZWxlYXNlXG5cdGFwaS5vbiggJ2Rlc3Ryb3kuZHRTZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG5cdFx0YXBpLnJvd3Moe3NlbGVjdGVkOiB0cnVlfSkuZGVzZWxlY3QoKTtcblxuXHRcdGRpc2FibGVNb3VzZVNlbGVjdGlvbiggYXBpICk7XG5cdFx0YXBpLm9mZiggJy5kdFNlbGVjdCcgKTtcblx0XHQkKCdib2R5Jykub2ZmKCcuZHRTZWxlY3QnICsgX3NhZmVJZChhcGkudGFibGUoKS5ub2RlKCkpKTtcblx0fSApO1xufVxuXG4vKipcbiAqIEFkZCBvbmUgb3IgbW9yZSBpdGVtcyAocm93cyBvciBjb2x1bW5zKSB0byB0aGUgc2VsZWN0aW9uIHdoZW4gc2hpZnQgY2xpY2tpbmdcbiAqIGluIE9TIHNlbGVjdGlvbiBzdHlsZVxuICpcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5BcGl9IGR0ICAgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICB0eXBlIFJvdyBvciBjb2x1bW4gcmFuZ2Ugc2VsZWN0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGlkeCAgSXRlbSBpbmRleCB0byBzZWxlY3QgdG9cbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGxhc3QgSXRlbSBpbmRleCB0byBzZWxlY3QgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcm93Q29sdW1uUmFuZ2UoIGR0LCB0eXBlLCBpZHgsIGxhc3QgKVxue1xuXHQvLyBBZGQgYSByYW5nZSBvZiByb3dzIGZyb20gdGhlIGxhc3Qgc2VsZWN0ZWQgcm93IHRvIHRoaXMgb25lXG5cdHZhciBpbmRleGVzID0gZHRbdHlwZSsncyddKCB7IHNlYXJjaDogJ2FwcGxpZWQnIH0gKS5pbmRleGVzKCk7XG5cdHZhciBpZHgxID0gJC5pbkFycmF5KCBsYXN0LCBpbmRleGVzICk7XG5cdHZhciBpZHgyID0gJC5pbkFycmF5KCBpZHgsIGluZGV4ZXMgKTtcblxuXHRpZiAoICEgZHRbdHlwZSsncyddKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSAmJiBpZHgxID09PSAtMSApIHtcblx0XHQvLyBzZWxlY3QgZnJvbSB0b3AgdG8gaGVyZSAtIHNsaWdodGx5IG9kZCwgYnV0IGJvdGggV2luZG93cyBhbmQgTWFjIE9TXG5cdFx0Ly8gZG8gdGhpc1xuXHRcdGluZGV4ZXMuc3BsaWNlKCAkLmluQXJyYXkoIGlkeCwgaW5kZXhlcyApKzEsIGluZGV4ZXMubGVuZ3RoICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gcmV2ZXJzZSBzbyB3ZSBjYW4gc2hpZnQgY2xpY2sgJ3VwJyBhcyB3ZWxsIGFzIGRvd25cblx0XHRpZiAoIGlkeDEgPiBpZHgyICkge1xuXHRcdFx0dmFyIHRtcCA9IGlkeDI7XG5cdFx0XHRpZHgyID0gaWR4MTtcblx0XHRcdGlkeDEgPSB0bXA7XG5cdFx0fVxuXG5cdFx0aW5kZXhlcy5zcGxpY2UoIGlkeDIrMSwgaW5kZXhlcy5sZW5ndGggKTtcblx0XHRpbmRleGVzLnNwbGljZSggMCwgaWR4MSApO1xuXHR9XG5cblx0aWYgKCAhIGR0W3R5cGVdKCBpZHgsIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICkge1xuXHRcdC8vIFNlbGVjdCByYW5nZVxuXHRcdGR0W3R5cGUrJ3MnXSggaW5kZXhlcyApLnNlbGVjdCgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIERlc2VsZWN0IHJhbmdlIC0gbmVlZCB0byBrZWVwIHRoZSBjbGlja2VkIG9uIHJvdyBzZWxlY3RlZFxuXHRcdGluZGV4ZXMuc3BsaWNlKCAkLmluQXJyYXkoIGlkeCwgaW5kZXhlcyApLCAxICk7XG5cdFx0ZHRbdHlwZSsncyddKCBpbmRleGVzICkuZGVzZWxlY3QoKTtcblx0fVxufVxuXG4vKipcbiAqIENsZWFyIGFsbCBzZWxlY3RlZCBpdGVtc1xuICpcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5zZXR0aW5nc30gY3R4IFNldHRpbmdzIG9iamVjdCBvZiB0aGUgaG9zdCBEYXRhVGFibGVcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gRm9yY2UgdGhlIGRlLXNlbGVjdGlvbiB0byBoYXBwZW4sIHJlZ2FyZGxlc3NcbiAqICAgICBvZiBzZWxlY3Rpb24gc3R5bGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyKCBjdHgsIGZvcmNlIClcbntcblx0aWYgKCBmb3JjZSB8fCBjdHguX3NlbGVjdC5zdHlsZSA9PT0gJ3NpbmdsZScgKSB7XG5cdFx0dmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKTtcblx0XHRcblx0XHRhcGkucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZGVzZWxlY3QoKTtcblx0XHRhcGkuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZGVzZWxlY3QoKTtcblx0XHRhcGkuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmRlc2VsZWN0KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBTZWxlY3QgaXRlbXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBmb3Igc3R5bGUgYW5kIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgZSAgICBNb3VzZSBldmVudCBvYmplY3RcbiAqIEBwYXJhbSAge0RhdGFUYWJsZXMuQXBpfSAgICAgZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5zZXR0aW5nc30gY3R4ICBTZXR0aW5ncyBvYmplY3Qgb2YgdGhlIGhvc3QgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHR5cGUgSXRlbXMgdG8gc2VsZWN0XG4gKiBAcGFyYW0gIHtpbnR8b2JqZWN0fSAgICAgICAgIGlkeCAgSW5kZXggb2YgdGhlIGl0ZW0gdG8gc2VsZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0eXBlU2VsZWN0ICggZSwgZHQsIGN0eCwgdHlwZSwgaWR4IClcbntcblx0dmFyIHN0eWxlID0gZHQuc2VsZWN0LnN0eWxlKCk7XG5cdHZhciB0b2dnbGVhYmxlID0gZHQuc2VsZWN0LnRvZ2dsZWFibGUoKTtcblx0dmFyIGlzU2VsZWN0ZWQgPSBkdFt0eXBlXSggaWR4LCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKTtcblx0XG5cdGlmICggaXNTZWxlY3RlZCAmJiAhIHRvZ2dsZWFibGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBzdHlsZSA9PT0gJ29zJyApIHtcblx0XHRpZiAoIGUuY3RybEtleSB8fCBlLm1ldGFLZXkgKSB7XG5cdFx0XHQvLyBBZGQgb3IgcmVtb3ZlIGZyb20gdGhlIHNlbGVjdGlvblxuXHRcdFx0ZHRbdHlwZV0oIGlkeCApLnNlbGVjdCggISBpc1NlbGVjdGVkICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBlLnNoaWZ0S2V5ICkge1xuXHRcdFx0aWYgKCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdGNlbGxSYW5nZSggZHQsIGlkeCwgY3R4Ll9zZWxlY3RfbGFzdENlbGwgfHwgbnVsbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJvd0NvbHVtblJhbmdlKCBkdCwgdHlwZSwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCA/XG5cdFx0XHRcdFx0Y3R4Ll9zZWxlY3RfbGFzdENlbGxbdHlwZV0gOlxuXHRcdFx0XHRcdG51bGxcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBjbWQgb3Igc2hpZnQgY2xpY2sgLSBkZXNlbGVjdCBpZiBzZWxlY3RlZCwgb3Igc2VsZWN0XG5cdFx0XHQvLyB0aGlzIHJvdyBvbmx5XG5cdFx0XHR2YXIgc2VsZWN0ZWQgPSBkdFt0eXBlKydzJ10oIHsgc2VsZWN0ZWQ6IHRydWUgfSApO1xuXG5cdFx0XHRpZiAoIGlzU2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZmxhdHRlbigpLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZHRbdHlwZV0oIGlkeCApLmRlc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZWN0ZWQuZGVzZWxlY3QoKTtcblx0XHRcdFx0ZHRbdHlwZV0oIGlkeCApLnNlbGVjdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggc3R5bGUgPT0gJ211bHRpK3NoaWZ0JyApIHtcblx0XHRpZiAoIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0Y2VsbFJhbmdlKCBkdCwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCB8fCBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93Q29sdW1uUmFuZ2UoIGR0LCB0eXBlLCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsID9cblx0XHRcdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbFt0eXBlXSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGR0WyB0eXBlIF0oIGlkeCApLnNlbGVjdCggISBpc1NlbGVjdGVkICk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGR0WyB0eXBlIF0oIGlkeCApLnNlbGVjdCggISBpc1NlbGVjdGVkICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gX3NhZmVJZCggbm9kZSApIHtcblx0cmV0dXJuIG5vZGUuaWQucmVwbGFjZSgvW15hLXpBLVowLTlcXC1cXF9dL2csICctJyk7XG59XG5cblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogRGF0YVRhYmxlcyBzZWxlY3RvcnNcbiAqL1xuXG4vLyByb3cgYW5kIGNvbHVtbiBhcmUgYmFzaWNhbGx5IGlkZW50aWNhbCBqdXN0IGFzc2lnbmVkIHRvIGRpZmZlcmVudCBwcm9wZXJ0aWVzXG4vLyBhbmQgY2hlY2tpbmcgYSBkaWZmZXJlbnQgYXJyYXksIHNvIHdlIGNhbiBkeW5hbWljYWxseSBjcmVhdGUgdGhlIGZ1bmN0aW9ucyB0b1xuLy8gcmVkdWNlIHRoZSBjb2RlIHNpemVcbiQuZWFjaCggW1xuXHR7IHR5cGU6ICdyb3cnLCBwcm9wOiAnYW9EYXRhJyB9LFxuXHR7IHR5cGU6ICdjb2x1bW4nLCBwcm9wOiAnYW9Db2x1bW5zJyB9XG5dLCBmdW5jdGlvbiAoIGksIG8gKSB7XG5cdERhdGFUYWJsZS5leHQuc2VsZWN0b3JbIG8udHlwZSBdLnB1c2goIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMsIGluZGV4ZXMgKSB7XG5cdFx0dmFyIHNlbGVjdGVkID0gb3B0cy5zZWxlY3RlZDtcblx0XHR2YXIgZGF0YTtcblx0XHR2YXIgb3V0ID0gW107XG5cblx0XHRpZiAoIHNlbGVjdGVkICE9PSB0cnVlICYmIHNlbGVjdGVkICE9PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBpbmRleGVzO1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1pbmRleGVzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0ZGF0YSA9IHNldHRpbmdzWyBvLnByb3AgXVsgaW5kZXhlc1tpXSBdO1xuXG5cdFx0XHRpZiAoIChzZWxlY3RlZCA9PT0gdHJ1ZSAmJiBkYXRhLl9zZWxlY3Rfc2VsZWN0ZWQgPT09IHRydWUpIHx8XG5cdFx0XHQgICAgIChzZWxlY3RlZCA9PT0gZmFsc2UgJiYgISBkYXRhLl9zZWxlY3Rfc2VsZWN0ZWQgKVxuXHRcdFx0KSB7XG5cdFx0XHRcdG91dC5wdXNoKCBpbmRleGVzW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dDtcblx0fSApO1xufSApO1xuXG5EYXRhVGFibGUuZXh0LnNlbGVjdG9yLmNlbGwucHVzaCggZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cywgY2VsbHMgKSB7XG5cdHZhciBzZWxlY3RlZCA9IG9wdHMuc2VsZWN0ZWQ7XG5cdHZhciByb3dEYXRhO1xuXHR2YXIgb3V0ID0gW107XG5cblx0aWYgKCBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiBjZWxscztcblx0fVxuXG5cdGZvciAoIHZhciBpPTAsIGllbj1jZWxscy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRyb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhWyBjZWxsc1tpXS5yb3cgXTtcblxuXHRcdGlmICggKHNlbGVjdGVkID09PSB0cnVlICYmIHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzICYmIHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzWyBjZWxsc1tpXS5jb2x1bW4gXSA9PT0gdHJ1ZSkgfHxcblx0XHQgICAgIChzZWxlY3RlZCA9PT0gZmFsc2UgJiYgKCAhIHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzIHx8ICEgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHNbIGNlbGxzW2ldLmNvbHVtbiBdICkgKVxuXHRcdCkge1xuXHRcdFx0b3V0LnB1c2goIGNlbGxzW2ldICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn0gKTtcblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIEFQSVxuICpcbiAqIEZvciBjb21wbGV0ZSBkb2N1bWVudGF0aW9uLCBwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3MvYXBpIGRpcmVjdG9yeSBvciB0aGVcbiAqIERhdGFUYWJsZXMgc2l0ZVxuICovXG5cbi8vIExvY2FsIHZhcmlhYmxlcyB0byBpbXByb3ZlIGNvbXByZXNzaW9uXG52YXIgYXBpUmVnaXN0ZXIgPSBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyO1xudmFyIGFwaVJlZ2lzdGVyUGx1cmFsID0gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbDtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdERhdGFUYWJsZS5zZWxlY3QuaW5pdCggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApICk7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QuYmx1cmFibGUoKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LmJsdXJhYmxlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGN0eC5fc2VsZWN0LmJsdXJhYmxlID0gZmxhZztcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC50b2dnbGVhYmxlKCknLCBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdGlmICggZmxhZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC50b2dnbGVhYmxlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGN0eC5fc2VsZWN0LnRvZ2dsZWFibGUgPSBmbGFnO1xuXHR9ICk7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LmluZm8oKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LmluZm87XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuaW5mbyA9IGZsYWc7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QuaXRlbXMoKScsIGZ1bmN0aW9uICggaXRlbXMgKSB7XG5cdGlmICggaXRlbXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuaXRlbXM7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuaXRlbXMgPSBpdGVtcztcblxuXHRcdGV2ZW50VHJpZ2dlciggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApLCAnc2VsZWN0SXRlbXMnLCBbIGl0ZW1zIF0gKTtcblx0fSApO1xufSApO1xuXG4vLyBUYWtlcyBlZmZlY3QgZnJvbSB0aGUgX25leHRfIHNlbGVjdGlvbi4gTm9uZSBkaXNhYmxlcyBmdXR1cmUgc2VsZWN0aW9uLCBidXRcbi8vIGRvZXMgbm90IGNsZWFyIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gVXNlIHRoZSBgZGVzZWxlY3RgIG1ldGhvZHMgZm9yIHRoYXRcbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LnN0eWxlKCknLCBmdW5jdGlvbiAoIHN0eWxlICkge1xuXHRpZiAoIHN0eWxlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LnN0eWxlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGlmICggISBjdHguX3NlbGVjdCApIHtcblx0XHRcdERhdGFUYWJsZS5zZWxlY3QuaW5pdCggbmV3IERhdGFUYWJsZS5BcGkoY3R4KSApO1xuXHRcdH1cblxuXHRcdGlmICggISBjdHguX3NlbGVjdF9pbml0ICkge1xuXHRcdFx0aW5pdChjdHgpO1xuXHRcdH1cblxuXHRcdGN0eC5fc2VsZWN0LnN0eWxlID0gc3R5bGU7XG5cblx0XHQvLyBBZGQgLyByZW1vdmUgbW91c2UgZXZlbnQgaGFuZGxlcnMuIFRoZXkgYXJlbid0IHJlcXVpcmVkIHdoZW4gb25seVxuXHRcdC8vIEFQSSBzZWxlY3Rpb24gaXMgYXZhaWxhYmxlXG5cdFx0dmFyIGR0ID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApO1xuXHRcdGRpc2FibGVNb3VzZVNlbGVjdGlvbiggZHQgKTtcblx0XHRcblx0XHRpZiAoIHN0eWxlICE9PSAnYXBpJyApIHtcblx0XHRcdGVuYWJsZU1vdXNlU2VsZWN0aW9uKCBkdCApO1xuXHRcdH1cblxuXHRcdGV2ZW50VHJpZ2dlciggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApLCAnc2VsZWN0U3R5bGUnLCBbIHN0eWxlIF0gKTtcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC5zZWxlY3RvcigpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC5zZWxlY3Rvcjtcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oIG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKSApO1xuXG5cdFx0Y3R4Ll9zZWxlY3Quc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdGlmICggY3R4Ll9zZWxlY3Quc3R5bGUgIT09ICdhcGknICkge1xuXHRcdFx0ZW5hYmxlTW91c2VTZWxlY3Rpb24oIG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuc2VsZWN0KCknLCAncm93KCkuc2VsZWN0KCknLCBmdW5jdGlvbiAoIHNlbGVjdCApIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0aWYgKCBzZWxlY3QgPT09IGZhbHNlICkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjbGVhciggY3R4ICk7XG5cblx0XHRjdHguYW9EYXRhWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gdHJ1ZTtcblx0XHQkKCBjdHguYW9EYXRhWyBpZHggXS5uVHIgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ3NlbGVjdCcsIFsgJ3JvdycsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdyb3coKS5zZWxlY3RlZCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdGlmIChcblx0XHRjdHggJiZcblx0XHR0aGlzLmxlbmd0aCAmJlxuXHRcdGN0eC5hb0RhdGFbdGhpc1swXV0gJiZcblx0XHRjdHguYW9EYXRhW3RoaXNbMF1dLl9zZWxlY3Rfc2VsZWN0ZWRcblx0KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59ICk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnNlbGVjdCgpJywgJ2NvbHVtbigpLnNlbGVjdCgpJywgZnVuY3Rpb24gKCBzZWxlY3QgKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdGlmICggc2VsZWN0ID09PSBmYWxzZSApIHtcblx0XHRyZXR1cm4gdGhpcy5kZXNlbGVjdCgpO1xuXHR9XG5cblx0dGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggY3R4LCBpZHggKSB7XG5cdFx0Y2xlYXIoIGN0eCApO1xuXG5cdFx0Y3R4LmFvQ29sdW1uc1sgaWR4IF0uX3NlbGVjdF9zZWxlY3RlZCA9IHRydWU7XG5cblx0XHR2YXIgY29sdW1uID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApLmNvbHVtbiggaWR4ICk7XG5cblx0XHQkKCBjb2x1bW4uaGVhZGVyKCkgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0JCggY29sdW1uLmZvb3RlcigpICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXG5cdFx0Y29sdW1uLm5vZGVzKCkudG8kKCkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdzZWxlY3QnLCBbICdjb2x1bW4nLCBhcGlbaV0gXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnY29sdW1uKCkuc2VsZWN0ZWQoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblxuXHRpZiAoXG5cdFx0Y3R4ICYmXG5cdFx0dGhpcy5sZW5ndGggJiZcblx0XHRjdHguYW9Db2x1bW5zW3RoaXNbMF1dICYmXG5cdFx0Y3R4LmFvQ29sdW1uc1t0aGlzWzBdXS5fc2VsZWN0X3NlbGVjdGVkXG5cdCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSApO1xuXG5hcGlSZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuc2VsZWN0KCknLCAnY2VsbCgpLnNlbGVjdCgpJywgZnVuY3Rpb24gKCBzZWxlY3QgKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdGlmICggc2VsZWN0ID09PSBmYWxzZSApIHtcblx0XHRyZXR1cm4gdGhpcy5kZXNlbGVjdCgpO1xuXHR9XG5cblx0dGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIGN0eCwgcm93SWR4LCBjb2xJZHggKSB7XG5cdFx0Y2xlYXIoIGN0eCApO1xuXG5cdFx0dmFyIGRhdGEgPSBjdHguYW9EYXRhWyByb3dJZHggXTtcblxuXHRcdGlmICggZGF0YS5fc2VsZWN0ZWRfY2VsbHMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGRhdGEuX3NlbGVjdGVkX2NlbGxzID0gW107XG5cdFx0fVxuXG5cdFx0ZGF0YS5fc2VsZWN0ZWRfY2VsbHNbIGNvbElkeCBdID0gdHJ1ZTtcblxuXHRcdGlmICggZGF0YS5hbkNlbGxzICkge1xuXHRcdFx0JCggZGF0YS5hbkNlbGxzWyBjb2xJZHggXSApLmFkZENsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHR9XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ3NlbGVjdCcsIFsgJ2NlbGwnLCBhcGkuY2VsbHMoYXBpW2ldKS5pbmRleGVzKCkudG9BcnJheSgpIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ2NlbGwoKS5zZWxlY3RlZCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdGlmIChjdHggJiYgdGhpcy5sZW5ndGgpIHtcblx0XHR2YXIgcm93ID0gY3R4LmFvRGF0YVt0aGlzWzBdWzBdLnJvd107XG5cblx0XHRpZiAocm93ICYmIHJvdy5fc2VsZWN0ZWRfY2VsbHMgJiYgcm93Ll9zZWxlY3RlZF9jZWxsc1t0aGlzWzBdWzBdLmNvbHVtbl0pIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0gKTtcblxuXG5hcGlSZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5kZXNlbGVjdCgpJywgJ3JvdygpLmRlc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIGN0eCwgaWR4ICkge1xuXHRcdGN0eC5hb0RhdGFbIGlkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbCA9IG51bGw7XG5cdFx0JCggY3R4LmFvRGF0YVsgaWR4IF0ublRyICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdkZXNlbGVjdCcsIFsgJ3JvdycsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGVzZWxlY3QoKScsICdjb2x1bW4oKS5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHR0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjdHguYW9Db2x1bW5zWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gZmFsc2U7XG5cblx0XHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApO1xuXHRcdHZhciBjb2x1bW4gPSBhcGkuY29sdW1uKCBpZHggKTtcblxuXHRcdCQoIGNvbHVtbi5oZWFkZXIoKSApLnJlbW92ZUNsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHQkKCBjb2x1bW4uZm9vdGVyKCkgKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cblx0XHQvLyBOZWVkIHRvIGxvb3Agb3ZlciBlYWNoIGNlbGwsIHJhdGhlciB0aGFuIGp1c3QgdXNpbmdcblx0XHQvLyBgY29sdW1uKCkubm9kZXMoKWAgYXMgY2VsbHMgd2hpY2ggYXJlIGluZGl2aWR1YWxseSBzZWxlY3RlZCBzaG91bGRcblx0XHQvLyBub3QgaGF2ZSB0aGUgYHNlbGVjdGVkYCBjbGFzcyByZW1vdmVkIGZyb20gdGhlbVxuXHRcdGFwaS5jZWxscyggbnVsbCwgaWR4ICkuaW5kZXhlcygpLmVhY2goIGZ1bmN0aW9uIChjZWxsSWR4KSB7XG5cdFx0XHR2YXIgZGF0YSA9IGN0eC5hb0RhdGFbIGNlbGxJZHgucm93IF07XG5cdFx0XHR2YXIgY2VsbFNlbGVjdGVkID0gZGF0YS5fc2VsZWN0ZWRfY2VsbHM7XG5cblx0XHRcdGlmICggZGF0YS5hbkNlbGxzICYmICghIGNlbGxTZWxlY3RlZCB8fCAhIGNlbGxTZWxlY3RlZFsgY2VsbElkeC5jb2x1bW4gXSkgKSB7XG5cdFx0XHRcdCQoIGRhdGEuYW5DZWxsc1sgY2VsbElkeC5jb2x1bW4gIF0gKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdkZXNlbGVjdCcsIFsgJ2NvbHVtbicsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmRlc2VsZWN0KCknLCAnY2VsbCgpLmRlc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBjdHgsIHJvd0lkeCwgY29sSWR4ICkge1xuXHRcdHZhciBkYXRhID0gY3R4LmFvRGF0YVsgcm93SWR4IF07XG5cblx0XHRpZihkYXRhLl9zZWxlY3RlZF9jZWxscyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkYXRhLl9zZWxlY3RlZF9jZWxsc1sgY29sSWR4IF0gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgY2xhc3Mgb25seSBpZiB0aGUgY2VsbHMgZXhpc3QsIGFuZCB0aGUgY2VsbCBpcyBub3QgY29sdW1uXG5cdFx0Ly8gc2VsZWN0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIGNsYXNzIHNob3VsZCByZW1haW4gKHNpbmNlIGl0IGlzIHNlbGVjdGVkXG5cdFx0Ly8gaW4gdGhlIGNvbHVtbilcblx0XHRpZiAoIGRhdGEuYW5DZWxscyAmJiAhIGN0eC5hb0NvbHVtbnNbIGNvbElkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgKSB7XG5cdFx0XHQkKCBkYXRhLmFuQ2VsbHNbIGNvbElkeCBdICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnZGVzZWxlY3QnLCBbICdjZWxsJywgYXBpW2ldIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIEJ1dHRvbnNcbiAqL1xuZnVuY3Rpb24gaTE4biggbGFiZWwsIGRlZiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChkdCkge1xuXHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy4nK2xhYmVsLCBkZWYgKTtcblx0fTtcbn1cblxuLy8gQ29tbW9uIGV2ZW50cyB3aXRoIHN1aXRhYmxlIG5hbWVzcGFjZXNcbmZ1bmN0aW9uIG5hbWVzcGFjZWRFdmVudHMgKCBjb25maWcgKSB7XG5cdHZhciB1bmlxdWUgPSBjb25maWcuX2V2ZW50TmFtZXNwYWNlO1xuXG5cdHJldHVybiAnZHJhdy5kdC5EVCcrdW5pcXVlKycgc2VsZWN0LmR0LkRUJyt1bmlxdWUrJyBkZXNlbGVjdC5kdC5EVCcrdW5pcXVlO1xufVxuXG5mdW5jdGlvbiBlbmFibGVkICggZHQsIGNvbmZpZyApIHtcblx0aWYgKCAkLmluQXJyYXkoICdyb3dzJywgY29uZmlnLmxpbWl0VG8gKSAhPT0gLTEgJiYgZHQucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoICQuaW5BcnJheSggJ2NvbHVtbnMnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5jb2x1bW5zKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggJC5pbkFycmF5KCAnY2VsbHMnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfYnV0dG9uTmFtZXNwYWNlID0gMDtcblxuJC5leHRlbmQoIERhdGFUYWJsZS5leHQuYnV0dG9ucywge1xuXHRzZWxlY3RlZDoge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RlZCcsICdTZWxlY3RlZCcgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdGVkJyxcblx0XHRsaW1pdFRvOiBbICdyb3dzJywgJ2NvbHVtbnMnLCAnY2VsbHMnIF0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0Ly8gLkRUIG5hbWVzcGFjZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgYnkgRGF0YVRhYmxlcyBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBvbiB0YWJsZSBkZXN0cm95XG5cdFx0XHRkdC5vbiggbmFtZXNwYWNlZEV2ZW50cyhjb25maWcpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBlbmFibGVkKGR0LCBjb25maWcpICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0ZHQub2ZmKCBjb25maWcuX2V2ZW50TmFtZXNwYWNlICk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3RlZFNpbmdsZToge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RlZFNpbmdsZScsICdTZWxlY3RlZCBzaW5nbGUnICksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3RlZC1zaW5nbGUnLFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmZpZyApIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgPSAnLnNlbGVjdCcrKF9idXR0b25OYW1lc3BhY2UrKyk7XG5cblx0XHRcdGR0Lm9uKCBuYW1lc3BhY2VkRXZlbnRzKGNvbmZpZyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gZHQucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNvbHVtbnMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGggK1xuXHRcdFx0XHQgICAgICAgICAgICBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblxuXHRcdFx0XHR0aGF0LmVuYWJsZSggY291bnQgPT09IDEgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH0sXG5cdHNlbGVjdEFsbDoge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RBbGwnLCAnU2VsZWN0IGFsbCcgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdC1hbGwnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHRoaXNbIGl0ZW1zKydzJyBdKCkuc2VsZWN0KCk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3ROb25lOiB7XG5cdFx0dGV4dDogaTE4biggJ3NlbGVjdE5vbmUnLCAnRGVzZWxlY3QgYWxsJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LW5vbmUnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXIoIHRoaXMuc2V0dGluZ3MoKVswXSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0ZHQub24oIG5hbWVzcGFjZWRFdmVudHMoY29uZmlnKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY291bnQgPSBkdC5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoICtcblx0XHRcdFx0ICAgICAgICAgICAgZHQuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBjb3VudCA+IDAgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuJC5lYWNoKCBbICdSb3cnLCAnQ29sdW1uJywgJ0NlbGwnIF0sIGZ1bmN0aW9uICggaSwgaXRlbSApIHtcblx0dmFyIGxjID0gaXRlbS50b0xvd2VyQ2FzZSgpO1xuXG5cdERhdGFUYWJsZS5leHQuYnV0dG9uc1sgJ3NlbGVjdCcraXRlbSsncycgXSA9IHtcblx0XHR0ZXh0OiBpMThuKCAnc2VsZWN0JytpdGVtKydzJywgJ1NlbGVjdCAnK2xjKydzJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LScrbGMrJ3MnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZWxlY3QuaXRlbXMoIGxjICk7XG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0XHRkdC5vbiggJ3NlbGVjdEl0ZW1zLmR0LkRUJywgZnVuY3Rpb24gKCBlLCBjdHgsIGl0ZW1zICkge1xuXHRcdFx0XHR0aGF0LmFjdGl2ZSggaXRlbXMgPT09IGxjICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIEluaXRpYWxpc2F0aW9uXG4gKi9cblxuLy8gRGF0YVRhYmxlcyBjcmVhdGlvbiAtIGNoZWNrIGlmIHNlbGVjdCBoYXMgYmVlbiBkZWZpbmVkIGluIHRoZSBvcHRpb25zLiBOb3RlXG4vLyB0aGlzIHJlcXVpcmVkIHRoYXQgdGhlIHRhYmxlIGJlIGluIHRoZSBkb2N1bWVudCEgSWYgaXQgaXNuJ3QgdGhlbiBzb21ldGhpbmdcbi8vIG5lZWRzIHRvIHRyaWdnZXIgdGhpcyBtZXRob2QgdW5mb3J0dW5hdGVseS4gVGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZlxuLy8gRGF0YVRhYmxlcyB3aWxsIHJld29yayB0aGUgZXZlbnRzIGFuZCBhZGRyZXNzIHRoaXMuXG4kKGRvY3VtZW50KS5vbiggJ3ByZUluaXQuZHQuZHRTZWxlY3QnLCBmdW5jdGlvbiAoZSwgY3R4KSB7XG5cdGlmICggZS5uYW1lc3BhY2UgIT09ICdkdCcgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcbn0gKTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlLnNlbGVjdDtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-select/js/dataTables.select.js\n");

/***/ }),

/***/ "datatables.net":
/*!*********************************!*\
  !*** external "$.fn.dataTable" ***!
  \*********************************/
/***/ (function(module) {

"use strict";
module.exports = window["$.fn.dataTable"];

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module) {

"use strict";
module.exports = window["jQuery"];

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/datatables-select/datatables-select.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;