/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shepherd\": function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL1Z1ZXh5Ly4vbGlicy9zaGVwaGVyZC9zaGVwaGVyZC5qcz83YTgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaGVwaGVyZCBmcm9tICdzaGVwaGVyZC5qcy9kaXN0L2pzL3NoZXBoZXJkJztcclxuXHJcbmV4cG9ydCB7IFNoZXBoZXJkIH07XHJcbiJdLCJuYW1lcyI6WyJTaGVwaGVyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! shepherd.js 10.0.1 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref6 = step.options.advanceOn || {},\n      event = _ref6.event,\n      selector = _ref6.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function getBoundingClientRect(element, includeScale) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    var rect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (isHTMLElement(element) && includeScale) {\n      var offsetHeight = element.offsetHeight;\n      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n      // Fallback to 1 in case both values are `0`\n\n      if (offsetWidth > 0) {\n        scaleX = round(rect.width) / offsetWidth || 1;\n      }\n      if (offsetHeight > 0) {\n        scaleY = round(rect.height) / offsetHeight || 1;\n      }\n    }\n    return {\n      width: rect.width / scaleX,\n      height: rect.height / scaleY,\n      top: rect.top / scaleY,\n      right: rect.right / scaleX,\n      bottom: rect.bottom / scaleY,\n      left: rect.left / scaleX,\n      x: rect.left / scaleX,\n      y: rect.top / scaleY\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n      options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === 'x' ? top : left;\n      var _altSide = mainAxis === 'x' ? bottom : right;\n      var _offset = popperOffsets[altAxis];\n      var _len = altAxis === 'y' ? 'height' : 'width';\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates a modifier for popper that will help focus the element after it has\n   * been rendered\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The focus after render modifier configuration object\n   */\n\n  function generateFocusAfterRenderModifier(step) {\n    return {\n      name: 'focusAfterRender',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn() {\n        setTimeout(function () {\n          if (step.el) {\n            var focusOptions = {\n              preventScroll: true\n            };\n            step.el.focus(focusOptions);\n          }\n        }, 300);\n      }\n    };\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [generateFocusAfterRenderModifier(step)]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {// TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n    if (shouldCenterStep(attachToOptions)) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, generateFocusAfterRenderModifier(step)],\n      strategy: 'absolute'\n    };\n    if (shouldCenterStep(attachToOptions)) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n      return mergedPopperOptions;\n    }\n    return popperOptions;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) {\n      tar[k] = src[k];\n    }\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n\n  function flush() {\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      while (flushidx < dirty_components.length) {\n        var component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) {\n        binding_callbacks.pop()();\n      } // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.49.0 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/\n        ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/\n            ctx[0])) /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          dirty = _ref7[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/\n        32) button.innerHTML = /*text*/\n        ctx[5];\n        if (dirty & /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/\n        4) {\n          button.disabled = /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    var _super = _createSuper(Shepherd_button);\n    function Shepherd_button(options) {\n      var _this3;\n      _classCallCheck(this, Shepherd_button);\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.49.0 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].m(target, anchor);\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/\n        3) {\n          each_value = /*buttons*/\n          ctx[1];\n          var _i4;\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n              each_blocks[_i4].c();\n              transition_in(each_blocks[_i4], 1);\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/\n        ctx[2],\n        step: /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/\n        2) shepherdbutton_changes.config = /*config*/\n        ctx[2];\n        if (dirty & /*step*/\n        1) shepherdbutton_changes.step = /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n          dirty = _ref8[0];\n        if ( /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    var _super2 = _createSuper(Shepherd_footer);\n    function Shepherd_footer(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_footer);\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.49.0 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n          dirty = _ref9[0];\n        if (dirty & /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.49.0 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n          dirty = _ref10[0];\n        if (dirty & /*labelId*/\n        2) {\n          attr(h3, \"id\", /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    var _super4 = _createSuper(Shepherd_title);\n    function Shepherd_title(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_title);\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.49.0 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/\n        ctx[0],\n        title: /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/\n        1) shepherdtitle_changes.labelId = /*labelId*/\n        ctx[0];\n        if (dirty & /*title*/\n        4) shepherdtitle_changes.title = /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/\n        ctx[3],\n        step: /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/\n        ctx[3];\n        if (dirty & /*step*/\n        2) shepherdcancelicon_changes.step = /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/\n    ctx[3] && /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n          dirty = _ref11[0];\n        if ( /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/\n        ctx[3] && /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    var _super5 = _createSuper(Shepherd_header);\n    function Shepherd_header(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_header);\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.49.0 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n          dirty = _ref12[0];\n        if (dirty & /*descriptionId*/\n        2) {\n          attr(div, \"id\", /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    var _super6 = _createSuper(Shepherd_text);\n    function Shepherd_text(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_text);\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.49.0 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/\n        ctx[1],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/\n        2) shepherdheader_changes.labelId = /*labelId*/\n        ctx[1];\n        if (dirty & /*step*/\n        4) shepherdheader_changes.step = /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[0],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/\n        1) shepherdtext_changes.descriptionId = /*descriptionId*/\n        ctx[0];\n        if (dirty & /*step*/\n        4) shepherdtext_changes.step = /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/\n        4) shepherdfooter_changes.step = /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/\n    ctx[2].options.title) || /*step*/\n    ctx[2].options.cancelIcon && /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/\n    ctx[2].options.buttons) && /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n          dirty = _ref13[0];\n        if (dirty & /*step*/\n        4) show_if_2 = !isUndefined( /*step*/\n        ctx[2].options.title) || /*step*/\n        ctx[2].options.cancelIcon && /*step*/\n        ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if_1 = !isUndefined( /*step*/\n        ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if = Array.isArray( /*step*/\n        ctx[2].options.buttons) && /*step*/\n        ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    var _super7 = _createSuper(Shepherd_content);\n    function Shepherd_content(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_content);\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.49.0 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/\n    ctx[4].options.arrow && /*step*/\n    ctx[4].options.attachTo && /*step*/\n    ctx[4].options.attachTo.element && /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[2],\n        labelId: /*labelId*/\n        ctx[3],\n        step: /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/\n      ctx[4].options.text) ? /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/\n      ctx[4].options.title ? /*labelId*/\n      ctx[3] : null\n    }, /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n          dirty = _ref14[0];\n        if ( /*step*/\n        ctx[4].options.arrow && /*step*/\n        ctx[4].options.attachTo && /*step*/\n        ctx[4].options.attachTo.element && /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId = /*descriptionId*/\n        ctx[2];\n        if (dirty & /*labelId*/\n        8) shepherdcontent_changes.labelId = /*labelId*/\n        ctx[3];\n        if (dirty & /*step*/\n        16) shepherdcontent_changes.step = /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/\n        ctx[4].options.text) ? /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/\n        ctx[4].options.title ? /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/\n        2 && /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    var _super8 = _createSuper(Shepherd_element);\n    function Shepherd_element(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_element);\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset,\n            // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n            original.elementScroll.call(this,\n            // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft,\n            // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    var _super9 = _createSuper(Step);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this11;\n      _classCallCheck(this, Step);\n      if (options === void 0) {\n        options = {};\n      }\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n\n      _this11._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this11));\n      _this11._setOptions(options);\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this13 = this;\n        if (options === void 0) {\n          options = {};\n        }\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n        this.trigger('before-show'); // Force resolve to make sure the options are updated on subsequent shows.\n\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$r = _ref.r,\n      r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.49.0 */\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref15 = _slicedToArray(_ref, 1),\n          dirty = _ref15[0];\n        if (dirty & /*pathDefinition*/\n        4) {\n          attr(path, \"d\", /*pathDefinition*/\n          ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    var _super10 = _createSuper(Shepherd_modal);\n    function Shepherd_modal(options) {\n      var _this15;\n      _classCallCheck(this, Shepherd_modal);\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    var _super11 = _createSuper(Tour);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this16;\n      _classCallCheck(this, Tour);\n      if (options === void 0) {\n        options = {};\n      }\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this16._setTourID();\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this18.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n        if (forward === void 0) {\n          forward = true;\n        }\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQSxJQUFJQSxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQkMsS0FBM0IsRUFBa0M7SUFDekQsT0FBT0MsZUFBZSxDQUFDRCxLQUFELENBQWYsSUFDSCxDQUFDRSxTQUFTLENBQUNGLEtBQUQsQ0FEZDtFQUVBLENBSEQ7RUFLQSxTQUFTQyxlQUFULENBQXlCRCxLQUF6QixFQUFnQztJQUMvQixPQUFPLENBQUMsQ0FBQ0EsS0FBRixJQUFXLFFBQU9BLEtBQVAsTUFBaUIsUUFBbkM7RUFDQTtFQUVELFNBQVNFLFNBQVQsQ0FBbUJGLEtBQW5CLEVBQTBCO0lBQ3pCLElBQUlHLFdBQVcsR0FBR0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JQLEtBQS9CLENBQWxCO0lBRUEsT0FBT0csV0FBVyxLQUFLLGlCQUFoQixJQUNIQSxXQUFXLEtBQUssZUFEYixJQUVISyxjQUFjLENBQUNSLEtBQUQsQ0FGbEI7RUFHQTs7RUFHRCxJQUFJUyxZQUFZLEdBQUcsT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUFnQ0EsTUFBTSxDQUFDQyxHQUExRDtFQUNBLElBQUlDLGtCQUFrQixHQUFHSCxZQUFZLEdBQUdDLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGVBQVgsQ0FBSCxHQUFpQyxNQUF0RTtFQUVBLFNBQVNILGNBQVQsQ0FBd0JSLEtBQXhCLEVBQStCO0lBQzlCLE9BQU9BLEtBQUssQ0FBQ2EsUUFBTixLQUFtQkQsa0JBQTFCO0VBQ0E7RUFFRCxTQUFTRSxXQUFULENBQXFCQyxHQUFyQixFQUEwQjtJQUN6QixPQUFPQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsR0FBZCxDQUFxQixLQUFyQixHQUEwQixFQUFqQztFQUNBO0VBRUQsU0FBU0csNkJBQVQsQ0FBdUNsQixL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QixJQUFLQSxZQUFMLENBQWlCM2IsSUFBakI7UUFDRDtRQUVELElBQUksQ0FBQyxLQUFLb2MsUUFBTCxFQUFMLEVBQXNCO1VBQ3BCLEtBQUtVLGdCQUFMO1FBQ0Q7TUFDRjtNQUVEO0FBQ0Y7QUFDQTtBQUNBO0lBSEU7TUFBQTtNQUFBLE9BSUFyQixzQkFBYTtRQUNYLElBQU15QixRQUFRLEdBQUcsS0FBS3oyQixPQUFMLENBQWF5MkIsUUFBYixJQUF5QixNQUExQztRQUVBLEtBQUt0SyxFQUFMLGFBQWFzSyxRQUFTLGVBQUkzVSxJQUFJLEVBQUcsQ0FBakM7TUFDRDtJQUFBO0lBQUE7RUFBQSxFQTlXdUI5ZSxPQUFuQjtFQ2hCUC9ELE1BQU0sQ0FBQ3VKLE1BQVAsQ0FBY2tzQixRQUFkLEVBQXdCO0lBQUVDLElBQUYsRUFBRUEsSUFBRjtJQUFRbkU7RUFBUixDQUF4QiIsInNvdXJjZXMiOlsid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanM/NWFkMSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvdXRpbHMvdHlwZS1jaGVjay5qcz8xZmQzIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9ldmVudGVkLmpzPzk3M2QiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL2F1dG8tYmluZC5qcz83YjE2Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy91dGlscy9iaW5kLmpzP2E1MTUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcz80Njk3Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzPzkwNjAiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzPzlhOTQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcz83Y2Y4Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzPzEyZWIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzPzE1N2QiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzPzNiOGMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzP2RkMTQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcz83ODAzIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzPzU4MTAiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcz8wOTA4Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzPzM3ZDQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzPzM4NDgiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcz9lMDg5Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcz81ODJhIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzPzVkMGIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanM/ZDA5MyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcz9kMDdmIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzPzgwZjUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanM/NTQxMSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz9kMTMwIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzP2MwMWYiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcz82MzkxIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzPzc5MzUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcz9hMDA2Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanM/ZjgxZSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanM/OGE3MCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzPzY2ZDMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzP2Q3ZmUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzPzMzMWUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanM/Nzg2MyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanM/YTMyYSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz82ZjU5Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcz85YzM5Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcz9kMTZkIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanM/NGU3NSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzP2I1MzQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcz8yZWExIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanM/ZGI0OCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzP2FiOTciLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzP2MzNjkiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz81ODAxIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcz9kOGM3Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcz9mOThlIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzP2I3ZTYiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcz82NmNmIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanM/ZGQyYSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2NmYWIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcz9iODBiIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanM/YjA2OSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz9hOTAwIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzPzUxNWUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL3BvcHBlci1vcHRpb25zLmpzP2M2OWIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL2dlbmVyYWwuanM/YjQyZCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcz8wNGY3Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWJ1dHRvbi5zdmVsdGU/NzhjNSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1mb290ZXIuc3ZlbHRlP2FmNDciLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtY2FuY2VsLWljb24uc3ZlbHRlPzc5YzEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtdGl0bGUuc3ZlbHRlP2NhYzIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtaGVhZGVyLnN2ZWx0ZT8yZjI3Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLXRleHQuc3ZlbHRlP2FjZWYiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtY29udGVudC5zdmVsdGU/ZjA3ZSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1lbGVtZW50LnN2ZWx0ZT9iNTg2Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9zbW9vdGhzY3JvbGwtcG9seWZpbGwvZGlzdC9zbW9vdGhzY3JvbGwuanM/ZTZjOCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvc3RlcC5qcz9hZDhkIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy91dGlscy9jbGVhbnVwLmpzPzZkY2EiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL292ZXJsYXktcGF0aC5qcz9jZDUzIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZT9mNTRiIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy90b3VyLmpzPzM5NTEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3NoZXBoZXJkLmpzPzUxNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBFbGVtZW50YC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGFuIEVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEhUTUxFbGVtZW50YC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGFuIEhUTUxFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2Agb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbmV4cG9ydCBjbGFzcyBFdmVudGVkIHtcbiAgb24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgb25jZSA9IGZhbHNlKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgfVxuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzW2V2ZW50XSkpIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdID0gW107XG4gICAgfVxuICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnB1c2goeyBoYW5kbGVyLCBjdHgsIG9uY2UgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIsIGN0eCkge1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIHRydWUpO1xuICB9XG5cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3MpIHx8IGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3NbZXZlbnRdKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKSB7XG4gICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tldmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLmZvckVhY2goKGJpbmRpbmcsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyaWdnZXIoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3MpICYmIHRoaXMuYmluZGluZ3NbZXZlbnRdKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5mb3JFYWNoKChiaW5kaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgaGFuZGxlciwgb25jZSB9ID0gYmluZGluZztcblxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3R4IHx8IHRoaXM7XG5cbiAgICAgICAgaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcblxuICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCIvKipcbiAqIEJpbmRzIGFsbCB0aGUgbWV0aG9kcyBvbiBhIEpTIENsYXNzIHRvIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3MuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hdXRvLWJpbmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWxmIFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBjbGFzc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvQmluZChzZWxmKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgdmFsID0gc2VsZltrZXldO1xuICAgIGlmIChrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZltrZXldID0gdmFsLmJpbmQoc2VsZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG4iLCJpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4vdHlwZS1jaGVjayc7XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgaGFuZGxlciB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGFkdmFuY2UgdGhlIHRvdXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zZXR1cEFkdmFuY2VPbkhhbmRsZXIoc2VsZWN0b3IsIHN0ZXApIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmIChzdGVwLmlzT3BlbigpKSB7XG4gICAgICBjb25zdCB0YXJnZXRJc0VsID0gc3RlcC5lbCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBzdGVwLmVsO1xuICAgICAgY29uc3QgdGFyZ2V0SXNTZWxlY3RvciA9XG4gICAgICAgICFpc1VuZGVmaW5lZChzZWxlY3RvcikgJiYgZXZlbnQuY3VycmVudFRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKTtcblxuICAgICAgaWYgKHRhcmdldElzU2VsZWN0b3IgfHwgdGFyZ2V0SXNFbCkge1xuICAgICAgICBzdGVwLnRvdXIubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kIHRoZSBldmVudCBoYW5kbGVyIGZvciBhZHZhbmNlT25cbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEFkdmFuY2Uoc3RlcCkge1xuICAvLyBBbiBlbXB0eSBzZWxlY3RvciBtYXRjaGVzIHRoZSBzdGVwIGVsZW1lbnRcbiAgY29uc3QgeyBldmVudCwgc2VsZWN0b3IgfSA9IHN0ZXAub3B0aW9ucy5hZHZhbmNlT24gfHwge307XG4gIGlmIChldmVudCkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKTtcblxuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGFsc28gYmluZC91bmJpbmQgb24gc2hvdy9oaWRlXG4gICAgbGV0IGVsO1xuICAgIHRyeSB7XG4gICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChzZWxlY3RvcikgJiYgIWVsKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICAgYE5vIGVsZW1lbnQgd2FzIGZvdW5kIGZvciB0aGUgc2VsZWN0b3Igc3VwcGxpZWQgdG8gYWR2YW5jZU9uOiAke3NlbGVjdG9yfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIHN0ZXAub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgJ2FkdmFuY2VPbiB3YXMgZGVmaW5lZCwgYnV0IG5vIGV2ZW50IG5hbWUgd2FzIHBhc3NlZC4nXG4gICAgKTtcbiAgfVxufVxuIiwiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyIsImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlKSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgaW5jbHVkZVNjYWxlKSB7XG4gICAgdmFyIG9mZnNldEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBvZmZzZXRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7IC8vIERvIG5vdCBhdHRlbXB0IHRvIGRpdmlkZSBieSAwLCBvdGhlcndpc2Ugd2UgZ2V0IGBJbmZpbml0eWAgYXMgc2NhbGVcbiAgICAvLyBGYWxsYmFjayB0byAxIGluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIGAwYFxuXG4gICAgaWYgKG9mZnNldFdpZHRoID4gMCkge1xuICAgICAgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBvZmZzZXRXaWR0aCB8fCAxO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBvZmZzZXRIZWlnaHQgfHwgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoIC8gc2NhbGVYLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyBzY2FsZVksXG4gICAgdG9wOiByZWN0LnRvcCAvIHNjYWxlWSxcbiAgICByaWdodDogcmVjdC5yaWdodCAvIHNjYWxlWCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tIC8gc2NhbGVZLFxuICAgIGxlZnQ6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB4OiByZWN0LmxlZnQgLyBzY2FsZVgsXG4gICAgeTogcmVjdC50b3AgLyBzY2FsZVlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cbiAgLy8gQWxzbywgYGh0bWwuY2xpZW50SGVpZ2h0YCBhZGRzIHRoZSBib3R0b20gYmFyIGhlaWdodCBpbiBTYWZhcmkgaU9TLCBldmVuXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDsgLy8gVXNlcyBMYXlvdXQgVmlld3BvcnQgKGxpa2UgQ2hyb21lOyBTYWZhcmkgZG9lcyBub3QgY3VycmVudGx5KVxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxuICAgIC8vIFNhZmFyaSByZXR1cm5zIGEgbnVtYmVyIDw9IDAsIHVzdWFsbHkgPCAtMSB3aGVuIHBpbmNoLXpvb21lZFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XG4gICAgLy8gMC4wMDFcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcIk5vdCBTYWZhcmlcIiB1c2VyQWdlbnRcblxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgdW5pcXVlQnkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlQnkuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwiZnVuY3Rpb24gX2dldENlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllcigpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgICAgZm4oeyBzdGF0ZSB9KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKG5hbWUgIT09ICdwb3BwZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG1vZGlmaWVyIGZvciBwb3BwZXIgdGhhdCB3aWxsIGhlbHAgZm9jdXMgdGhlIGVsZW1lbnQgYWZ0ZXIgaXQgaGFzXG4gKiBiZWVuIHJlbmRlcmVkXG4gKlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmb2N1cyBhZnRlciByZW5kZXIgbW9kaWZpZXIgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyKHN0ZXApIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZm9jdXNBZnRlclJlbmRlcicsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgIGZuKCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGVwLmVsKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNPcHRpb25zID0ge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzdGVwLmVsLmZvY3VzKGZvY3VzT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgYXJyYXkgb2Ygb3B0aW9ucyBmb3IgYSB0b29sdGlwIHRoYXQgZG9lc24ndCBoYXZlIGFcbiAqIHRhcmdldCBlbGVtZW50IGluIHRoZSBET00gLS0gYW5kIHRodXMgaXMgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXG4gKiBvZiB0aGUgdmlld1xuICpcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZmluYWwgUG9wcGVyIG9wdGlvbnMgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2VudGVyZWRQb3BwZXIoc3RlcCkge1xuICBjb25zdCBjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIgPSBfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyKCk7XG5cbiAgbGV0IHBvcHBlck9wdGlvbnMgPSB7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBzdHJhdGVneTogJ2ZpeGVkJyxcbiAgICBtb2RpZmllcnM6IFtnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllcihzdGVwKV1cbiAgfTtcblxuICBwb3BwZXJPcHRpb25zID0ge1xuICAgIC4uLnBvcHBlck9wdGlvbnMsXG4gICAgbW9kaWZpZXJzOiBBcnJheS5mcm9tKFxuICAgICAgbmV3IFNldChbLi4ucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMsIC4uLmNlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllcl0pXG4gICAgKVxuICB9O1xuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuaW1wb3J0IHsgbWFrZUNlbnRlcmVkUG9wcGVyLCBnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllciB9IGZyb20gJy4vcG9wcGVyLW9wdGlvbnMnO1xuXG4vKipcbiAqIEVuc3VyZSBjbGFzcyBwcmVmaXggZW5kcyBpbiBgLWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCB0byBwcmVwZW5kIHRvIHRoZSBjbGFzcyBuYW1lcyBnZW5lcmF0ZWQgYnkgbmFuby1jc3NcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHByZWZpeCBlbmRpbmcgaW4gYC1gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQcmVmaXgocHJlZml4KSB7XG4gIGlmICghaXNTdHJpbmcocHJlZml4KSB8fCBwcmVmaXggPT09ICcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeC5jaGFyQXQocHJlZml4Lmxlbmd0aCAtIDEpICE9PSAnLScgPyBgJHtwcmVmaXh9LWAgOiBwcmVmaXg7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYXR0YWNoVG8gb3B0aW9ucywgY29udmVydGluZyBlbGVtZW50IG9wdGlvbiB2YWx1ZSB0byBhIHF1YWxpZmllZCBIVE1MRWxlbWVudC5cbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybnMge3t9fHtlbGVtZW50LCBvbn19XG4gKiBgZWxlbWVudGAgaXMgYSBxdWFsaWZpZWQgSFRNTCBFbGVtZW50XG4gKiBgb25gIGlzIGEgc3RyaW5nIHBvc2l0aW9uIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUF0dGFjaFRvKHN0ZXApIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHN0ZXAub3B0aW9ucy5hdHRhY2hUbyB8fCB7fTtcbiAgY29uc3QgcmV0dXJuT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gIGlmIChpc0Z1bmN0aW9uKHJldHVybk9wdHMuZWxlbWVudCkpIHtcbiAgICAvLyBCaW5kIHRoZSBjYWxsYmFjayB0byBzdGVwIHNvIHRoYXQgaXQgaGFzIGFjY2VzcyB0byB0aGUgb2JqZWN0LCB0byBlbmFibGUgcnVubmluZyBhZGRpdGlvbmFsIGxvZ2ljXG4gICAgcmV0dXJuT3B0cy5lbGVtZW50ID0gcmV0dXJuT3B0cy5lbGVtZW50LmNhbGwoc3RlcCk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcocmV0dXJuT3B0cy5lbGVtZW50KSkge1xuICAgIC8vIENhbid0IG92ZXJyaWRlIHRoZSBlbGVtZW50IGluIHVzZXIgb3B0cyByZWZlcmVuY2UgYmVjYXVzZSB3ZSBjYW4ndFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBlbGVtZW50IHdpbGwgZXhpc3QgaW4gdGhlIGZ1dHVyZS5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuT3B0cy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyZXR1cm5PcHRzLmVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgaWYgKCFyZXR1cm5PcHRzLmVsZW1lbnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBUaGUgZWxlbWVudCBmb3IgdGhpcyBTaGVwaGVyZCBzdGVwIHdhcyBub3QgZm91bmQgJHtvcHRpb25zLmVsZW1lbnR9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuT3B0cztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN0ZXAgc2hvdWxkIGJlIGNlbnRlcmVkIG9yIG5vdC4gRG9lcyBub3QgdHJpZ2dlciBhdHRhY2hUby5lbGVtZW50IGV2YWx1YXRpb24sIG1ha2luZyBpdCBhIHB1cmVcbiAqIGFsdGVybmF0aXZlIGZvciB0aGUgZGVwcmVjYXRlZCBzdGVwLmlzQ2VudGVyZWQoKSBtZXRob2QuXG4gKiBAcGFyYW0gcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQ2VudGVyU3RlcChyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucykge1xuICBpZiAocmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCByZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgXG4gIHJldHVybiAhcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMuZWxlbWVudCB8fCAhcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMub247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBvcHRpb25zIGZvciB0aGUgdG9vbHRpcCBhbmQgaW5pdGlhbGl6ZXNcbiAqIGBzdGVwLnRvb2x0aXBgIGFzIGEgUG9wcGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFRvb2x0aXAoc3RlcCkge1xuICBpZiAoc3RlcC50b29sdGlwKSB7XG4gICAgc3RlcC50b29sdGlwLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGNvbnN0IGF0dGFjaFRvT3B0aW9ucyA9IHN0ZXAuX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zKCk7XG5cbiAgbGV0IHRhcmdldCA9IGF0dGFjaFRvT3B0aW9ucy5lbGVtZW50O1xuICBjb25zdCBwb3BwZXJPcHRpb25zID0gZ2V0UG9wcGVyT3B0aW9ucyhhdHRhY2hUb09wdGlvbnMsIHN0ZXApO1xuXG4gIGlmIChzaG91bGRDZW50ZXJTdGVwKGF0dGFjaFRvT3B0aW9ucykpIHtcbiAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdGVwLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC1jZW50ZXJlZCcpO1xuICB9XG5cbiAgc3RlcC50b29sdGlwID0gY3JlYXRlUG9wcGVyKHRhcmdldCwgc3RlcC5lbCwgcG9wcGVyT3B0aW9ucyk7XG4gIHN0ZXAudGFyZ2V0ID0gYXR0YWNoVG9PcHRpb25zLmVsZW1lbnQ7XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdW5pcXVlIGlkIGZvciBzdGVwcywgdG91cnMsIG1vZGFscywgZXRjXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICBsZXQgZCA9IERhdGUubm93KCk7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGBQb3BwZXJgIG9wdGlvbnMgZnJvbSBhIHNldCBvZiBiYXNlIGBhdHRhY2hUb2Agb3B0aW9uc1xuICogQHBhcmFtIGF0dGFjaFRvT3B0aW9uc1xuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9wcGVyT3B0aW9ucyhhdHRhY2hUb09wdGlvbnMsIHN0ZXApIHtcbiAgbGV0IHBvcHBlck9wdGlvbnMgPSB7XG4gICAgbW9kaWZpZXJzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYWx0QXhpczogdHJ1ZSxcbiAgICAgICAgICB0ZXRoZXI6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllcihzdGVwKVxuICAgIF0sXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbiAgfTtcblxuICBpZiAoc2hvdWxkQ2VudGVyU3RlcChhdHRhY2hUb09wdGlvbnMpKSB7XG4gICAgcG9wcGVyT3B0aW9ucyA9IG1ha2VDZW50ZXJlZFBvcHBlcihzdGVwKTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPcHRpb25zLnBsYWNlbWVudCA9IGF0dGFjaFRvT3B0aW9ucy5vbjtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9ucyA9XG4gICAgc3RlcC50b3VyICYmIHN0ZXAudG91ci5vcHRpb25zICYmIHN0ZXAudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcblxuICBpZiAoZGVmYXVsdFN0ZXBPcHRpb25zKSB7XG4gICAgcG9wcGVyT3B0aW9ucyA9IF9tZXJnZU1vZGlmaWVycyhkZWZhdWx0U3RlcE9wdGlvbnMsIHBvcHBlck9wdGlvbnMpO1xuICB9XG5cbiAgcG9wcGVyT3B0aW9ucyA9IF9tZXJnZU1vZGlmaWVycyhzdGVwLm9wdGlvbnMsIHBvcHBlck9wdGlvbnMpO1xuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBfbWVyZ2VNb2RpZmllcnMoc3RlcE9wdGlvbnMsIHBvcHBlck9wdGlvbnMpIHtcbiAgaWYgKHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMpIHtcbiAgICBsZXQgbWVyZ2VkUG9wcGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHBvcHBlck9wdGlvbnMsXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgIHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzICYmXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLm1hcCgobW9kKSA9PiBtb2QubmFtZSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZE1vZGlmaWVycyA9IHBvcHBlck9wdGlvbnMubW9kaWZpZXJzLmZpbHRlcihcbiAgICAgICAgKG1vZCkgPT4gIW5hbWVzLmluY2x1ZGVzKG1vZC5uYW1lKVxuICAgICAgKTtcblxuICAgICAgbWVyZ2VkUG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgPSBBcnJheS5mcm9tKFxuICAgICAgICBuZXcgU2V0KFsuLi5maWx0ZXJlZE1vZGlmaWVycywgLi4uc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnNdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkUG9wcGVyT3B0aW9ucztcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuIiwiZnVuY3Rpb24gbm9vcCgpIHsgfVxuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yIChjb25zdCBrIGluIHNyYylcbiAgICAgICAgdGFyW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiB0YXI7XG59XG5mdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuICAgIGlmIChpc19oeWRyYXRpbmcpIHtcbiAgICAgICAgaW5pdF9oeWRyYXRlKHRhcmdldCk7XG4gICAgICAgIGlmICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCkgfHwgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudEVsZW1lbnQgIT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG4gICAgICAgIHdoaWxlICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG4gICAgICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zW2ldKVxuICAgICAgICAgICAgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5mdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzX3Byb3Aob2JqLCBrKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFyZ2V0W2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHRleHQoZGF0YSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cbmZ1bmN0aW9uIHNwYWNlKCkge1xuICAgIHJldHVybiB0ZXh0KCcgJyk7XG59XG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGV4dCgnJyk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCkge1xuICAgICAgICAgICAgbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAocHJvcCBpbiBub2RlKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG4gICAgaWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzTm9kZSwgY3JlYXRlTm9kZSwgZG9udFVwZGF0ZUxhc3RJbmRleCA9IGZhbHNlKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IHJlc3VsdE5vZGUgPSAoKCkgPT4ge1xuICAgICAgICAvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZSgpO1xuICAgIH0pKCk7XG4gICAgcmVzdWx0Tm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICByZXR1cm4gcmVzdWx0Tm9kZTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmUuZm9yRWFjaCh2ID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKSk7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSAnJyArIGRhdGE7XG4gICAgICAgIGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhU3RyKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB0ZXh0KGRhdGEpLCB0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuICAgICk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gZmluZF9jb21tZW50KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuICAgIC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuICAgIGNvbnN0IHN0YXJ0X2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcbiAgICBjb25zdCBlbmRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCk7XG4gICAgaWYgKHN0YXJ0X2luZGV4ID09PSBlbmRfaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKHVuZGVmaW5lZCwgaXNfc3ZnKTtcbiAgICB9XG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG4gICAgY29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oY2xhaW1lZF9ub2RlcywgaXNfc3ZnKTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCAhPT0gZGF0YSlcbiAgICAgICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuICAgIGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpIHx8IHNlbGVjdC5vcHRpb25zWzBdO1xuICAgIHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5mdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG4gICAgcmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCBvcHRpb24gPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5sZXQgY3Jvc3NvcmlnaW47XG5mdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcbiAgICBpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjcm9zc29yaWdpbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjcm9zc29yaWdpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuZnVuY3Rpb24gYWRkX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5jbGFzcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGlzX3N2ZztcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICB9XG4gICAgbShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX3N2ZylcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBzdmdfZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuYyhodG1sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gICAgaChodG1sKSB7XG4gICAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKGlzX3N2Zyk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBmb3IgbXVsdGlwbGUgZG9jdW1lbnRzIGJlY2F1c2UgYSBTdmVsdGUgYXBwbGljYXRpb24gY291bGQgYWxzbyBjb250YWluIGlmcmFtZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzM2MjRcbmNvbnN0IG1hbmFnZWRfc3R5bGVzID0gbmV3IE1hcCgpO1xubGV0IGFjdGl2ZSA9IDA7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSkge1xuICAgIGNvbnN0IGluZm8gPSB7IHN0eWxlc2hlZXQ6IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLCBydWxlczoge30gfTtcbiAgICBtYW5hZ2VkX3N0eWxlcy5zZXQoZG9jLCBpbmZvKTtcbiAgICByZXR1cm4gaW5mbztcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHsgc3R5bGVzaGVldCwgcnVsZXMgfSA9IG1hbmFnZWRfc3R5bGVzLmdldChkb2MpIHx8IGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpO1xuICAgIGlmICghcnVsZXNbbmFtZV0pIHtcbiAgICAgICAgcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoYEBrZXlmcmFtZXMgJHtuYW1lfSAke3J1bGV9YCwgc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGAke2FuaW1hdGlvbiA/IGAke2FuaW1hdGlvbn0sIGAgOiAnJ30ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcbiAgICBhY3RpdmUgKz0gMTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IChub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihuYW1lXG4gICAgICAgID8gYW5pbSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cbiAgICAgICAgOiBhbmltID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICAgICk7XG4gICAgY29uc3QgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbmV4dC5qb2luKCcsICcpO1xuICAgICAgICBhY3RpdmUgLT0gZGVsZXRlZDtcbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjbGVhcl9ydWxlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHN0eWxlc2hlZXQgfSA9IGluZm87XG4gICAgICAgICAgICBsZXQgaSA9IHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LmRlbGV0ZVJ1bGUoaSk7XG4gICAgICAgICAgICBpbmZvLnJ1bGVzID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5jbGVhcigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZyb20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmIGZyb20ucmlnaHQgPT09IHRvLnJpZ2h0ICYmIGZyb20udG9wID09PSB0by50b3AgJiYgZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cbiAgICBzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzpcbiAgICBlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sIHRpY2sgPSBub29wLCBjc3MgfSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbmFtZTtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBuYW1lKTtcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgIGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQgJiYgbm93ID49IGVuZCkge1xuICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG4gICAgICAgICAgICBjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHN0YXJ0KCk7XG4gICAgdGljaygwLCAxKTtcbiAgICByZXR1cm4gc3RvcDtcbn1cbmZ1bmN0aW9uIGZpeF9wb3NpdGlvbihub2RlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuICAgIH1cbn1cblxubGV0IGN1cnJlbnRfY29tcG9uZW50O1xuZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuICAgIGlmICghY3VycmVudF9jb21wb25lbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5mdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG4gICAgfVxufVxuXG5jb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5jb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5jb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICAgIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrKCkge1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgIHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgY29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICB3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG4gICAgICAgICAgICBmbHVzaGlkeCsrO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoY29tcG9uZW50LiQkKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH1cbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAkJC51cGRhdGUoKTtcbiAgICAgICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAgICAgY29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcbiAgICAgICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICAgICAkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG59XG5cbmxldCBwcm9taXNlO1xuZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xubGV0IG91dHJvcztcbmZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcbiAgICBvdXRyb3MgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgIGM6IFtdLFxuICAgICAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcbiAgICBpZiAoIW91dHJvcy5yKSB7XG4gICAgICAgIHJ1bl9hbGwob3V0cm9zLmMpO1xuICAgIH1cbiAgICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgYmxvY2suaShsb2NhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICAgICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgICAgIG91dHJvcy5jLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmQoMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2NrLm8obG9jYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbmZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRhc2spXG4gICAgICAgICAgICB0YXNrLmFib3J0KCk7XG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcbiAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuICAgIGdyb3VwLnIgKz0gMTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWdyb3VwLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwoZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSAtIHQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZChyZXNldCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRpY2soMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuICAgIGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZCA9IChwcm9ncmFtLmIgLSB0KTtcbiAgICAgICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiB0LFxuICAgICAgICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgICAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgICAgICAgYlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcbiAgICAgICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBydW5uaW5nX3Byb2dyYW0uYiwgcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLCAwLCBlYXNpbmcsIGNvbmZpZy5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQgPSBydW5uaW5nX3Byb2dyYW0uYiwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRybyDigJQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRybyDigJQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBydW4oYikge1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcbiAgICBjb25zdCB0b2tlbiA9IGluZm8udG9rZW4gPSB7fTtcbiAgICBmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZm8udG9rZW4gIT09IHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbmZvLnJlc29sdmVkID0gdmFsdWU7XG4gICAgICAgIGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ibG9ja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICAgICAgYmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcbiAgICAgICAgICAgIG5lZWRzX2ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrcylcbiAgICAgICAgICAgIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICBpZiAobmVlZHNfZmx1c2gpIHtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHByb21pc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaChpbmZvLCBjdHgsIGRpcnR5KSB7XG4gICAgY29uc3QgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8uY2F0Y2gpIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8uZXJyb3JdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZCgxKTtcbiAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5mdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gICAgbGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcbiAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpID0gbztcbiAgICBjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gICAgY29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2xvb2t1cC5zZXQoa2V5LCBuZXdfYmxvY2tzW2ldID0gYmxvY2spO1xuICAgICAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKVxuICAgICAgICAgICAgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgIGJsb2NrLm0obm9kZSwgbmV4dCk7XG4gICAgICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgICAgIG5leHQgPSBibG9jay5maXJzdDtcbiAgICAgICAgbi0tO1xuICAgIH1cbiAgICB3aGlsZSAobyAmJiBuKSB7XG4gICAgICAgIGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG4gICAgICAgIGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuICAgICAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGJsb2NrXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuICAgICAgICAgICAgZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcbiAgICAgICAgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSlcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgIH1cbiAgICB3aGlsZSAobilcbiAgICAgICAgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG5jb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnYWxsb3dmdWxsc2NyZWVuJyxcbiAgICAnYWxsb3dwYXltZW50cmVxdWVzdCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXV0b2ZvY3VzJyxcbiAgICAnYXV0b3BsYXknLFxuICAgICdjaGVja2VkJyxcbiAgICAnY29udHJvbHMnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVmZXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2Zvcm1ub3ZhbGlkYXRlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaXNtYXAnLFxuICAgICdsb29wJyxcbiAgICAnbXVsdGlwbGUnLFxuICAgICdtdXRlZCcsXG4gICAgJ25vbW9kdWxlJyxcbiAgICAnbm92YWxpZGF0ZScsXG4gICAgJ29wZW4nLFxuICAgICdwbGF5c2lubGluZScsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXSk7XG5cbmNvbnN0IHZvaWRfZWxlbWVudF9uYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC87XG5mdW5jdGlvbiBpc192b2lkKG5hbWUpIHtcbiAgICByZXR1cm4gdm9pZF9lbGVtZW50X25hbWVzLnRlc3QobmFtZSkgfHwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnIWRvY3R5cGUnO1xufVxuXG5jb25zdCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciA9IC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmZ1bmN0aW9uIHNwcmVhZChhcmdzLCBhdHRyc190b19hZGQpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uYXJncyk7XG4gICAgaWYgKGF0dHJzX3RvX2FkZCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5jbGFzc2VzO1xuICAgICAgICBjb25zdCBzdHlsZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLnN0eWxlcztcbiAgICAgICAgaWYgKGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuc3R5bGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlc190b19hZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcobWVyZ2Vfc3NyX3N0eWxlcyhhdHRyaWJ1dGVzLnN0eWxlLCBzdHlsZXNfdG9fYWRkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICBlbHNlIGlmIChib29sZWFuX2F0dHJpYnV0ZXMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke25hbWV9PVwiJHt2YWx1ZX1cImA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gbWVyZ2Vfc3NyX3N0eWxlcyhzdHlsZV9hdHRyaWJ1dGUsIHN0eWxlX2RpcmVjdGl2ZSkge1xuICAgIGNvbnN0IHN0eWxlX29iamVjdCA9IHt9O1xuICAgIGZvciAoY29uc3QgaW5kaXZpZHVhbF9zdHlsZSBvZiBzdHlsZV9hdHRyaWJ1dGUuc3BsaXQoJzsnKSkge1xuICAgICAgICBjb25zdCBjb2xvbl9pbmRleCA9IGluZGl2aWR1YWxfc3R5bGUuaW5kZXhPZignOicpO1xuICAgICAgICBjb25zdCBuYW1lID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZSgwLCBjb2xvbl9pbmRleCkudHJpbSgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoY29sb25faW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlX2RpcmVjdGl2ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlX2RpcmVjdGl2ZVtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZV9vYmplY3RbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlX29iamVjdDtcbn1cbmNvbnN0IEFUVFJfUkVHRVggPSAvWyZcIl0vZztcbmNvbnN0IENPTlRFTlRfUkVHRVggPSAvWyY8XS9nO1xuLyoqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwZXJmb3JtYW5jZSBzZW5zaXRpdmUgYW5kIGhhcyBiZWVuIG9wdGltaXplZFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzU3MDFcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHZhbHVlLCBpc19hdHRyID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBpc19hdHRyID8gQVRUUl9SRUdFWCA6IENPTlRFTlRfUkVHRVg7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIGxldCBlc2NhcGVkID0gJyc7XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuICAgICAgICBjb25zdCBpID0gcGF0dGVybi5sYXN0SW5kZXggLSAxO1xuICAgICAgICBjb25zdCBjaCA9IHN0cltpXTtcbiAgICAgICAgZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogKGNoID09PSAnXCInID8gJyZxdW90OycgOiAnJmx0OycpKTtcbiAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gZXNjYXBlZCArIHN0ci5zdWJzdHJpbmcobGFzdCk7XG59XG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHZhbHVlKSB7XG4gICAgLy8ga2VlcCBib29sZWFucywgbnVsbCwgYW5kIHVuZGVmaW5lZCBmb3IgdGhlIHNha2Ugb2YgYHNwcmVhZGBcbiAgICBjb25zdCBzaG91bGRfZXNjYXBlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNob3VsZF9lc2NhcGUgPyBlc2NhcGUodmFsdWUsIHRydWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZWFjaChpdGVtcywgZm4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG4gICAgJCRyZW5kZXI6ICgpID0+ICcnXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQuJCRyZW5kZXIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JylcbiAgICAgICAgICAgIG5hbWUgKz0gJyB0aGlzPXsuLi59JztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlc2ApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcbiAgICBjb25zb2xlLmxvZyhge0BkZWJ1Z30gJHtmaWxlID8gZmlsZSArICcgJyA6ICcnfSgke2xpbmV9OiR7Y29sdW1ufSlgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuICcnO1xufVxubGV0IG9uX2Rlc3Ryb3k7XG5mdW5jdGlvbiBjcmVhdGVfc3NyX2NvbXBvbmVudChmbikge1xuICAgIGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0ICQkID0ge1xuICAgICAgICAgICAgb25fZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBhc3NpZ25tZW50ID0gKGJvb2xlYW4gJiYgdmFsdWUgPT09IHRydWUpID8gJycgOiBgPVwiJHtlc2NhcGUodmFsdWUsIHRydWUpfVwiYDtcbiAgICByZXR1cm4gYCAke25hbWV9JHthc3NpZ25tZW50fWA7XG59XG5mdW5jdGlvbiBhZGRfY2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMgPyBgIGNsYXNzPVwiJHtjbGFzc2VzfVwiYCA6ICcnO1xufVxuZnVuY3Rpb24gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuICAgICAgICAuZmlsdGVyKGtleSA9PiBzdHlsZV9vYmplY3Rba2V5XSlcbiAgICAgICAgLm1hcChrZXkgPT4gYCR7a2V5fTogJHtzdHlsZV9vYmplY3Rba2V5XX07YClcbiAgICAgICAgLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGFkZF9zdHlsZXMoc3R5bGVfb2JqZWN0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpO1xuICAgIHJldHVybiBzdHlsZXMgPyBgIHN0eWxlPVwiJHtzdHlsZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogbnVsbCxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjQ5LjAnIH0sIGRldGFpbCksIHsgYnViYmxlczogdHJ1ZSB9KSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmUnLCB7IG5vZGUgfSk7XG4gICAgZGV0YWNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG4gICAgd2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5fZGV2KG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zLCBoYXNfcHJldmVudF9kZWZhdWx0LCBoYXNfc3RvcF9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuICAgIGlmIChoYXNfcHJldmVudF9kZWZhdWx0KVxuICAgICAgICBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcbiAgICBpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgY29uc3QgZGlzcG9zZSA9IGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlIH0pO1xuICAgIGVsc2VcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBwcm9wX2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGFzZXQnLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmICEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd7I2VhY2h9IG9ubHkgaXRlcmF0ZXMgb3ZlciBhcnJheS1saWtlIG9iamVjdHMuJztcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpIHtcbiAgICAgICAgICAgIG1zZyArPSAnIFlvdSBjYW4gdXNlIGEgc3ByZWFkIHRvIGNvbnZlcnQgdGhpcyBpdGVyYWJsZSBpbnRvIGFuIGFycmF5Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuICAgIGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcbiAgICAgICAgaWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcbiAgICBpZiAodGFnICYmICFpc19zdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8c3ZlbHRlOmVsZW1lbnQ+IGV4cGVjdHMgXCJ0aGlzXCIgYXR0cmlidXRlIHRvIGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqIFRoaXMgb25seSBleGlzdHMgZm9yIHR5cGluZyBwdXJwb3NlcyBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gYC5kLnRzYCBmaWxlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50VHlwZWQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnRUeXBlZDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKlxuICogIyMjIyBXaHkgbm90IG1ha2UgdGhpcyBwYXJ0IG9mIGBTdmVsdGVDb21wb25lbnQoRGV2KWA/XG4gKiBCZWNhdXNlXG4gKiBgYGB0c1xuICogY2xhc3MgQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGNvbnN0IGNvbXBvbmVudDogdHlwZW9mIFN2ZWx0ZUNvbXBvbmVudCA9IEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50O1xuICogYGBgXG4gKiB3aWxsIHRocm93IGEgdHlwZSBlcnJvciwgc28gd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgbW9yZSBzdHJpY3RseSB0eXBlZCBjbGFzcy5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIEh0bWxUYWdIeWRyYXRpb24sIFN2ZWx0ZUNvbXBvbmVudCwgU3ZlbHRlQ29tcG9uZW50RGV2LCBTdmVsdGVDb21wb25lbnRUeXBlZCwgU3ZlbHRlRWxlbWVudCwgYWN0aW9uX2Rlc3Ryb3llciwgYWRkX2F0dHJpYnV0ZSwgYWRkX2NsYXNzZXMsIGFkZF9mbHVzaF9jYWxsYmFjaywgYWRkX2xvY2F0aW9uLCBhZGRfcmVuZGVyX2NhbGxiYWNrLCBhZGRfcmVzaXplX2xpc3RlbmVyLCBhZGRfc3R5bGVzLCBhZGRfdHJhbnNmb3JtLCBhZnRlclVwZGF0ZSwgYXBwZW5kLCBhcHBlbmRfZGV2LCBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldCwgYXBwZW5kX2h5ZHJhdGlvbiwgYXBwZW5kX2h5ZHJhdGlvbl9kZXYsIGFwcGVuZF9zdHlsZXMsIGFzc2lnbiwgYXR0ciwgYXR0cl9kZXYsIGF0dHJpYnV0ZV90b19vYmplY3QsIGJlZm9yZVVwZGF0ZSwgYmluZCwgYmluZGluZ19jYWxsYmFja3MsIGJsYW5rX29iamVjdCwgYnViYmxlLCBjaGVja19vdXRyb3MsIGNoaWxkcmVuLCBjbGFpbV9jb21wb25lbnQsIGNsYWltX2VsZW1lbnQsIGNsYWltX2h0bWxfdGFnLCBjbGFpbV9zcGFjZSwgY2xhaW1fc3ZnX2VsZW1lbnQsIGNsYWltX3RleHQsIGNsZWFyX2xvb3BzLCBjb21wb25lbnRfc3Vic2NyaWJlLCBjb21wdXRlX3Jlc3RfcHJvcHMsIGNvbXB1dGVfc2xvdHMsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgY3JlYXRlX2FuaW1hdGlvbiwgY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiwgY3JlYXRlX2NvbXBvbmVudCwgY3JlYXRlX2luX3RyYW5zaXRpb24sIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbiwgY3JlYXRlX3Nsb3QsIGNyZWF0ZV9zc3JfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCwgY3VzdG9tX2V2ZW50LCBkYXRhc2V0X2RldiwgZGVidWcsIGRlc3Ryb3lfYmxvY2ssIGRlc3Ryb3lfY29tcG9uZW50LCBkZXN0cm95X2VhY2gsIGRldGFjaCwgZGV0YWNoX2FmdGVyX2RldiwgZGV0YWNoX2JlZm9yZV9kZXYsIGRldGFjaF9iZXR3ZWVuX2RldiwgZGV0YWNoX2RldiwgZGlydHlfY29tcG9uZW50cywgZGlzcGF0Y2hfZGV2LCBlYWNoLCBlbGVtZW50LCBlbGVtZW50X2lzLCBlbXB0eSwgZW5kX2h5ZHJhdGluZywgZXNjYXBlLCBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlLCBlc2NhcGVfb2JqZWN0LCBleGNsdWRlX2ludGVybmFsX3Byb3BzLCBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9wb3NpdGlvbiwgZmx1c2gsIGdldEFsbENvbnRleHRzLCBnZXRDb250ZXh0LCBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUsIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlLCBnZXRfY3VycmVudF9jb21wb25lbnQsIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsIGdldF9yb290X2Zvcl9zdHlsZSwgZ2V0X3Nsb3RfY2hhbmdlcywgZ2V0X3NwcmVhZF9vYmplY3QsIGdldF9zcHJlYWRfdXBkYXRlLCBnZXRfc3RvcmVfdmFsdWUsIGdsb2JhbHMsIGdyb3VwX291dHJvcywgaGFuZGxlX3Byb21pc2UsIGhhc0NvbnRleHQsIGhhc19wcm9wLCBpZGVudGl0eSwgaW5pdCwgaW5zZXJ0LCBpbnNlcnRfZGV2LCBpbnNlcnRfaHlkcmF0aW9uLCBpbnNlcnRfaHlkcmF0aW9uX2RldiwgaW50cm9zLCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciwgaXNfY2xpZW50LCBpc19jcm9zc29yaWdpbiwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBpc192b2lkLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1lcmdlX3Nzcl9zdHlsZXMsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfZGF0YSwgc2V0X2RhdGFfZGV2LCBzZXRfaW5wdXRfdHlwZSwgc2V0X2lucHV0X3ZhbHVlLCBzZXRfbm93LCBzZXRfcmFmLCBzZXRfc3RvcmVfdmFsdWUsIHNldF9zdHlsZSwgc2V0X3N2Z19hdHRyaWJ1dGVzLCBzcGFjZSwgc3ByZWFkLCBzcmNfdXJsX2VxdWFsLCBzdGFydF9oeWRyYXRpbmcsIHN0b3BfcHJvcGFnYXRpb24sIHN1YnNjcmliZSwgc3ZnX2VsZW1lbnQsIHRleHQsIHRpY2ssIHRpbWVfcmFuZ2VzX3RvX2FycmF5LCB0b19udW1iZXIsIHRvZ2dsZV9jbGFzcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQsIHRydXN0ZWQsIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2gsIHVwZGF0ZV9rZXllZF9lYWNoLCB1cGRhdGVfc2xvdCwgdXBkYXRlX3Nsb3RfYmFzZSwgdmFsaWRhdGVfY29tcG9uZW50LCB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCwgeGxpbmtfYXR0ciB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuXG4gIGV4cG9ydCBsZXQgY29uZmlnLCBzdGVwO1xuICBsZXQgYWN0aW9uLCBjbGFzc2VzLCBkaXNhYmxlZCwgbGFiZWwsIHNlY29uZGFyeSwgdGV4dDtcblxuICAkOiB7XG4gICAgYWN0aW9uID0gY29uZmlnLmFjdGlvbiA/IGNvbmZpZy5hY3Rpb24uYmluZChzdGVwLnRvdXIpIDogbnVsbDtcbiAgICBjbGFzc2VzID0gY29uZmlnLmNsYXNzZXM7XG4gICAgZGlzYWJsZWQgPSBjb25maWcuZGlzYWJsZWQgPyBnZXRDb25maWdPcHRpb24oY29uZmlnLmRpc2FibGVkKSA6IGZhbHNlO1xuICAgIGxhYmVsID0gY29uZmlnLmxhYmVsID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy5sYWJlbCkgOiBudWxsO1xuICAgIHNlY29uZGFyeSA9IGNvbmZpZy5zZWNvbmRhcnk7XG4gICAgdGV4dCA9IGNvbmZpZy50ZXh0ID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy50ZXh0KSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb25maWdPcHRpb24ob3B0aW9uKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9uKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbiA9IG9wdGlvbi5jYWxsKHN0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoNTAsIDEzNiwgMjMwKTtcbiAgICBib3JkZXI6IDA7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbiAgICBwYWRkaW5nOiAwLjVyZW0gMS41cmVtO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjUsIDExMSwgMjA0KTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b24uc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeSB7XG4gICAgYmFja2dyb3VuZDogcmdiKDI0MSwgMjQyLCAyNDMpO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbi5zaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5Om5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjE0LCAyMTcsIDIxOSk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uOmRpc2FibGVkIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG48L3N0eWxlPlxuXG48YnV0dG9uXG4gIGFyaWEtbGFiZWw9XCJ7bGFiZWwgPyBsYWJlbCA6IG51bGx9XCJcbiAgY2xhc3M9XCJ7YCR7KGNsYXNzZXMgfHwgJycpfSBzaGVwaGVyZC1idXR0b24gJHsoc2Vjb25kYXJ5ID8gJ3NoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnknIDogJycpfWB9XCJcbiAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICBvbjpjbGljaz17YWN0aW9ufVxuICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIHtAaHRtbCB0ZXh0fVxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRCdXR0b24gZnJvbSAnLi9zaGVwaGVyZC1idXR0b24uc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IHN0ZXA7XG5cbiAgJDogYnV0dG9ucyA9IHN0ZXAub3B0aW9ucy5idXR0b25zO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1mb290ZXIge1xuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDVweDtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBwYWRkaW5nOiAwIDAuNzVyZW0gMC43NXJlbTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1mb290ZXIgLnNoZXBoZXJkLWJ1dHRvbjpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxmb290ZXIgY2xhc3M9XCJzaGVwaGVyZC1mb290ZXJcIj5cbiAgICB7I2lmIGJ1dHRvbnN9XG4gICAgICAgIHsjZWFjaCBidXR0b25zIGFzIGNvbmZpZ31cbiAgICAgICAgICA8U2hlcGhlcmRCdXR0b25cbiAgICAgICAgICAgIHtjb25maWd9XG4gICAgICAgICAgICB7c3RlcH1cbiAgICAgICAgICAvPlxuICAgICAgICB7L2VhY2h9XG4gICAgey9pZn1cbjwvZm9vdGVyPlxuIiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBjYW5jZWxJY29uLCBzdGVwO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjbGljayBsaXN0ZW5lciB0byB0aGUgY2FuY2VsIGxpbmsgdGhhdCBjYW5jZWxzIHRoZSB0b3VyXG4gICAqL1xuICBjb25zdCBoYW5kbGVDYW5jZWxDbGljayA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN0ZXAuY2FuY2VsKCk7XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWNhbmNlbC1pY29uIHtcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC43NSk7XG4gICAgZm9udC1zaXplOiAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgdHJhbnNpdGlvbjogY29sb3IgMC41cyBlYXNlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWNhbmNlbC1pY29uOmhvdmVyIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWNhbmNlbC1pY29uIHtcbiAgICBjb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWNhbmNlbC1pY29uOmhvdmVyIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuPC9zdHlsZT5cblxuPGJ1dHRvblxuICBhcmlhLWxhYmVsPVwie2NhbmNlbEljb24ubGFiZWwgPyBjYW5jZWxJY29uLmxhYmVsIDogJ0Nsb3NlIFRvdXInfVwiXG4gIGNsYXNzPVwic2hlcGhlcmQtY2FuY2VsLWljb25cIlxuICBvbjpjbGljaz17aGFuZGxlQ2FuY2VsQ2xpY2t9XG4gIHR5cGU9XCJidXR0b25cIlxuPlxuICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcbiAgXG4gIGV4cG9ydCBsZXQgbGFiZWxJZCwgZWxlbWVudCwgdGl0bGU7XG4gIFxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGl0bGUpKSB7XG4gICAgICB0aXRsZSA9IHRpdGxlKCk7XG4gICAgfVxuICAgIFxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGl0bGU7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC10aXRsZSB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBmbGV4OiAxIDAgYXV0bztcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGgzXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgaWQ9XCJ7bGFiZWxJZH1cIlxuICBjbGFzcz1cInNoZXBoZXJkLXRpdGxlXCJcbj5cbjwvaDM+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRDYW5jZWxJY29uIGZyb20gJy4vc2hlcGhlcmQtY2FuY2VsLWljb24uc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkVGl0bGUgZnJvbSAnLi9zaGVwaGVyZC10aXRsZS5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgbGFiZWxJZCwgc3RlcDtcbiAgbGV0IHRpdGxlLCBjYW5jZWxJY29uO1xuXG4gICQ6IHtcbiAgICAgIHRpdGxlID0gc3RlcC5vcHRpb25zLnRpdGxlO1xuICAgICAgY2FuY2VsSWNvbiA9IHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWhlYWRlciB7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgbGluZS1oZWlnaHQ6IDJlbTtcbiAgICBwYWRkaW5nOiAwLjc1cmVtIDAuNzVyZW0gMDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWhlYWRlciB7XG4gICAgYmFja2dyb3VuZDogI2U2ZTZlNjtcbiAgICBwYWRkaW5nOiAxZW07XG4gIH1cbjwvc3R5bGU+XG5cbjxoZWFkZXIgY2xhc3M9XCJzaGVwaGVyZC1oZWFkZXJcIj5cbiAgICB7I2lmIHRpdGxlfVxuICAgICAgPFNoZXBoZXJkVGl0bGVcbiAgICAgICAge2xhYmVsSWR9XG4gICAgICAgIHt0aXRsZX1cbiAgICAgIC8+XG4gICAgey9pZn1cblxuICAgIHsjaWYgY2FuY2VsSWNvbiAmJiBjYW5jZWxJY29uLmVuYWJsZWR9XG4gICAgICA8U2hlcGhlcmRDYW5jZWxJY29uXG4gICAgICAgIHtjYW5jZWxJY29ufVxuICAgICAgICB7c3RlcH1cbiAgICAgIC8+XG4gICAgey9pZn1cbjwvaGVhZGVyPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbiAgZXhwb3J0IGxldCBkZXNjcmlwdGlvbklkLCBlbGVtZW50LCBzdGVwO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBsZXQgeyB0ZXh0IH0gPSBzdGVwLm9wdGlvbnM7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0ZXh0KSkge1xuICAgICAgdGV4dCA9IHRleHQuY2FsbChzdGVwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0ZXh0KSkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLXRleHQge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBsaW5lLWhlaWdodDogMS4zZW07XG4gICAgcGFkZGluZzogMC43NWVtO1xuICB9XG5cbiAgLnNoZXBoZXJkLXRleHQgcCB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgfVxuXG4gIC5zaGVwaGVyZC10ZXh0IHA6bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzPVwic2hlcGhlcmQtdGV4dFwiXG4gIGlkPVwie2Rlc2NyaXB0aW9uSWR9XCJcbj5cbjwvZGl2PlxuXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRGb290ZXIgZnJvbSAnLi9zaGVwaGVyZC1mb290ZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkSGVhZGVyIGZyb20gJy4vc2hlcGhlcmQtaGVhZGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZFRleHQgZnJvbSAnLi9zaGVwaGVyZC10ZXh0LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5cbiAgZXhwb3J0IGxldCBkZXNjcmlwdGlvbklkLCBsYWJlbElkLCBzdGVwO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1jb250ZW50IHtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGNsYXNzPVwic2hlcGhlcmQtY29udGVudFwiXG4+XG4gIHsjaWYgIWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50aXRsZSkgfHwgKHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQpfVxuICAgIDxTaGVwaGVyZEhlYWRlclxuICAgICAge2xhYmVsSWR9XG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIHsjaWYgIWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50ZXh0KX1cbiAgICA8U2hlcGhlcmRUZXh0XG4gICAgICB7ZGVzY3JpcHRpb25JZH1cbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgeyNpZiBBcnJheS5pc0FycmF5KHN0ZXAub3B0aW9ucy5idXR0b25zKSAmJiBzdGVwLm9wdGlvbnMuYnV0dG9ucy5sZW5ndGh9XG4gICAgPFNoZXBoZXJkRm9vdGVyXG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50LCBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZENvbnRlbnQgZnJvbSAnLi9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuXG4gIGNvbnN0IEtFWV9UQUIgPSA5O1xuICBjb25zdCBLRVlfRVNDID0gMjc7XG4gIGNvbnN0IExFRlRfQVJST1cgPSAzNztcbiAgY29uc3QgUklHSFRfQVJST1cgPSAzOTtcblxuICBleHBvcnQgbGV0IGNsYXNzUHJlZml4LCBlbGVtZW50LCBkZXNjcmlwdGlvbklkLCBmaXJzdEZvY3VzYWJsZUVsZW1lbnQsXG4gICAgZm9jdXNhYmxlRWxlbWVudHMsIGxhYmVsSWQsIGxhc3RGb2N1c2FibGVFbGVtZW50LCBzdGVwLCBkYXRhU3RlcElkO1xuXG4gIGxldCBoYXNDYW5jZWxJY29uLCBoYXNUaXRsZSwgY2xhc3NlcztcblxuICAkOiB7XG4gICAgaGFzQ2FuY2VsSWNvbiA9IHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbiAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkO1xuICAgIGhhc1RpdGxlID0gc3RlcC5vcHRpb25zICYmIHN0ZXAub3B0aW9ucy50aXRsZTtcbiAgfVxuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICAvLyBHZXQgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGZvY3VzYWJsZVxuICAgIGRhdGFTdGVwSWQgPSB7IFtgZGF0YS0ke2NsYXNzUHJlZml4fXNoZXBoZXJkLXN0ZXAtaWRgXTogc3RlcC5pZCB9O1xuICAgIGZvY3VzYWJsZUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgW3RhYmluZGV4PVwiMFwiXScpO1xuICAgIGZpcnN0Rm9jdXNhYmxlRWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdO1xuICAgIGxhc3RGb2N1c2FibGVFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZihjbGFzc2VzICE9PSBzdGVwLm9wdGlvbnMuY2xhc3Nlcykge1xuICAgICAgdXBkYXRlRHluYW1pY0NsYXNzZXMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNDbGFzc2VzKCkge1xuICAgICAgcmVtb3ZlQ2xhc3NlcyhjbGFzc2VzKTtcbiAgICAgIGNsYXNzZXMgPSBzdGVwLm9wdGlvbnMuY2xhc3NlcztcbiAgICAgIGFkZENsYXNzZXMoY2xhc3Nlcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICBpZiAoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgICBpZiAob2xkQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzZXMoY2xhc3Nlcykge1xuICAgIGlmKGlzU3RyaW5nKGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBuZXdDbGFzc2VzID0gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgICAgaWYgKG5ld0NsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5uZXdDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcykge1xuICAgICByZXR1cm4gY2xhc3Nlcy5zcGxpdCgnICcpLmZpbHRlcihjbGFzc05hbWUgPT4gISFjbGFzc05hbWUubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBrZXlkb3duIGV2ZW50cyB0byBhbGxvdyBjbG9zaW5nIHRoZSBtb2RhbCB3aXRoIEVTQ1xuICAgKlxuICAgKiBCb3Jyb3dlZCBmcm9tIHRoaXMgZ3JlYXQgcG9zdCEgaHR0cHM6Ly9iaXRzb2Zjby5kZS9hY2Nlc3NpYmxlLW1vZGFsLWRpYWxvZy9cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgIGNvbnN0IHsgdG91ciB9ID0gc3RlcDtcbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSBLRVlfVEFCOlxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkIHRhYlxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmaXJzdEZvY3VzYWJsZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3NoZXBoZXJkLWVsZW1lbnQnKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGFzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RGb2N1c2FibGVFbGVtZW50KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBmaXJzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWV9FU0M6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMuZXhpdE9uRXNjKSB7XG4gICAgICAgICAgc3RlcC5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICB0b3VyLmJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgdG91ci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzLCB2aXNpYmlsaXR5IDAuM3M7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHotaW5kZXg6IDk5OTk7XG4gIH1cblxuICAuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC1lbGVtZW50IHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXTpub3QoLnNoZXBoZXJkLWNlbnRlcmVkKSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudCwgLnNoZXBoZXJkLWVsZW1lbnQgKixcbiAgLnNoZXBoZXJkLWVsZW1lbnQgKjphZnRlcixcbiAgLnNoZXBoZXJkLWVsZW1lbnQgKjpiZWZvcmUge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAuc2hlcGhlcmQtYXJyb3csXG4gIC5zaGVwaGVyZC1hcnJvdzo6YmVmb3JlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDE2cHg7XG4gICAgaGVpZ2h0OiAxNnB4O1xuICAgIHotaW5kZXg6IC0xO1xuICB9XG5cbiAgLnNoZXBoZXJkLWFycm93OmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuICAgIGJhY2tncm91bmQ6ICNmZmYgIDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J3RvcCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBib3R0b206IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdib3R0b20nXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgdG9wOiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nbGVmdCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICByaWdodDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J3JpZ2h0J10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIGxlZnQ6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudC5zaGVwaGVyZC1jZW50ZXJlZCA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuXG5cbiAgLyoqXG4gICogQXJyb3cgb24gdG9wIG9mIHRvb2x0aXAgY2VudGVyZWQgaG9yaXpvbnRhbGx5LCB3aXRoIHRpdGxlIGNvbG9yXG4gICovXG4gIC5zaGVwaGVyZC1lbGVtZW50LnNoZXBoZXJkLWhhcy10aXRsZVtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdib3R0b20nXSA+IC5zaGVwaGVyZC1hcnJvdzo6YmVmb3JlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xuICB9XG5cbiAgLnNoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLXRhcmdldCxcbiAgLnNoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLXRhcmdldCAqIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBhcmlhLWRlc2NyaWJlZGJ5PXshaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRleHQpID8gZGVzY3JpcHRpb25JZCA6IG51bGx9XG4gIGFyaWEtbGFiZWxsZWRieT17c3RlcC5vcHRpb25zLnRpdGxlID8gbGFiZWxJZCA6IG51bGx9XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M6c2hlcGhlcmQtaGFzLWNhbmNlbC1pY29uPVwie2hhc0NhbmNlbEljb259XCJcbiAgY2xhc3M6c2hlcGhlcmQtaGFzLXRpdGxlPVwie2hhc1RpdGxlfVwiXG4gIGNsYXNzOnNoZXBoZXJkLWVsZW1lbnQ9XCJ7dHJ1ZX1cIlxuICB7Li4uZGF0YVN0ZXBJZH1cbiAgb246a2V5ZG93bj17aGFuZGxlS2V5RG93bn1cbiAgcm9sZT1cImRpYWxvZ1wiXG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gICAgeyNpZiBzdGVwLm9wdGlvbnMuYXJyb3cgJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUby5lbGVtZW50ICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUby5vbn1cbiAgICAgIDxkaXYgY2xhc3M9XCJzaGVwaGVyZC1hcnJvd1wiIGRhdGEtcG9wcGVyLWFycm93PjwvZGl2PlxuICAgIHsvaWZ9XG4gIDxTaGVwaGVyZENvbnRlbnRcbiAgICB7ZGVzY3JpcHRpb25JZH1cbiAgICB7bGFiZWxJZH1cbiAgICB7c3RlcH1cbiAgLz5cbjwvZGl2PlxuIiwiLyogc21vb3Roc2Nyb2xsIHYwLjQuNCAtIDIwMTkgLSBEdXN0YW4gS2FzdGVuLCBKZXJlbWlhcyBNZW5pY2hlbGxpIC0gTUlUIExpY2Vuc2UgKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBwb2x5ZmlsbFxuICBmdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICAvLyBhbGlhc2VzXG4gICAgdmFyIHcgPSB3aW5kb3c7XG4gICAgdmFyIGQgPSBkb2N1bWVudDtcblxuICAgIC8vIHJldHVybiBpZiBzY3JvbGwgYmVoYXZpb3IgaXMgc3VwcG9ydGVkIGFuZCBwb2x5ZmlsbCBpcyBub3QgZm9yY2VkXG4gICAgaWYgKFxuICAgICAgJ3Njcm9sbEJlaGF2aW9yJyBpbiBkLmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJlxuICAgICAgdy5fX2ZvcmNlU21vb3RoU2Nyb2xsUG9seWZpbGxfXyAhPT0gdHJ1ZVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdsb2JhbHNcbiAgICB2YXIgRWxlbWVudCA9IHcuSFRNTEVsZW1lbnQgfHwgdy5FbGVtZW50O1xuICAgIHZhciBTQ1JPTExfVElNRSA9IDQ2ODtcblxuICAgIC8vIG9iamVjdCBnYXRoZXJpbmcgb3JpZ2luYWwgc2Nyb2xsIG1ldGhvZHNcbiAgICB2YXIgb3JpZ2luYWwgPSB7XG4gICAgICBzY3JvbGw6IHcuc2Nyb2xsIHx8IHcuc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxCeTogdy5zY3JvbGxCeSxcbiAgICAgIGVsZW1lbnRTY3JvbGw6IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCB8fCBzY3JvbGxFbGVtZW50LFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgfTtcblxuICAgIC8vIGRlZmluZSB0aW1pbmcgbWV0aG9kXG4gICAgdmFyIG5vdyA9XG4gICAgICB3LnBlcmZvcm1hbmNlICYmIHcucGVyZm9ybWFuY2Uubm93XG4gICAgICAgID8gdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3LnBlcmZvcm1hbmNlKVxuICAgICAgICA6IERhdGUubm93O1xuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBtYWRlIGJ5IE1pY3Jvc29mdFxuICAgICAqIEBtZXRob2QgaXNNaWNyb3NvZnRCcm93c2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJBZ2VudFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWljcm9zb2Z0QnJvd3Nlcih1c2VyQWdlbnQpIHtcbiAgICAgIHZhciB1c2VyQWdlbnRQYXR0ZXJucyA9IFsnTVNJRSAnLCAnVHJpZGVudC8nLCAnRWRnZS8nXTtcblxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodXNlckFnZW50UGF0dGVybnMuam9pbignfCcpKS50ZXN0KHVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJRSBoYXMgcm91bmRpbmcgYnVnIHJvdW5kaW5nIGRvd24gY2xpZW50SGVpZ2h0IGFuZCBjbGllbnRXaWR0aCBhbmRcbiAgICAgKiByb3VuZGluZyB1cCBzY3JvbGxIZWlnaHQgYW5kIHNjcm9sbFdpZHRoIGNhdXNpbmcgZmFsc2UgcG9zaXRpdmVzXG4gICAgICogb24gaGFzU2Nyb2xsYWJsZVNwYWNlXG4gICAgICovXG4gICAgdmFyIFJPVU5ESU5HX1RPTEVSQU5DRSA9IGlzTWljcm9zb2Z0QnJvd3Nlcih3Lm5hdmlnYXRvci51c2VyQWdlbnQpID8gMSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2Qgc2Nyb2xsRWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjcm9sbEVsZW1lbnQoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHJlc3VsdCBvZiBhcHBseWluZyBlYXNlIG1hdGggZnVuY3Rpb24gdG8gYSBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGVhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHNtb290aCBiZWhhdmlvciBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqIEBtZXRob2Qgc2hvdWxkQmFpbE91dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZmlyc3RBcmdcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG91bGRCYWlsT3V0KGZpcnN0QXJnKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGZpcnN0QXJnID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBmaXJzdEFyZyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ2F1dG8nIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnaW5zdGFudCdcbiAgICAgICkge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0L251bGxcbiAgICAgICAgLy8gb3IgYmVoYXZpb3IgaXMgYXV0bywgaW5zdGFudCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09ICdvYmplY3QnICYmIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QgYW5kIGJlaGF2aW9yIGlzIHNtb290aFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yIHdoZW4gYmVoYXZpb3IgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2JlaGF2aW9yIG1lbWJlciBvZiBTY3JvbGxPcHRpb25zICcgK1xuICAgICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yICtcbiAgICAgICAgICAnIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBlbnVtZXJhdGlvbiBTY3JvbGxCZWhhdmlvci4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGhhcyBzY3JvbGxhYmxlIHNwYWNlIGluIHRoZSBwcm92aWRlZCBheGlzXG4gICAgICogQG1ldGhvZCBoYXNTY3JvbGxhYmxlU3BhY2VcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsIGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09PSAnWScpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsaWVudEhlaWdodCArIFJPVU5ESU5HX1RPTEVSQU5DRSA8IGVsLnNjcm9sbEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgPT09ICdYJykge1xuICAgICAgICByZXR1cm4gZWwuY2xpZW50V2lkdGggKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxXaWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgYSBzY3JvbGxhYmxlIG92ZXJmbG93IHByb3BlcnR5IGluIHRoZSBheGlzXG4gICAgICogQG1ldGhvZCBjYW5PdmVyZmxvd1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbk92ZXJmbG93KGVsLCBheGlzKSB7XG4gICAgICB2YXIgb3ZlcmZsb3dWYWx1ZSA9IHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbClbJ292ZXJmbG93JyArIGF4aXNdO1xuXG4gICAgICByZXR1cm4gb3ZlcmZsb3dWYWx1ZSA9PT0gJ2F1dG8nIHx8IG92ZXJmbG93VmFsdWUgPT09ICdzY3JvbGwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGNhbiBiZSBzY3JvbGxlZCBpbiBlaXRoZXIgYXhpc1xuICAgICAqIEBtZXRob2QgaXNTY3JvbGxhYmxlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsKSB7XG4gICAgICB2YXIgaXNTY3JvbGxhYmxlWSA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1knKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1knKTtcbiAgICAgIHZhciBpc1Njcm9sbGFibGVYID0gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCAnWCcpICYmIGNhbk92ZXJmbG93KGVsLCAnWCcpO1xuXG4gICAgICByZXR1cm4gaXNTY3JvbGxhYmxlWSB8fCBpc1Njcm9sbGFibGVYO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmRzIHNjcm9sbGFibGUgcGFyZW50IG9mIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIGZpbmRTY3JvbGxhYmxlUGFyZW50XG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEByZXR1cm5zIHtOb2RlfSBlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRTY3JvbGxhYmxlUGFyZW50KGVsKSB7XG4gICAgICB3aGlsZSAoZWwgIT09IGQuYm9keSAmJiBpc1Njcm9sbGFibGUoZWwpID09PSBmYWxzZSkge1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGUgfHwgZWwuaG9zdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlbGYgaW52b2tlZCBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIGNvbnRleHQsIHN0ZXBzIHRocm91Z2ggc2Nyb2xsaW5nXG4gICAgICogQG1ldGhvZCBzdGVwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0ZXAoY29udGV4dCkge1xuICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgIHZhciBjdXJyZW50WTtcbiAgICAgIHZhciBlbGFwc2VkID0gKHRpbWUgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBTQ1JPTExfVElNRTtcblxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXG4gICAgICB2YWx1ZSA9IGVhc2UoZWxhcHNlZCk7XG5cbiAgICAgIGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgICBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICBjb250ZXh0Lm1ldGhvZC5jYWxsKGNvbnRleHQuc2Nyb2xsYWJsZSwgY3VycmVudFgsIGN1cnJlbnRZKTtcblxuICAgICAgLy8gc2Nyb2xsIG1vcmUgaWYgd2UgaGF2ZSBub3QgcmVhY2hlZCBvdXIgZGVzdGluYXRpb25cbiAgICAgIGlmIChjdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcbiAgICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcC5iaW5kKHcsIGNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzY3JvbGxzIHdpbmRvdyBvciBlbGVtZW50IHdpdGggYSBzbW9vdGggYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHNtb290aFNjcm9sbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5vZGV9IGVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc21vb3RoU2Nyb2xsKGVsLCB4LCB5KSB7XG4gICAgICB2YXIgc2Nyb2xsYWJsZTtcbiAgICAgIHZhciBzdGFydFg7XG4gICAgICB2YXIgc3RhcnRZO1xuICAgICAgdmFyIG1ldGhvZDtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBub3coKTtcblxuICAgICAgLy8gZGVmaW5lIHNjcm9sbCBjb250ZXh0XG4gICAgICBpZiAoZWwgPT09IGQuYm9keSkge1xuICAgICAgICBzY3JvbGxhYmxlID0gdztcbiAgICAgICAgc3RhcnRYID0gdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQ7XG4gICAgICAgIHN0YXJ0WSA9IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0O1xuICAgICAgICBtZXRob2QgPSBvcmlnaW5hbC5zY3JvbGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxhYmxlID0gZWw7XG4gICAgICAgIHN0YXJ0WCA9IGVsLnNjcm9sbExlZnQ7XG4gICAgICAgIHN0YXJ0WSA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbWV0aG9kID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gc2Nyb2xsIGxvb3Bpbmcgb3ZlciBhIGZyYW1lXG4gICAgICBzdGVwKHtcbiAgICAgICAgc2Nyb2xsYWJsZTogc2Nyb2xsYWJsZSxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE9SSUdJTkFMIE1FVEhPRFMgT1ZFUlJJREVTXG4gICAgLy8gdy5zY3JvbGwgYW5kIHcuc2Nyb2xsVG9cbiAgICB3LnNjcm9sbCA9IHcuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbC5jYWxsKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgICA6IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgIC8vIHVzZSB0b3AgcHJvcCwgc2Vjb25kIGFyZ3VtZW50IGlmIHByZXNlbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsWVxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gYXJndW1lbnRzWzFdXG4gICAgICAgICAgICAgIDogdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXRcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICA6IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0LFxuICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgIDogdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXRcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHcuc2Nyb2xsQnlcbiAgICB3LnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxCeS5jYWxsKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JyA/IGFyZ3VtZW50c1swXSA6IDAsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgKHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0KSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0udG9wICsgKHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIGFuZCBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUb1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCA9IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBpZiBvbmUgbnVtYmVyIGlzIHBhc3NlZCwgdGhyb3cgZXJyb3IgdG8gbWF0Y2ggRmlyZWZveCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1ZhbHVlIGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIC8vIHVzZSBsZWZ0IHByb3AsIGZpcnN0IG51bWJlciBhcmd1bWVudCBvciBmYWxsYmFjayB0byBzY3JvbGxMZWZ0XG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnID8gfn5hcmd1bWVudHNbMF0gOiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgLy8gdXNlIHRvcCBwcm9wLCBzZWNvbmQgYXJndW1lbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsVG9wXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IH5+YXJndW1lbnRzWzFdIDogdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gYXJndW1lbnRzWzBdLmxlZnQ7XG4gICAgICB2YXIgdG9wID0gYXJndW1lbnRzWzBdLnRvcDtcblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsTGVmdCA6IH5+bGVmdCxcbiAgICAgICAgdHlwZW9mIHRvcCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbFRvcCA6IH5+dG9wXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeVxuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5lbGVtZW50U2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnRcbiAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMF0gKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcCArIHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICAgICA6IH5+YXJndW1lbnRzWzFdICsgdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsKHtcbiAgICAgICAgbGVmdDogfn5hcmd1bWVudHNbMF0ubGVmdCArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgdG9wOiB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcCxcbiAgICAgICAgYmVoYXZpb3I6IGFyZ3VtZW50c1swXS5iZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsSW50b1ZpZXcuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgdmFyIHNjcm9sbGFibGVQYXJlbnQgPSBmaW5kU2Nyb2xsYWJsZVBhcmVudCh0aGlzKTtcbiAgICAgIHZhciBwYXJlbnRSZWN0cyA9IHNjcm9sbGFibGVQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY2xpZW50UmVjdHMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoc2Nyb2xsYWJsZVBhcmVudCAhPT0gZC5ib2R5KSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluc2lkZSBwYXJlbnRcbiAgICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsTGVmdCArIGNsaWVudFJlY3RzLmxlZnQgLSBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsVG9wICsgY2xpZW50UmVjdHMudG9wIC0gcGFyZW50UmVjdHMudG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcmV2ZWFsIHBhcmVudCBpbiB2aWV3cG9ydCB1bmxlc3MgaXMgZml4ZWRcbiAgICAgICAgaWYgKHcuZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxhYmxlUGFyZW50KS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgICAgbGVmdDogcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICAgIHRvcDogcGFyZW50UmVjdHMudG9wLFxuICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBjbGllbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY29tbW9uanNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgcG9seWZpbGw6IHBvbHlmaWxsIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2xvYmFsXG4gICAgcG9seWZpbGwoKTtcbiAgfVxuXG59KCkpO1xuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQgeyBFdmVudGVkIH0gZnJvbSAnLi9ldmVudGVkLmpzJztcbmltcG9ydCBhdXRvQmluZCBmcm9tICcuL3V0aWxzL2F1dG8tYmluZC5qcyc7XG5pbXBvcnQge1xuICBpc0VsZW1lbnQsXG4gIGlzSFRNTEVsZW1lbnQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzVW5kZWZpbmVkXG59IGZyb20gJy4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5pbXBvcnQgeyBiaW5kQWR2YW5jZSB9IGZyb20gJy4vdXRpbHMvYmluZC5qcyc7XG5pbXBvcnQge1xuICBzZXR1cFRvb2x0aXAsXG4gIHBhcnNlQXR0YWNoVG8sXG4gIG5vcm1hbGl6ZVByZWZpeCxcbiAgdXVpZFxufSBmcm9tICcuL3V0aWxzL2dlbmVyYWwuanMnO1xuaW1wb3J0IFNoZXBoZXJkRWxlbWVudCBmcm9tICcuL2NvbXBvbmVudHMvc2hlcGhlcmQtZWxlbWVudC5zdmVsdGUnO1xuXG4vLyBQb2x5ZmlsbHNcbmltcG9ydCBzbW9vdGhzY3JvbGwgZnJvbSAnc21vb3Roc2Nyb2xsLXBvbHlmaWxsJztcbnNtb290aHNjcm9sbC5wb2x5ZmlsbCgpO1xuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIHN0ZXBzIHRvIGJlIGFkZGVkIHRvIGEgdG91ci5cbiAqIEBleHRlbmRzIHtFdmVudGVkfVxuICovXG5leHBvcnQgY2xhc3MgU3RlcCBleHRlbmRzIEV2ZW50ZWQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgc3RlcFxuICAgKiBAcGFyYW0ge1RvdXJ9IHRvdXIgVGhlIHRvdXIgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYXJyb3cgV2hldGhlciB0byBkaXNwbGF5IHRoZSBhcnJvdyBmb3IgdGhlIHRvb2x0aXAgb3Igbm90LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmF0dGFjaFRvIFRoZSBlbGVtZW50IHRoZSBzdGVwIHNob3VsZCBiZSBhdHRhY2hlZCB0byBvbiB0aGUgcGFnZS5cbiAgICogQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBgZWxlbWVudGAgYW5kIGBvbmAuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0ZXAgPSBuZXcgU3RlcCh0b3VyLCB7XG4gICAqICAgYXR0YWNoVG86IHsgZWxlbWVudDogJy5zb21lIC5zZWxlY3Rvci1wYXRoJywgb246ICdsZWZ0JyB9LFxuICAgKiAgIC4uLm1vcmVPcHRpb25zXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IGRvbuKAmXQgc3BlY2lmeSBhbiBgYXR0YWNoVG9gIHRoZSBlbGVtZW50IHdpbGwgYXBwZWFyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi4gVGhlIHNhbWUgd2lsbCBoYXBwZW4gaWYgeW91ciBgYXR0YWNoVG8uZWxlbWVudGAgY2FsbGJhY2sgcmV0dXJucyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvciBhIHNlbGVjdG9yIHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIERPTS5cbiAgICogSWYgeW91IG9taXQgdGhlIGBvbmAgcG9ydGlvbiBvZiBgYXR0YWNoVG9gLCB0aGUgZWxlbWVudCB3aWxsIHN0aWxsIGJlIGhpZ2hsaWdodGVkLCBidXQgdGhlIHRvb2x0aXAgd2lsbCBhcHBlYXJcbiAgICogaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLCB3aXRob3V0IGFuIGFycm93IHBvaW50aW5nIHRvIHRoZSB0YXJnZXQuXG4gICAqIElmIHRoZSBlbGVtZW50IHRvIGhpZ2hsaWdodCBkb2VzIG5vdCB5ZXQgZXhpc3Qgd2hpbGUgaW5zdGFudGlhdGluZyB0b3VyIHN0ZXBzLCB5b3UgbWF5IHVzZSBsYXp5IGV2YWx1YXRpb24gYnkgc3VwcGx5aW5nIGEgZnVuY3Rpb24gdG8gYGF0dGFjaFRvLmVsZW1lbnRgLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGBiZWZvcmUtc2hvd2AgcGhhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fGZ1bmN0aW9ufSBvcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgQW4gZWxlbWVudCBzZWxlY3RvciBzdHJpbmcsIERPTSBlbGVtZW50LCBvciBhIGZ1bmN0aW9uIChyZXR1cm5pbmcgYSBzZWxlY3RvciwgYSBET00gZWxlbWVudCwgYG51bGxgIG9yIGB1bmRlZmluZWRgKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXR0YWNoVG8ub24gVGhlIG9wdGlvbmFsIGRpcmVjdGlvbiB0byBwbGFjZSB0aGUgUG9wcGVyIHRvb2x0aXAgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQuXG4gICAqICAgLSBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzOiAnYXV0bycsICdhdXRvLXN0YXJ0JywgJ2F1dG8tZW5kJywgJ3RvcCcsICd0b3Atc3RhcnQnLCAndG9wLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnLCAncmlnaHQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCcsICdsZWZ0LWVuZCdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYWR2YW5jZU9uIEFuIGFjdGlvbiBvbiB0aGUgcGFnZSB3aGljaCBzaG91bGQgYWR2YW5jZSBzaGVwaGVyZCB0byB0aGUgbmV4dCBzdGVwLlxuICAgKiBJdCBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggYSBzdHJpbmcgYHNlbGVjdG9yYCBhbmQgYW4gYGV2ZW50YCBuYW1lXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0ZXAgPSBuZXcgU3RlcCh0b3VyLCB7XG4gICAqICAgYWR2YW5jZU9uOiB7IHNlbGVjdG9yOiAnLnNvbWUgLnNlbGVjdG9yLXBhdGgnLCBldmVudDogJ2NsaWNrJyB9LFxuICAgKiAgIC4uLm1vcmVPcHRpb25zXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGV2ZW50YCBkb2VzbuKAmXQgaGF2ZSB0byBiZSBhbiBldmVudCBpbnNpZGUgdGhlIHRvdXIsIGl0IGNhbiBiZSBhbnkgZXZlbnQgZmlyZWQgb24gYW55IGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gICAqIFlvdSBjYW4gYWxzbyBhbHdheXMgbWFudWFsbHkgYWR2YW5jZSB0aGUgVG91ciBieSBjYWxsaW5nIGBteVRvdXIubmV4dCgpYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gICAqIFdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHRoZSByZXN0IG9mIHRoZSBgc2hvd2AgY29kZSBmb3IgdGhlIHN0ZXAgd2lsbCBleGVjdXRlLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRpb25zLmJ1dHRvbnMgQW4gYXJyYXkgb2YgYnV0dG9ucyB0byBhZGQgdG8gdGhlIHN0ZXAuIFRoZXNlIHdpbGwgYmUgcmVuZGVyZWQgaW4gYVxuICAgKiBmb290ZXIgYmVsb3cgdGhlIG1haW4gYm9keSB0ZXh0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmFjdGlvbiBBIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIG9uLlxuICAgKiBJdCBpcyBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZSBgdG91cmAgdGhlIHN0ZXAgaXMgYXNzb2NpYXRlZCB3aXRoLCBzbyB0aGluZ3MgbGlrZSBgdGhpcy5uZXh0YCB3aWxsXG4gICAqIHdvcmsgaW5zaWRlIHRoZSBhY3Rpb24uXG4gICAqIFlvdSBjYW4gdXNlIGFjdGlvbiB0byBza2lwIHN0ZXBzIG9yIG5hdmlnYXRlIHRvIHNwZWNpZmljIHN0ZXBzLCB3aXRoIHNvbWV0aGluZyBsaWtlOlxuICAgKiBgYGBqc1xuICAgKiBhY3Rpb24oKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuc2hvdygnc29tZV9zdGVwX25hbWUnKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uY2xhc3NlcyBFeHRyYSBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBgPGE+YFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uZGlzYWJsZWQgU2hvdWxkIHRoZSBidXR0b24gYmUgZGlzYWJsZWQ/XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmxhYmVsIFRoZSBhcmlhLWxhYmVsIHRleHQgb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uc2Vjb25kYXJ5IElmIHRydWUsIGEgc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeSBjbGFzcyBpcyBhcHBsaWVkIHRvIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24udGV4dCBUaGUgSFRNTCB0ZXh0IG9mIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNhbkNsaWNrVGFyZ2V0IEEgYm9vbGVhbiwgdGhhdCB3aGVuIHNldCB0byBmYWxzZSwgd2lsbCBzZXQgYHBvaW50ZXItZXZlbnRzOiBub25lYCBvbiB0aGUgdGFyZ2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNhbmNlbEljb24gT3B0aW9ucyBmb3IgdGhlIGNhbmNlbCBpY29uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQgU2hvdWxkIGEgY2FuY2VsIOKAnOKcleKAnSBiZSBzaG93biBpbiB0aGUgaGVhZGVyIG9mIHRoZSBzdGVwP1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYW5jZWxJY29uLmxhYmVsIFRoZSBsYWJlbCB0byBhZGQgZm9yIGBhcmlhLWxhYmVsYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbGFzc2VzIEEgc3RyaW5nIG9mIGV4dHJhIGNsYXNzZXMgdG8gYWRkIHRvIHRoZSBzdGVwJ3MgY29udGVudCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5oaWdobGlnaHRDbGFzcyBBbiBleHRyYSBjbGFzcyB0byBhcHBseSB0byB0aGUgYGF0dGFjaFRvYCBlbGVtZW50IHdoZW4gaXQgaXNcbiAgICogaGlnaGxpZ2h0ZWQgKHRoYXQgaXMsIHdoZW4gaXRzIHN0ZXAgaXMgYWN0aXZlKS4gWW91IGNhbiB0aGVuIHRhcmdldCB0aGF0IHNlbGVjdG9yIGluIHlvdXIgQ1NTLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBUaGUgc3RyaW5nIHRvIHVzZSBhcyB0aGUgYGlkYCBmb3IgdGhlIHN0ZXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIEFuIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIEFuIGFtb3VudCBvZiBib3JkZXIgcmFkaXVzIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5wb3BwZXJPcHRpb25zIEV4dHJhIG9wdGlvbnMgdG8gcGFzcyB0byBQb3BwZXJcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gb3B0aW9ucy5zY3JvbGxUbyBTaG91bGQgdGhlIGVsZW1lbnQgYmUgc2Nyb2xsZWQgdG8gd2hlbiB0aGlzIHN0ZXAgaXMgc2hvd24/IElmIHRydWUsIHVzZXMgdGhlIGRlZmF1bHQgYHNjcm9sbEludG9WaWV3YCxcbiAgICogaWYgYW4gb2JqZWN0LCBwYXNzZXMgdGhhdCBvYmplY3QgYXMgdGhlIHBhcmFtcyB0byBgc2Nyb2xsSW50b1ZpZXdgIGkuZS4gYHtiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJ31gXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCBsZXRzIHlvdSBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY3JvbGxUbyBiZWhhdmlvciBhbmRcbiAgICogZGVmaW5lIGEgY3VzdG9tIGFjdGlvbiB0byBkbyB0aGUgc2Nyb2xsaW5nLCBhbmQgcG9zc2libHkgb3RoZXIgbG9naWMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc2hvd09uIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBpdCByZXR1cm5zIGB0cnVlYCwgd2lsbCBzaG93IHRoZSBzdGVwLlxuICAgKiBJZiBpdCByZXR1cm5zIGZhbHNlLCB0aGUgc3RlcCB3aWxsIGJlIHNraXBwZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRleHQgVGhlIHRleHQgaW4gdGhlIGJvZHkgb2YgdGhlIHN0ZXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhyZWUgdHlwZXM6XG4gICAqIGBgYFxuICAgKiAtIEhUTUwgc3RyaW5nXG4gICAqIC0gYEhUTUxFbGVtZW50YCBvYmplY3RcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIG9uZSB0aGUgdHdvIG9wdGlvbnMgYWJvdmUuXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgc3RlcCdzIHRpdGxlLiBJdCBiZWNvbWVzIGFuIGBoM2AgYXQgdGhlIHRvcCBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0d28gdHlwZXM6XG4gICAqIGBgYFxuICAgKiAtIEhUTUwgc3RyaW5nXG4gICAqIC0gYEZ1bmN0aW9uYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBzdGVwIGlzIGJ1aWx0LiBJdCBtdXN0IHJldHVybiBIVE1MIHN0cmluZy5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLndoZW4gWW91IGNhbiBkZWZpbmUgYHNob3dgLCBgaGlkZWAsIGV0YyBldmVudHMgaW5zaWRlIGB3aGVuYC4gRm9yIGV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHdoZW46IHtcbiAgICogICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICogICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBuZXdseSBjcmVhdGVkIFN0ZXAgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvdXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHRvdXIsIG9wdGlvbnMpO1xuICAgIHRoaXMudG91ciA9IHRvdXI7XG4gICAgdGhpcy5jbGFzc1ByZWZpeCA9IHRoaXMudG91ci5vcHRpb25zXG4gICAgICA/IG5vcm1hbGl6ZVByZWZpeCh0aGlzLnRvdXIub3B0aW9ucy5jbGFzc1ByZWZpeClcbiAgICAgIDogJyc7XG4gICAgdGhpcy5zdHlsZXMgPSB0b3VyLnN0eWxlcztcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGF0dGFjaFRvIG9wdGlvbnMuIER1ZSB0byBsYXp5IGV2YWx1YXRpb24sIHdlIG9ubHkgcmVzb2x2ZSB0aGUgb3B0aW9ucyBkdXJpbmcgYGJlZm9yZS1zaG93YCBwaGFzZS5cbiAgICAgKiBEbyBub3QgdXNlIHRoaXMgZGlyZWN0bHksIHVzZSB0aGUgX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIEB0eXBlIHtudWxsfHt9fHtlbGVtZW50LCB0b319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvID0gbnVsbDtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgdG91clxuICAgKiBUcmlnZ2VycyB0aGUgYGNhbmNlbGAgZXZlbnRcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLnRvdXIuY2FuY2VsKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5jZWwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgdG91clxuICAgKiBUcmlnZ2VycyB0aGUgYGNvbXBsZXRlYCBldmVudFxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy50b3VyLmNvbXBsZXRlKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgc3RlcCwgZGVsZXRlIHRoZSBzdGVwJ3MgZWxlbWVudCwgYW5kIGRlc3Ryb3kgdGhlIFBvcHBlciBpbnN0YW5jZSBmb3IgdGhlIHN0ZXAuXG4gICAqIFRyaWdnZXJzIGBkZXN0cm95YCBldmVudFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50b29sdGlwKSB7XG4gICAgICB0aGlzLnRvb2x0aXAuZGVzdHJveSgpO1xuICAgICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0aGlzLmVsKSAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdXIgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge1RvdXJ9IFRoZSB0b3VyIGluc3RhbmNlXG4gICAqL1xuICBnZXRUb3VyKCkge1xuICAgIHJldHVybiB0aGlzLnRvdXI7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgc3RlcFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvdXIubW9kYWwuaGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmUtaGlkZScpO1xuXG4gICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2hpZGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhdHRhY2hUbyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7e318e2VsZW1lbnQsIG9ufX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCkge1xuICAgIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPSBwYXJzZUF0dGFjaFRvKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2VsZWN0b3IgZm9yIHJlc29sdmVkIGF0dGFjaFRvIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zKCkge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlZEF0dGFjaFRvID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RlcCBpcyBvcGVuIGFuZCB2aXNpYmxlXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5lbCAmJiAhdGhpcy5lbC5oaWRkZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGBfc2hvd2AgYW5kIGVuc3VyZXMgYGJlZm9yZVNob3dQcm9taXNlYCByZXNvbHZlcyBiZWZvcmUgY2FsbGluZyBzaG93XG4gICAqIEByZXR1cm4geyp8UHJvbWlzZX1cbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmJlZm9yZVNob3dQcm9taXNlKSkge1xuICAgICAgY29uc3QgYmVmb3JlU2hvd1Byb21pc2UgPSB0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UoKTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQoYmVmb3JlU2hvd1Byb21pc2UpKSB7XG4gICAgICAgIHJldHVybiBiZWZvcmVTaG93UHJvbWlzZS50aGVuKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3Nob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBvcHRpb25zIG9mIHRoZSBzdGVwLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICovXG4gIHVwZGF0ZVN0ZXBPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQpIHtcbiAgICAgIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LiRzZXQoeyBzdGVwOiB0aGlzIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgaW5zdGFuY2UuIHVuZGVmaW5lZCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzaG93biwgbnVsbCBpZiBpdCBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFyZ2V0IGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgaW5zdGFuY2UuIHVuZGVmaW5lZCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzaG93biwgbnVsbCBpZiBxdWVyeSBzdHJpbmcgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAqL1xuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgU2hlcGhlcmQgZWxlbWVudCBmb3Igc3RlcCBiYXNlZCBvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBET00gZWxlbWVudCBmb3IgdGhlIHN0ZXAgdG9vbHRpcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVRvb2x0aXBDb250ZW50KCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uSWQgPSBgJHt0aGlzLmlkfS1kZXNjcmlwdGlvbmA7XG4gICAgY29uc3QgbGFiZWxJZCA9IGAke3RoaXMuaWR9LWxhYmVsYDtcblxuICAgIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50ID0gbmV3IFNoZXBoZXJkRWxlbWVudCh7XG4gICAgICB0YXJnZXQ6IHRoaXMudG91ci5vcHRpb25zLnN0ZXBzQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgZGVzY3JpcHRpb25JZCxcbiAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgc3RlcDogdGhpcyxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIGN1c3RvbSBzY3JvbGxUb0hhbmRsZXIgaXMgZGVmaW5lZCwgY2FsbCB0aGF0LCBvdGhlcndpc2UgZG8gdGhlIGdlbmVyaWNcbiAgICogc2Nyb2xsSW50b1ZpZXcgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gc2Nyb2xsVG9PcHRpb25zIElmIHRydWUsIHVzZXMgdGhlIGRlZmF1bHQgYHNjcm9sbEludG9WaWV3YCxcbiAgICogaWYgYW4gb2JqZWN0LCBwYXNzZXMgdGhhdCBvYmplY3QgYXMgdGhlIHBhcmFtcyB0byBgc2Nyb2xsSW50b1ZpZXdgIGkuZS4gYHsgYmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ2NlbnRlcicgfWBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXMuX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zKCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKSkge1xuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvSGFuZGxlcihlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNFbGVtZW50KGVsZW1lbnQpICYmXG4gICAgICB0eXBlb2YgZWxlbWVudC5zY3JvbGxJbnRvVmlldyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyhzY3JvbGxUb09wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBfZ2V0Q2xhc3NPcHRpb25zIGdldHMgYWxsIHBvc3NpYmxlIGNsYXNzZXMgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGVwT3B0aW9ucyBUaGUgc3RlcCBzcGVjaWZpYyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHVuaXF1ZSBzdHJpbmcgZnJvbSBhcnJheSBvZiBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q2xhc3NPcHRpb25zKHN0ZXBPcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zID1cbiAgICAgIHRoaXMudG91ciAmJiB0aGlzLnRvdXIub3B0aW9ucyAmJiB0aGlzLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG4gICAgY29uc3Qgc3RlcENsYXNzZXMgPSBzdGVwT3B0aW9ucy5jbGFzc2VzID8gc3RlcE9wdGlvbnMuY2xhc3NlcyA6ICcnO1xuICAgIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMgPVxuICAgICAgZGVmYXVsdFN0ZXBPcHRpb25zICYmIGRlZmF1bHRTdGVwT3B0aW9ucy5jbGFzc2VzXG4gICAgICAgID8gZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgOiAnJztcbiAgICBjb25zdCBhbGxDbGFzc2VzID0gW1xuICAgICAgLi4uc3RlcENsYXNzZXMuc3BsaXQoJyAnKSxcbiAgICAgIC4uLmRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMuc3BsaXQoJyAnKVxuICAgIF07XG4gICAgY29uc3QgdW5pcUNsYXNzZXMgPSBuZXcgU2V0KGFsbENsYXNzZXMpO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20odW5pcUNsYXNzZXMpLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXAsIG1hcHMgYHdoZW5gIHRvIGV2ZW50cywgc2V0cyB1cCBidXR0b25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHRvdXJPcHRpb25zID1cbiAgICAgIHRoaXMudG91ciAmJiB0aGlzLnRvdXIub3B0aW9ucyAmJiB0aGlzLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG5cbiAgICB0b3VyT3B0aW9ucyA9IG1lcmdlKHt9LCB0b3VyT3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBhcnJvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRvdXJPcHRpb25zLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICBjb25zdCB7IHdoZW4gfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMub3B0aW9ucy5jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZCB8fCBgc3RlcC0ke3V1aWQoKX1gO1xuXG4gICAgaWYgKHdoZW4pIHtcbiAgICAgIE9iamVjdC5rZXlzKHdoZW4pLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMub24oZXZlbnQsIHdoZW5bZXZlbnRdLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGVsZW1lbnQgYW5kIHNldCB1cCB0aGUgUG9wcGVyIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBFbGVtZW50cygpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuZWwpKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsID0gdGhpcy5fY3JlYXRlVG9vbHRpcENvbnRlbnQoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWR2YW5jZU9uKSB7XG4gICAgICBiaW5kQWR2YW5jZSh0aGlzKTtcbiAgICB9XG4gICAgc2V0dXBUb29sdGlwKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGBiZWZvcmUtc2hvd2AsIGdlbmVyYXRlcyB0aGUgdG9vbHRpcCBET00gY29udGVudCxcbiAgICogc2V0cyB1cCBhIFBvcHBlciBpbnN0YW5jZSBmb3IgdGhlIHRvb2x0aXAsIHRoZW4gdHJpZ2dlcnMgYHNob3dgLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3coKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmUtc2hvdycpO1xuXG4gICAgLy8gRm9yY2UgcmVzb2x2ZSB0byBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgYXJlIHVwZGF0ZWQgb24gc3Vic2VxdWVudCBzaG93cy5cbiAgICB0aGlzLl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCk7XG4gICAgdGhpcy5fc2V0dXBFbGVtZW50cygpO1xuXG4gICAgaWYgKCF0aGlzLnRvdXIubW9kYWwpIHtcbiAgICAgIHRoaXMudG91ci5fc2V0dXBNb2RhbCgpO1xuICAgIH1cblxuICAgIHRoaXMudG91ci5tb2RhbC5zZXR1cEZvclN0ZXAodGhpcyk7XG4gICAgdGhpcy5fc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgLy8gc3RhcnQgc2Nyb2xsaW5nIHRvIHRhcmdldCBiZWZvcmUgc2hvd2luZyB0aGUgc3RlcFxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG8pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLm9wdGlvbnMuc2Nyb2xsVG8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbC5oaWRkZW4gPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLWVuYWJsZWRgKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLXRhcmdldGApO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtZW5hYmxlZCcpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XG4gIH1cblxuICAvKipcbiAgICogTW9kdWxhdGVzIHRoZSBzdHlsZXMgb2YgdGhlIHBhc3NlZCBzdGVwJ3MgdGFyZ2V0IGVsZW1lbnQsIGJhc2VkIG9uIHRoZSBzdGVwJ3Mgb3B0aW9ucyBhbmRcbiAgICogdGhlIHRvdXIncyBgbW9kYWxgIG9wdGlvbiwgdG8gdmlzdWFsbHkgZW1waGFzaXplIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBzdGVwIFRoZSBzdGVwIG9iamVjdCB0aGF0IGF0dGFjaGVzIHRvIHRoZSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHN0ZXAudGFyZ2V0O1xuXG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKHN0ZXAub3B0aW9ucy5oaWdobGlnaHRDbGFzcyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcblxuICAgIGlmIChzdGVwLm9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgPT09IGZhbHNlKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgc3RlcCBpcyBoaWRkZW4sIHJlbW92ZSB0aGUgaGlnaGxpZ2h0Q2xhc3MgYW5kICdzaGVwaGVyZC1lbmFibGVkJ1xuICAgKiBhbmQgJ3NoZXBoZXJkLXRhcmdldCcgY2xhc3Nlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5oaWdobGlnaHRDbGFzcyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyxcbiAgICAgIGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtZW5hYmxlZGAsXG4gICAgICBgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLXRhcmdldGBcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIENsZWFudXAgdGhlIHN0ZXBzIGFuZCBzZXQgcG9pbnRlckV2ZW50cyBiYWNrIHRvICdhdXRvJ1xuICogQHBhcmFtIHRvdXIgVGhlIHRvdXIgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwU3RlcHModG91cikge1xuICBpZiAodG91cikge1xuICAgIGNvbnN0IHsgc3RlcHMgfSA9IHRvdXI7XG5cbiAgICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0ZXAub3B0aW9ucyAmJlxuICAgICAgICBzdGVwLm9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgPT09IGZhbHNlICYmXG4gICAgICAgIHN0ZXAub3B0aW9ucy5hdHRhY2hUb1xuICAgICAgKSB7XG4gICAgICAgIGlmIChzdGVwLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgc3RlcC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIHN2ZyBwYXRoIGRhdGEgZm9yIGEgcm91bmRlZCByZWN0YW5nbGUgb3ZlcmxheVxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbiAtIERpbWVuc2lvbnMgb2YgcmVjdGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gT2Zmc2V0IGZyb20gdG9wIGxlZnQgY29ybmVyIGluIHggYXhpcy4gZGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gT2Zmc2V0IGZyb20gdG9wIGxlZnQgY29ybmVyIGluIHkgYXhpcy4gZGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyPTBdIC0gQ29ybmVyIFJhZGl1cy4gS2VlcCB0aGlzIHNtYWxsZXIgdGhhbiAgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFJvdW5kZWQgcmVjdGFuZ2xlIG92ZXJsYXkgcGF0aCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU92ZXJsYXlQYXRoKHsgd2lkdGgsIGhlaWdodCwgeCA9IDAsIHkgPSAwLCByID0gMCB9KSB7XG4gIGNvbnN0IHsgaW5uZXJXaWR0aDogdywgaW5uZXJIZWlnaHQ6IGggfSA9IHdpbmRvdztcblxuICByZXR1cm4gYE0ke3d9LCR7aH1cXFxuSDBcXFxuVjBcXFxuSCR7d31cXFxuViR7aH1cXFxuWlxcXG5NJHt4ICsgcn0sJHt5fVxcXG5hJHtyfSwke3J9LDAsMCwwLSR7cn0sJHtyfVxcXG5WJHtoZWlnaHQgKyB5IC0gcn1cXFxuYSR7cn0sJHtyfSwwLDAsMCwke3J9LCR7cn1cXFxuSCR7d2lkdGggKyB4IC0gcn1cXFxuYSR7cn0sJHtyfSwwLDAsMCwke3J9LSR7cn1cXFxuViR7eSArIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAtJHtyfS0ke3J9XFxcblpgO1xufVxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgdXVpZCB9IGZyb20gJy4uL3V0aWxzL2dlbmVyYWwuanMnO1xuICBpbXBvcnQgeyBtYWtlT3ZlcmxheVBhdGggfSBmcm9tICcuLi91dGlscy9vdmVybGF5LXBhdGguanMnO1xuXG4gIGV4cG9ydCBsZXQgZWxlbWVudCwgb3BlbmluZ1Byb3BlcnRpZXM7XG4gIGNvbnN0IGd1aWQgPSB1dWlkKCk7XG4gIGxldCBtb2RhbElzVmlzaWJsZSA9IGZhbHNlO1xuICBsZXQgcmFmSWQgPSB1bmRlZmluZWQ7XG4gIGxldCBwYXRoRGVmaW5pdGlvbjtcblxuICAkOiBwYXRoRGVmaW5pdGlvbiA9IG1ha2VPdmVybGF5UGF0aChvcGVuaW5nUHJvcGVydGllcyk7XG5cbiAgY2xvc2VNb2RhbE9wZW5pbmcoKTtcblxuICBleHBvcnQgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGNsb3NlTW9kYWxPcGVuaW5nKCkge1xuICAgIG9wZW5pbmdQcm9wZXJ0aWVzID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHI6IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIG1vZGFsIG92ZXJsYXlcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBoaWRlKCkge1xuICAgIG1vZGFsSXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAvLyBFbnN1cmUgd2UgY2xlYW51cCBhbGwgZXZlbnQgbGlzdGVuZXJzIHdoZW4gd2UgaGlkZSB0aGUgbW9kYWxcbiAgICBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZXMgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudCB3ZSB3YW50IHRoZSBvcGVuaW5nIG92ZXJ0b3Agb2YgdG8gc2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvcGVuaW5nIGFuZCBwb3NpdGlvbiBpdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgQW4gYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIEFuIGFtb3VudCBvZiBib3JkZXIgcmFkaXVzIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzY3JvbGxQYXJlbnQgVGhlIHNjcm9sbGFibGUgcGFyZW50IG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRoZSBvcGVuaW5nIHdpbGwgZXhwb3NlXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcG9zaXRpb25Nb2RhbChcbiAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyA9IDAsXG4gICAgbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyA9IDAsXG4gICAgc2Nyb2xsUGFyZW50LFxuICAgIHRhcmdldEVsZW1lbnRcbiAgKSB7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgeSwgaGVpZ2h0IH0gPSBfZ2V0VmlzaWJsZUhlaWdodCh0YXJnZXRFbGVtZW50LCBzY3JvbGxQYXJlbnQpO1xuICAgICAgY29uc3QgeyB4LCB3aWR0aCwgbGVmdCB9ID0gdGFyZ2V0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIG5vdCBjb25zaXN0ZW50LiBTb21lIGJyb3dzZXJzIHVzZSB4IGFuZCB5LCB3aGlsZSBvdGhlcnMgdXNlIGxlZnQgYW5kIHRvcFxuICAgICAgb3BlbmluZ1Byb3BlcnRpZXMgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCArIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nICogMixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyAqIDIsXG4gICAgICAgIHg6ICh4IHx8IGxlZnQpIC0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIHk6IHkgLSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgcjogbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1c1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VNb2RhbE9wZW5pbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgbW9kYWwgaXMgZW5hYmxlZCwgc2V0dXAgdGhlIHN2ZyBtYXNrIG9wZW5pbmcgYW5kIG1vZGFsIG92ZXJsYXkgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNldHVwRm9yU3RlcChzdGVwKSB7XG4gICAgLy8gRW5zdXJlIHdlIG1vdmUgbGlzdGVuZXJzIGZyb20gdGhlIHByZXZpb3VzIHN0ZXAsIGJlZm9yZSB3ZSBzZXR1cCBuZXcgb25lc1xuICAgIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBpZiAoc3RlcC50b3VyLm9wdGlvbnMudXNlTW9kYWxPdmVybGF5KSB7XG4gICAgICBfc3R5bGVGb3JTdGVwKHN0ZXApO1xuICAgICAgc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIG1vZGFsIG92ZXJsYXlcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzaG93KCkge1xuICAgIG1vZGFsSXNWaXNpYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IF9wcmV2ZW50TW9kYWxCb2R5VG91Y2ggPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBjb25zdCBfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoID0gKGUpID0+IHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdG91Y2htb3ZlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkU3RlcEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIC8vIFByZXZlbnRzIHdpbmRvdyBmcm9tIG1vdmluZyBvbiB0b3VjaC5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBsb29wIGFuZCByZW1vdmUgdG91Y2htb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHJhZklkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICByYWZJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZSB0aGUgbW9kYWwgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCB0byBzdHlsZSB0aGUgb3BlbmluZyBmb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9zdHlsZUZvclN0ZXAoc3RlcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1c1xuICAgIH0gPSBzdGVwLm9wdGlvbnM7XG5cbiAgICBjb25zdCBzY3JvbGxQYXJlbnQgPSBfZ2V0U2Nyb2xsUGFyZW50KHN0ZXAudGFyZ2V0KTtcblxuICAgIC8vIFNldHVwIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0byBjYWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0byB1cGRhdGUgdGhlIG1vZGFsIG9wZW5pbmcgcG9zaXRpb25cbiAgICBjb25zdCByYWZMb29wID0gKCkgPT4ge1xuICAgICAgcmFmSWQgPSB1bmRlZmluZWQ7XG4gICAgICBwb3NpdGlvbk1vZGFsKFxuICAgICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyxcbiAgICAgICAgc2Nyb2xsUGFyZW50LFxuICAgICAgICBzdGVwLnRhcmdldFxuICAgICAgKTtcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkxvb3ApO1xuICAgIH07XG5cbiAgICByYWZMb29wKCk7XG5cbiAgICBfYWRkU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIHBhcmVudCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgaXNIdG1sRWxlbWVudCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICBjb25zdCBvdmVyZmxvd1kgPVxuICAgICAgaXNIdG1sRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5vdmVyZmxvd1k7XG4gICAgY29uc3QgaXNTY3JvbGxhYmxlID0gb3ZlcmZsb3dZICE9PSAnaGlkZGVuJyAmJiBvdmVyZmxvd1kgIT09ICd2aXNpYmxlJztcblxuICAgIGlmIChpc1Njcm9sbGFibGUgJiYgZWxlbWVudC5zY3JvbGxIZWlnaHQgPj0gZWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aXNpYmxlIGhlaWdodCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIHNjcm9sbFBhcmVudC5cbiAgICogSWYgdGhlcmUgaXMgbm8gc2Nyb2xsIHBhcmVudCwgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3Njcm9sbFBhcmVudF0gVGhlIHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHJldHVybnMge3t5OiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRWaXNpYmxlSGVpZ2h0KGVsZW1lbnQsIHNjcm9sbFBhcmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgdG9wID0gZWxlbWVudFJlY3QueSB8fCBlbGVtZW50UmVjdC50b3A7XG4gICAgbGV0IGJvdHRvbSA9IGVsZW1lbnRSZWN0LmJvdHRvbSB8fCB0b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQ7XG5cbiAgICBpZiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBjb25zdCBzY3JvbGxSZWN0ID0gc2Nyb2xsUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC55IHx8IHNjcm9sbFJlY3QudG9wO1xuICAgICAgY29uc3Qgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gfHwgc2Nyb2xsVG9wICsgc2Nyb2xsUmVjdC5oZWlnaHQ7XG5cbiAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgc2Nyb2xsVG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgc2Nyb2xsQm90dG9tKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChib3R0b20gLSB0b3AsIDApOyAvLyBEZWZhdWx0IHRvIDAgaWYgaGVpZ2h0IGlzIG5lZ2F0aXZlXG5cbiAgICByZXR1cm4geyB5OiB0b3AsIGhlaWdodCB9O1xuICB9XG48L3NjcmlwdD5cblxuPHN2Z1xuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzPXtgJHtcbiAgICBtb2RhbElzVmlzaWJsZSA/ICdzaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlJyA6ICcnXG4gIH0gc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXJgfVxuICBvbjp0b3VjaG1vdmU9e19wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2h9XG4+XG4gIDxwYXRoIGQ9e3BhdGhEZWZpbml0aW9ufSAvPlxuPC9zdmc+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgb3BhY2l0eTogMDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZS1vdXQsIGhlaWdodCAwbXMgMC4zcywgb3BhY2l0eSAwLjNzIDBtcztcbiAgICB3aWR0aDogMTAwdnc7XG4gICAgei1pbmRleDogOTk5NztcbiAgfVxuXG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lci5zaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlIHtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIG9wYWNpdHk6IDAuNTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dCwgaGVpZ2h0IDBzIDBzLCBvcGFjaXR5IDAuM3MgMHM7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUgcGF0aCB7XG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcbiAgfVxuPC9zdHlsZT5cbiIsImltcG9ydCB7IEV2ZW50ZWQgfSBmcm9tICcuL2V2ZW50ZWQuanMnO1xuaW1wb3J0IHsgU3RlcCB9IGZyb20gJy4vc3RlcC5qcyc7XG5pbXBvcnQgYXV0b0JpbmQgZnJvbSAnLi91dGlscy9hdXRvLWJpbmQuanMnO1xuaW1wb3J0IHtcbiAgaXNIVE1MRWxlbWVudCxcbiAgaXNGdW5jdGlvbixcbiAgaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkXG59IGZyb20gJy4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5pbXBvcnQgeyBjbGVhbnVwU3RlcHMgfSBmcm9tICcuL3V0aWxzL2NsZWFudXAuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplUHJlZml4LCB1dWlkIH0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCBTaGVwaGVyZE1vZGFsIGZyb20gJy4vY29tcG9uZW50cy9zaGVwaGVyZC1tb2RhbC5zdmVsdGUnO1xuXG5jb25zdCBTaGVwaGVyZCA9IG5ldyBFdmVudGVkKCk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBzaXRlIHRvdXJcbiAqIEBleHRlbmRzIHtFdmVudGVkfVxuICovXG5leHBvcnQgY2xhc3MgVG91ciBleHRlbmRzIEV2ZW50ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jb25maXJtQ2FuY2VsIElmIHRydWUsIHdpbGwgaXNzdWUgYSBgd2luZG93LmNvbmZpcm1gIGJlZm9yZSBjYW5jZWxsaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNvbmZpcm1DYW5jZWxNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGRpc3BsYXkgaW4gdGhlIGNvbmZpcm0gZGlhbG9nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsYXNzUHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBgc2hlcGhlcmQtZW5hYmxlZGAgYW5kIGBzaGVwaGVyZC10YXJnZXRgIGNsYXNzIG5hbWVzIGFzIHdlbGwgYXMgdGhlIGBkYXRhLXNoZXBoZXJkLXN0ZXAtaWRgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnMgRGVmYXVsdCBvcHRpb25zIGZvciBTdGVwcyAoe0BsaW5rIFN0ZXAjY29uc3RydWN0b3J9KSwgY3JlYXRlZCB0aHJvdWdoIGBhZGRTdGVwYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZXhpdE9uRXNjIEV4aXRpbmcgdGhlIHRvdXIgd2l0aCB0aGUgZXNjYXBlIGtleSB3aWxsIGJlIGVuYWJsZWQgdW5sZXNzIHRoaXMgaXMgZXhwbGljaXRseVxuICAgKiBzZXQgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24gTmF2aWdhdGluZyB0aGUgdG91ciB2aWEgbGVmdCBhbmQgcmlnaHQgYXJyb3cga2V5cyB3aWxsIGJlIGVuYWJsZWRcbiAgICogdW5sZXNzIHRoaXMgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuc3RlcHNDb250YWluZXIgQW4gb3B0aW9uYWwgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBzdGVwcy5cbiAgICogSWYgbm90IHNldCwgdGhlIHN0ZXBzIHdpbGwgYmUgYXBwZW5kZWQgdG8gYGRvY3VtZW50LmJvZHlgLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLm1vZGFsQ29udGFpbmVyIEFuIG9wdGlvbmFsIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgbW9kYWwuXG4gICAqIElmIG5vdCBzZXQsIHRoZSBtb2RhbCB3aWxsIGJlIGFwcGVuZGVkIHRvIGBkb2N1bWVudC5ib2R5YC5cbiAgICogQHBhcmFtIHtvYmplY3RbXSB8IFN0ZXBbXX0gb3B0aW9ucy5zdGVwcyBBbiBhcnJheSBvZiBzdGVwIG9wdGlvbnMgb2JqZWN0cyBvciBTdGVwIGluc3RhbmNlcyB0byBpbml0aWFsaXplIHRoZSB0b3VyIHdpdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG91ck5hbWUgQW4gb3B0aW9uYWwgXCJuYW1lXCIgZm9yIHRoZSB0b3VyLiBUaGlzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHRoZSB0b3VyJ3NcbiAgICogZHluYW1pY2FsbHkgZ2VuZXJhdGVkIGBpZGAgcHJvcGVydHkgLS0gd2hpY2ggaXMgYWxzbyBzZXQgb24gdGhlIGBib2R5YCBlbGVtZW50IGFzIHRoZSBgZGF0YS1zaGVwaGVyZC1hY3RpdmUtdG91cmAgYXR0cmlidXRlXG4gICAqIHdoZW5ldmVyIHRoZSB0b3VyIGJlY29tZXMgYWN0aXZlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudXNlTW9kYWxPdmVybGF5IFdoZXRoZXIgb3Igbm90IHN0ZXBzIHNob3VsZCBiZSBwbGFjZWQgYWJvdmUgYSBkYXJrZW5lZFxuICAgKiBtb2RhbCBvdmVybGF5LiBJZiB0cnVlLCB0aGUgb3ZlcmxheSB3aWxsIGNyZWF0ZSBhbiBvcGVuaW5nIGFyb3VuZCB0aGUgdGFyZ2V0IGVsZW1lbnQgc28gdGhhdCBpdFxuICAgKiBjYW4gcmVtYWluIGludGVyYWN0aXZlXG4gICAqIEByZXR1cm5zIHtUb3VyfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICBhdXRvQmluZCh0aGlzKTtcblxuICAgIGNvbnN0IGRlZmF1bHRUb3VyT3B0aW9ucyA9IHtcbiAgICAgIGV4aXRPbkVzYzogdHJ1ZSxcbiAgICAgIGtleWJvYXJkTmF2aWdhdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VG91ck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSBub3JtYWxpemVQcmVmaXgodGhpcy5vcHRpb25zLmNsYXNzUHJlZml4KTtcbiAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgdGhpcy5hZGRTdGVwcyh0aGlzLm9wdGlvbnMuc3RlcHMpO1xuXG4gICAgLy8gUGFzcyB0aGVzZSBldmVudHMgb250byB0aGUgZ2xvYmFsIFNoZXBoZXJkIG9iamVjdFxuICAgIGNvbnN0IGV2ZW50cyA9IFtcbiAgICAgICdhY3RpdmUnLFxuICAgICAgJ2NhbmNlbCcsXG4gICAgICAnY29tcGxldGUnLFxuICAgICAgJ2luYWN0aXZlJyxcbiAgICAgICdzaG93JyxcbiAgICAgICdzdGFydCdcbiAgICBdO1xuICAgIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiB7XG4gICAgICAoKGUpID0+IHtcbiAgICAgICAgdGhpcy5vbihlLCAob3B0cykgPT4ge1xuICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgIG9wdHMudG91ciA9IHRoaXM7XG4gICAgICAgICAgU2hlcGhlcmQudHJpZ2dlcihlLCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KShldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXRUb3VySUQoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgc3RlcCB0byB0aGUgdG91clxuICAgKiBAcGFyYW0ge09iamVjdHxTdGVwfSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHN0ZXAgb3B0aW9ucyBvciBhIFN0ZXAgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBvcHRpb25hbCBpbmRleCB0byBpbnNlcnQgdGhlIHN0ZXAgYXQuIElmIHVuZGVmaW5lZCwgdGhlIHN0ZXBcbiAgICogaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBuZXdseSBhZGRlZCBzdGVwXG4gICAqL1xuICBhZGRTdGVwKG9wdGlvbnMsIGluZGV4KSB7XG4gICAgbGV0IHN0ZXAgPSBvcHRpb25zO1xuXG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFN0ZXApKSB7XG4gICAgICBzdGVwID0gbmV3IFN0ZXAodGhpcywgc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXAudG91ciA9IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChpbmRleCkpIHtcbiAgICAgIHRoaXMuc3RlcHMuc3BsaWNlKGluZGV4LCAwLCBzdGVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgIH1cblxuICAgIHJldHVybiBzdGVwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBtdWx0aXBsZSBzdGVwcyB0byB0aGUgdG91clxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD4gfCBBcnJheTxTdGVwPn0gc3RlcHMgVGhlIHN0ZXBzIHRvIGFkZCB0byB0aGUgdG91clxuICAgKi9cbiAgYWRkU3RlcHMoc3RlcHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwcykpIHtcbiAgICAgIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gdGhlIHByZXZpb3VzIHN0ZXAgaW4gdGhlIHRvdXJcbiAgICovXG4gIGJhY2soKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG4gICAgdGhpcy5zaG93KGluZGV4IC0gMSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIF9kb25lKCkgdHJpZ2dlcmluZyB0aGUgJ2NhbmNlbCcgZXZlbnRcbiAgICogSWYgYGNvbmZpcm1DYW5jZWxgIGlzIHRydWUsIHdpbGwgc2hvdyBhIHdpbmRvdy5jb25maXJtIGJlZm9yZSBjYW5jZWxsaW5nXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25maXJtQ2FuY2VsKSB7XG4gICAgICBjb25zdCBjYW5jZWxNZXNzYWdlID1cbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWxNZXNzYWdlIHx8XG4gICAgICAgICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gc3RvcCB0aGUgdG91cj8nO1xuICAgICAgY29uc3Qgc3RvcFRvdXIgPSB3aW5kb3cuY29uZmlybShjYW5jZWxNZXNzYWdlKTtcbiAgICAgIGlmIChzdG9wVG91cikge1xuICAgICAgICB0aGlzLl9kb25lKCdjYW5jZWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZG9uZSgnY2FuY2VsJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIF9kb25lKCkgdHJpZ2dlcmluZyB0aGUgYGNvbXBsZXRlYCBldmVudFxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy5fZG9uZSgnY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGVwIGZyb20gYSBnaXZlbiBpZFxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgc3RlcCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgc3RlcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBgaWRgXG4gICAqL1xuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMuZmluZCgoc3RlcCkgPT4ge1xuICAgICAgcmV0dXJuIHN0ZXAuaWQgPT09IGlkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RlcFxuICAgKiBAcmV0dXJucyB7U3RlcHxudWxsfVxuICAgKi9cbiAgZ2V0Q3VycmVudFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXA7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgY3VycmVudCBzdGVwXG4gICAqL1xuICBoaWRlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpO1xuXG4gICAgaWYgKGN1cnJlbnRTdGVwKSB7XG4gICAgICByZXR1cm4gY3VycmVudFN0ZXAuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdG91ciBpcyBhY3RpdmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiBTaGVwaGVyZC5hY3RpdmVUb3VyID09PSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHRvdXJcbiAgICogSWYgd2UgYXJlIGF0IHRoZSBlbmQsIGNhbGwgYGNvbXBsZXRlYFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdyhpbmRleCArIDEsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzdGVwIGZyb20gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGlkIGZvciB0aGUgc3RlcCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVN0ZXAobmFtZSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCk7XG5cbiAgICAvLyBGaW5kIHRoZSBzdGVwLCBkZXN0cm95IGl0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGlzLnN0ZXBzXG4gICAgdGhpcy5zdGVwcy5zb21lKChzdGVwLCBpKSA9PiB7XG4gICAgICBpZiAoc3RlcC5pZCA9PT0gbmFtZSkge1xuICAgICAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgICAgIHN0ZXAuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RlcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RlcHMuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pZCA9PT0gbmFtZSkge1xuICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBzdGVwcyBsZWZ0LCBzaG93IHRoZSBmaXJzdCBvbmUsIG90aGVyd2lzZSBqdXN0IGNhbmNlbCB0aGUgdG91clxuICAgICAgdGhpcy5zdGVwcy5sZW5ndGggPyB0aGlzLnNob3coMCkgOiB0aGlzLmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGEgc3BlY2lmaWMgc3RlcCBpbiB0aGUgdG91clxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleSBUaGUga2V5IHRvIGxvb2sgdXAgdGhlIHN0ZXAgYnlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3J3YXJkIFRydWUgaWYgd2UgYXJlIGdvaW5nIGZvcndhcmQsIGZhbHNlIGlmIGJhY2t3YXJkXG4gICAqL1xuICBzaG93KGtleSA9IDAsIGZvcndhcmQgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3RlcCA9IGlzU3RyaW5nKGtleSkgPyB0aGlzLmdldEJ5SWQoa2V5KSA6IHRoaXMuc3RlcHNba2V5XTtcblxuICAgIGlmIChzdGVwKSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZUJlZm9yZVNob3coKTtcblxuICAgICAgY29uc3Qgc2hvdWxkU2tpcFN0ZXAgPVxuICAgICAgICBpc0Z1bmN0aW9uKHN0ZXAub3B0aW9ucy5zaG93T24pICYmICFzdGVwLm9wdGlvbnMuc2hvd09uKCk7XG5cbiAgICAgIC8vIElmIGBzaG93T25gIHJldHVybnMgZmFsc2UsIHdlIHdhbnQgdG8gc2tpcCB0aGUgc3RlcCwgb3RoZXJ3aXNlLCBzaG93IHRoZSBzdGVwIGxpa2Ugbm9ybWFsXG4gICAgICBpZiAoc2hvdWxkU2tpcFN0ZXApIHtcbiAgICAgICAgdGhpcy5fc2tpcFN0ZXAoc3RlcCwgZm9yd2FyZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnLCB7XG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgICBwcmV2aW91czogdGhpcy5jdXJyZW50U3RlcFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gc3RlcDtcbiAgICAgICAgc3RlcC5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSB0b3VyXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N0YXJ0Jyk7XG5cbiAgICAvLyBTYXZlIHRoZSBmb2N1c2VkIGVsZW1lbnQgYmVmb3JlIHRoZSB0b3VyIG9wZW5zXG4gICAgdGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSBudWxsO1xuXG4gICAgdGhpcy5fc2V0dXBNb2RhbCgpO1xuXG4gICAgdGhpcy5fc2V0dXBBY3RpdmVUb3VyKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0b3VyIGlzIGNhbmNlbGxlZCBvciBjb21wbGV0ZWQsIGJhc2ljYWxseSBhbnl0aW1lIHdlIGV4aXQgdGhlIHRvdXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lIHRvIHRyaWdnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kb25lKGV2ZW50KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdGVwcykpIHtcbiAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4gc3RlcC5kZXN0cm95KCkpO1xuICAgIH1cblxuICAgIGNsZWFudXBTdGVwcyh0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcihldmVudCwgeyBpbmRleCB9KTtcblxuICAgIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlcignaW5hY3RpdmUnLCB7IHRvdXI6IHRoaXMgfSk7XG5cbiAgICBpZiAodGhpcy5tb2RhbCkge1xuICAgICAgdGhpcy5tb2RhbC5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ID09PSAnY2FuY2VsJyB8fCBldmVudCA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgICAgY29uc3QgbW9kYWxDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXInXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1vZGFsQ29udGFpbmVyKSB7XG4gICAgICAgICAgbW9kYWxDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgdG91ciBzdGFydGVkXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuKSkge1xuICAgICAgdGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyB0b3VyIFwiYWN0aXZlXCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEFjdGl2ZVRvdXIoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdhY3RpdmUnLCB7IHRvdXI6IHRoaXMgfSk7XG5cbiAgICBTaGVwaGVyZC5hY3RpdmVUb3VyID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBfc2V0dXBNb2RhbCBjcmVhdGUgdGhlIG1vZGFsIGNvbnRhaW5lciBhbmQgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cE1vZGFsKCkge1xuICAgIHRoaXMubW9kYWwgPSBuZXcgU2hlcGhlcmRNb2RhbCh7XG4gICAgICB0YXJnZXQ6IHRoaXMub3B0aW9ucy5tb2RhbENvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xhc3NQcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXgsXG4gICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBgc2hvd09uYCBldmFsdWF0ZXMgdG8gZmFsc2UsIHRvIHNraXAgdGhlIHN0ZXAgb3IgY29tcGxldGUgdGhlIHRvdXIgaWYgaXQncyB0aGUgbGFzdCBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCB0byBza2lwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yd2FyZCBUcnVlIGlmIHdlIGFyZSBnb2luZyBmb3J3YXJkLCBmYWxzZSBpZiBiYWNrd2FyZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NraXBTdGVwKHN0ZXAsIGZvcndhcmQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZihzdGVwKTtcblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5leHRJbmRleCA9IGZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG4gICAgICB0aGlzLnNob3cobmV4dEluZGV4LCBmb3J3YXJkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIHNob3dpbmcsIGhpZGUgdGhlIGN1cnJlbnQgc3RlcCBhbmQgaWYgdGhlIHRvdXIgaXMgbm90XG4gICAqIGFscmVhZHkgYWN0aXZlLCBjYWxsIGB0aGlzLl9zZXR1cEFjdGl2ZVRvdXJgLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U3RlcCkge1xuICAgICAgdGhpcy5jdXJyZW50U3RlcC5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX3NldHVwQWN0aXZlVG91cigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMuaWQgdG8gYCR7dG91ck5hbWV9LS0ke3V1aWR9YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFRvdXJJRCgpIHtcbiAgICBjb25zdCB0b3VyTmFtZSA9IHRoaXMub3B0aW9ucy50b3VyTmFtZSB8fCAndG91cic7XG5cbiAgICB0aGlzLmlkID0gYCR7dG91ck5hbWV9LS0ke3V1aWQoKX1gO1xuICB9XG59XG5cbmV4cG9ydCB7IFNoZXBoZXJkIH07XG4iLCJpbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwLmpzJztcbmltcG9ydCB7IFNoZXBoZXJkLCBUb3VyIH0gZnJvbSAnLi90b3VyLmpzJztcblxuT2JqZWN0LmFzc2lnbihTaGVwaGVyZCwgeyBUb3VyLCBTdGVwIH0pO1xuXG5leHBvcnQgZGVmYXVsdCBTaGVwaGVyZDtcbiJdLCJuYW1lcyI6WyJpc01lcmdlYWJsZU9iamVjdCIsInZhbHVlIiwiaXNOb25OdWxsT2JqZWN0IiwiaXNTcGVjaWFsIiwic3RyaW5nVmFsdWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIiQkdHlwZW9mIiwiZW1wdHlUYXJnZXQiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsIm9wdGlvbnMiLCJjbG9uZSIsImRlZXBtZXJnZSIsImRlZmF1bHRBcnJheU1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwiY29uY2F0IiwibWFwIiwiZWxlbWVudCIsImdldE1lcmdlRnVuY3Rpb24iLCJrZXkiLCJjdXN0b21NZXJnZSIsImdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJzeW1ib2wiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldEtleXMiLCJrZXlzIiwicHJvcGVydHlJc09uT2JqZWN0Iiwib2JqZWN0IiwicHJvcGVydHkiLCJfIiwicHJvcGVydHlJc1Vuc2FmZSIsImhhc093blByb3BlcnR5IiwibWVyZ2VPYmplY3QiLCJkZXN0aW5hdGlvbiIsImZvckVhY2giLCJhcnJheU1lcmdlIiwic291cmNlSXNBcnJheSIsInRhcmdldElzQXJyYXkiLCJzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoIiwiYWxsIiwiZGVlcG1lcmdlQWxsIiwiYXJyYXkiLCJFcnJvciIsInJlZHVjZSIsInByZXYiLCJuZXh0IiwiZGVlcG1lcmdlXzEiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNGdW5jdGlvbiIsImlzU3RyaW5nIiwiaXNVbmRlZmluZWQiLCJ1bmRlZmluZWQiLCJFdmVudGVkIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJjdHgiLCJvbmNlIiwiYmluZGluZ3MiLCJwdXNoIiwib2ZmIiwiYmluZGluZyIsImluZGV4Iiwic3BsaWNlIiwidHJpZ2dlciIsImFyZ3MiLCJjb250ZXh0IiwiYXBwbHkiLCJhdXRvQmluZCIsInNlbGYiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29uc3RydWN0b3IiLCJpIiwibGVuZ3RoIiwiYmluZCIsIl9zZXR1cEFkdmFuY2VPbkhhbmRsZXIiLCJzZWxlY3RvciIsInN0ZXAiLCJpc09wZW4iLCJ0YXJnZXRJc0VsIiwiZWwiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0SXNTZWxlY3RvciIsIm1hdGNoZXMiLCJ0b3VyIiwiYmluZEFkdmFuY2UiLCJhZHZhbmNlT24iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJlIiwiY29uc29sZSIsImVycm9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJib2R5IiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJsZWZ0IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJlbmQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInJlZmVyZW5jZSIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJnZXROb2RlTmFtZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJub2RlIiwid2luZG93Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiT3duRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJhcHBseVN0eWxlcyIsIl9yZWYiLCJzdGF0ZSIsImVsZW1lbnRzIiwibmFtZSIsInN0eWxlIiwic3R5bGVzIiwiYXR0cmlidXRlcyIsImFzc2lnbiIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImVmZmVjdCIsIl9yZWYyIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwic3RyYXRlZ3kiLCJtYXJnaW4iLCJhcnJvdyIsInN0eWxlUHJvcGVydGllcyIsImF0dHJpYnV0ZSIsImVuYWJsZWQiLCJwaGFzZSIsImZuIiwicmVxdWlyZXMiLCJnZXRCYXNlUGxhY2VtZW50Iiwic3BsaXQiLCJtYXgiLCJNYXRoIiwibWluIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbmNsdWRlU2NhbGUiLCJyZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwiZ2V0TGF5b3V0UmVjdCIsImNsaWVudFJlY3QiLCJhYnMiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJpc1NhbWVOb2RlIiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNUYWJsZUVsZW1lbnQiLCJpbmRleE9mIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImdldE9mZnNldFBhcmVudCIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsIndpdGhpbiIsIm1hdGhNYXgiLCJtYXRoTWluIiwid2l0aGluTWF4Q2xhbXAiLCJ2IiwiZ2V0RnJlc2hTaWRlT2JqZWN0IiwibWVyZ2VQYWRkaW5nT2JqZWN0IiwicGFkZGluZ09iamVjdCIsImV4cGFuZFRvSGFzaE1hcCIsImhhc2hNYXAiLCJ0b1BhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwicmVjdHMiLCJfc3RhdGUkbW9kaWZpZXJzRGF0YSQiLCJhcnJvd0VsZW1lbnQiLCJwb3BwZXJPZmZzZXRzIiwibW9kaWZpZXJzRGF0YSIsImJhc2VQbGFjZW1lbnQiLCJheGlzIiwiaXNWZXJ0aWNhbCIsImxlbiIsImFycm93UmVjdCIsIm1pblByb3AiLCJtYXhQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNsaWVudEhlaWdodCIsImNsaWVudFdpZHRoIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJjZW50ZXIiLCJvZmZzZXQiLCJheGlzUHJvcCIsImNlbnRlck9mZnNldCIsIl9vcHRpb25zJGVsZW1lbnQiLCJyZXF1aXJlc0lmRXhpc3RzIiwiZ2V0VmFyaWF0aW9uIiwidW5zZXRTaWRlcyIsInJvdW5kT2Zmc2V0c0J5RFBSIiwid2luIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1hcFRvU3R5bGVzIiwiX09iamVjdCRhc3NpZ24yIiwicG9wcGVyUmVjdCIsInZhcmlhdGlvbiIsIm9mZnNldHMiLCJncHVBY2NlbGVyYXRpb24iLCJhZGFwdGl2ZSIsInJvdW5kT2Zmc2V0cyIsImlzRml4ZWQiLCJfb2Zmc2V0cyR4IiwiX29mZnNldHMkeSIsIl9yZWYzIiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsIm9mZnNldFkiLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldFgiLCJjb21tb25TdHlsZXMiLCJfcmVmNCIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY1IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJkYXRhIiwicGFzc2l2ZSIsImluc3RhbmNlIiwiX29wdGlvbnMkc2Nyb2xsIiwic2Nyb2xsIiwiX29wdGlvbnMkcmVzaXplIiwicmVzaXplIiwic2Nyb2xsUGFyZW50cyIsInNjcm9sbFBhcmVudCIsInVwZGF0ZSIsImhhc2giLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGwiLCJzY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXRWaWV3cG9ydFJlY3QiLCJodG1sIiwidGVzdCIsImdldERvY3VtZW50UmVjdCIsIl9lbGVtZW50JG93bmVyRG9jdW1lbiIsIndpblNjcm9sbCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiZGlyZWN0aW9uIiwiaXNTY3JvbGxQYXJlbnQiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0U2Nyb2xsUGFyZW50IiwibGlzdFNjcm9sbFBhcmVudHMiLCJsaXN0IiwiaXNCb2R5IiwidXBkYXRlZExpc3QiLCJyZWN0VG9DbGllbnRSZWN0IiwiZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRUb3AiLCJjbGllbnRMZWZ0IiwiZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUiLCJjbGlwcGluZ1BhcmVudCIsImdldENsaXBwaW5nUGFyZW50cyIsImNhbkVzY2FwZUNsaXBwaW5nIiwiY2xpcHBlckVsZW1lbnQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsIm1haW5DbGlwcGluZ1BhcmVudHMiLCJmaXJzdENsaXBwaW5nUGFyZW50IiwiY2xpcHBpbmdSZWN0IiwiYWNjUmVjdCIsImNvbXB1dGVPZmZzZXRzIiwiY29tbW9uWCIsImNvbW1vblkiLCJtYWluQXhpcyIsImRldGVjdE92ZXJmbG93IiwiX29wdGlvbnMiLCJfb3B0aW9ucyRwbGFjZW1lbnQiLCJfb3B0aW9ucyRib3VuZGFyeSIsIl9vcHRpb25zJHJvb3RCb3VuZGFyeSIsIl9vcHRpb25zJGVsZW1lbnRDb250ZSIsImVsZW1lbnRDb250ZXh0IiwiX29wdGlvbnMkYWx0Qm91bmRhcnkiLCJhbHRCb3VuZGFyeSIsIl9vcHRpb25zJHBhZGRpbmciLCJhbHRDb250ZXh0IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiY29udGV4dEVsZW1lbnQiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm11bHRpcGx5IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsImFsbFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50cyIsIm92ZXJmbG93cyIsInNvcnQiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwic2V0IiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsIl9pIiwiZml0dGluZ1BsYWNlbWVudCIsImZpbmQiLCJnZXQiLCJzbGljZSIsIl9yZXQiLCJyZXNldCIsImdldFNpZGVPZmZzZXRzIiwicHJldmVudGVkT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJzaWRlIiwiaGlkZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJnZXRBbHRBeGlzIiwiX29wdGlvbnMkdGV0aGVyIiwidGV0aGVyIiwiX29wdGlvbnMkdGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUiLCJvZmZzZXRNb2RpZmllclN0YXRlIiwiX29mZnNldE1vZGlmaWVyU3RhdGUkIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIiwiX21haW5TaWRlIiwiX2FsdFNpZGUiLCJfb2Zmc2V0IiwiX2xlbiIsIl9taW4iLCJfbWF4IiwiaXNPcmlnaW5TaWRlIiwiX29mZnNldE1vZGlmaWVyVmFsdWUiLCJfdGV0aGVyTWluIiwiX3RldGhlck1heCIsIl9wcmV2ZW50ZWRPZmZzZXQiLCJnZXRIVE1MRWxlbWVudFNjcm9sbCIsImdldE5vZGVTY3JvbGwiLCJpc0VsZW1lbnRTY2FsZWQiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFBhcmVudElzU2NhbGVkIiwib3JkZXIiLCJtb2RpZmllcnMiLCJ2aXNpdGVkIiwiU2V0IiwicmVzdWx0IiwibW9kaWZpZXIiLCJhZGQiLCJkZXAiLCJoYXMiLCJkZXBNb2RpZmllciIsIm9yZGVyTW9kaWZpZXJzIiwib3JkZXJlZE1vZGlmaWVycyIsImRlYm91bmNlIiwicGVuZGluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiY3VycmVudCIsImV4aXN0aW5nIiwiREVGQVVMVF9PUFRJT05TIiwiYXJlVmFsaWRFbGVtZW50cyIsImFyZ3VtZW50cyIsIl9rZXkiLCJwb3BwZXJHZW5lcmF0b3IiLCJnZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYiLCJkZWZhdWx0TW9kaWZpZXJzIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmMiIsImRlZmF1bHRPcHRpb25zIiwiY3JlYXRlUG9wcGVyIiwiZWZmZWN0Q2xlYW51cEZucyIsImlzRGVzdHJveWVkIiwic2V0T3B0aW9ucyIsInNldE9wdGlvbnNBY3Rpb24iLCJjbGVhbnVwTW9kaWZpZXJFZmZlY3RzIiwibSIsInJ1bk1vZGlmaWVyRWZmZWN0cyIsImZvcmNlVXBkYXRlIiwiX3N0YXRlJGVsZW1lbnRzIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiX3JlZjMkb3B0aW9ucyIsImNsZWFudXBGbiIsIm5vb3BGbiIsImV2ZW50TGlzdGVuZXJzIiwiX2dldENlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllciIsImdlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyIiwic2V0VGltZW91dCIsImZvY3VzT3B0aW9ucyIsInByZXZlbnRTY3JvbGwiLCJmb2N1cyIsIm1ha2VDZW50ZXJlZFBvcHBlciIsImNlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllciIsInBvcHBlck9wdGlvbnMiLCJmcm9tIiwibm9ybWFsaXplUHJlZml4IiwicHJlZml4IiwiY2hhckF0IiwicGFyc2VBdHRhY2hUbyIsImF0dGFjaFRvIiwicmV0dXJuT3B0cyIsInNob3VsZENlbnRlclN0ZXAiLCJyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyIsInNldHVwVG9vbHRpcCIsInRvb2x0aXAiLCJhdHRhY2hUb09wdGlvbnMiLCJfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJnZXRQb3BwZXJPcHRpb25zIiwiY29udGVudCIsInNoZXBoZXJkRWxlbWVudENvbXBvbmVudCIsImdldEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJ1dWlkIiwiZCIsIkRhdGUiLCJub3ciLCJjIiwiciIsInJhbmRvbSIsImZsb29yIiwiZGVmYXVsdFN0ZXBPcHRpb25zIiwiX21lcmdlTW9kaWZpZXJzIiwic3RlcE9wdGlvbnMiLCJtZXJnZWRQb3BwZXJPcHRpb25zIiwibmFtZXMiLCJtb2QiLCJmaWx0ZXJlZE1vZGlmaWVycyIsImluY2x1ZGVzIiwibm9vcCIsInRhciIsInNyYyIsImsiLCJydW4iLCJibGFua19vYmplY3QiLCJjcmVhdGUiLCJydW5fYWxsIiwiZm5zIiwiaXNfZnVuY3Rpb24iLCJ0aGluZyIsInNhZmVfbm90X2VxdWFsIiwiaXNfZW1wdHkiLCJvYmoiLCJhcHBlbmQiLCJhcHBlbmRDaGlsZCIsImluc2VydCIsImFuY2hvciIsImluc2VydEJlZm9yZSIsImRldGFjaCIsInJlbW92ZUNoaWxkIiwiZGVzdHJveV9lYWNoIiwiaXRlcmF0aW9ucyIsImRldGFjaGluZyIsImNyZWF0ZUVsZW1lbnQiLCJzdmdfZWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInRleHQiLCJjcmVhdGVUZXh0Tm9kZSIsInNwYWNlIiwiZW1wdHkiLCJsaXN0ZW4iLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwic2V0X2F0dHJpYnV0ZXMiLCJkZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJfX3Byb3RvX18iLCJjc3NUZXh0IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwidG9nZ2xlX2NsYXNzIiwidG9nZ2xlIiwiY3VycmVudF9jb21wb25lbnQiLCJzZXRfY3VycmVudF9jb21wb25lbnQiLCJjb21wb25lbnQiLCJnZXRfY3VycmVudF9jb21wb25lbnQiLCJvbk1vdW50IiwiJCQiLCJvbl9tb3VudCIsImFmdGVyVXBkYXRlIiwiYWZ0ZXJfdXBkYXRlIiwiZGlydHlfY29tcG9uZW50cyIsImJpbmRpbmdfY2FsbGJhY2tzIiwicmVuZGVyX2NhbGxiYWNrcyIsImZsdXNoX2NhbGxiYWNrcyIsInJlc29sdmVkX3Byb21pc2UiLCJ1cGRhdGVfc2NoZWR1bGVkIiwic2NoZWR1bGVfdXBkYXRlIiwiZmx1c2giLCJhZGRfcmVuZGVyX2NhbGxiYWNrIiwic2Vlbl9jYWxsYmFja3MiLCJmbHVzaGlkeCIsInNhdmVkX2NvbXBvbmVudCIsInBvcCIsImNhbGxiYWNrIiwiY2xlYXIiLCJmcmFnbWVudCIsImJlZm9yZV91cGRhdGUiLCJkaXJ0eSIsInAiLCJvdXRyb2luZyIsIm91dHJvcyIsImdyb3VwX291dHJvcyIsImNoZWNrX291dHJvcyIsInRyYW5zaXRpb25faW4iLCJibG9jayIsImxvY2FsIiwiZGVsZXRlIiwidHJhbnNpdGlvbl9vdXQiLCJvIiwiZ2V0X3NwcmVhZF91cGRhdGUiLCJsZXZlbHMiLCJ1cGRhdGVzIiwidG9fbnVsbF9vdXQiLCJhY2NvdW50ZWRfZm9yIiwiJCRzY29wZSIsIm4iLCJjcmVhdGVfY29tcG9uZW50IiwibW91bnRfY29tcG9uZW50IiwiY3VzdG9tRWxlbWVudCIsIm9uX2Rlc3Ryb3kiLCJuZXdfb25fZGVzdHJveSIsImRlc3Ryb3lfY29tcG9uZW50IiwibWFrZV9kaXJ0eSIsImZpbGwiLCJpbml0IiwiY3JlYXRlX2ZyYWdtZW50Iiwibm90X2VxdWFsIiwicHJvcHMiLCJhcHBlbmRfc3R5bGVzIiwicGFyZW50X2NvbXBvbmVudCIsImJvdW5kIiwib25fZGlzY29ubmVjdCIsImNhbGxiYWNrcyIsInNraXBfYm91bmQiLCJyb290IiwicmVhZHkiLCJyZXQiLCJoeWRyYXRlIiwibm9kZXMiLCJsIiwiaW50cm8iLCJTdmVsdGVDb21wb25lbnQiLCIkZGVzdHJveSIsIiRvbiIsInR5cGUiLCIkc2V0IiwiJCRwcm9wcyIsIiQkc2V0IiwiYWN0aW9uIiwiY2xhc3NlcyIsImRpc2FibGVkIiwibGFiZWwiLCJzZWNvbmRhcnkiLCJvcHRpb24iLCIkJGludmFsaWRhdGUiLCJjb25maWciLCJnZXRDb25maWdPcHRpb24iLCJjcmVhdGVfaWZfYmxvY2siLCIkIiwiYnV0dG9ucyIsImhhbmRsZUNhbmNlbENsaWNrIiwicHJldmVudERlZmF1bHQiLCJjYW5jZWwiLCJsYWJlbElkIiwidGl0bGUiLCJpbm5lckhUTUwiLCJjcmVhdGVfaWZfYmxvY2tfMSIsImNhbmNlbEljb24iLCJkZXNjcmlwdGlvbklkIiwiY2xhc3NOYW1lIiwiZmlyc3RGb2N1c2FibGVFbGVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJsYXN0Rm9jdXNhYmxlRWxlbWVudCIsImRhdGFTdGVwSWQiLCJoYXNDYW5jZWxJY29uIiwiaGFzVGl0bGUiLCJjbGFzc1ByZWZpeCIsImlkIiwicXVlcnlTZWxlY3RvckFsbCIsInVwZGF0ZUR5bmFtaWNDbGFzc2VzIiwicmVtb3ZlQ2xhc3NlcyIsImFkZENsYXNzZXMiLCJvbGRDbGFzc2VzIiwiZ2V0Q2xhc3Nlc0FycmF5IiwicmVtb3ZlIiwibmV3Q2xhc3NlcyIsImhhbmRsZUtleURvd24iLCJrZXlDb2RlIiwiS0VZX1RBQiIsInNoaWZ0S2V5IiwiYWN0aXZlRWxlbWVudCIsIktFWV9FU0MiLCJleGl0T25Fc2MiLCJMRUZUX0FSUk9XIiwia2V5Ym9hcmROYXZpZ2F0aW9uIiwiYmFjayIsIlJJR0hUX0FSUk9XIiwicG9seWZpbGwiLCJ3IiwiX19mb3JjZVNtb290aFNjcm9sbFBvbHlmaWxsX18iLCJTQ1JPTExfVElNRSIsIm9yaWdpbmFsIiwic2Nyb2xsVG8iLCJzY3JvbGxCeSIsImVsZW1lbnRTY3JvbGwiLCJzY3JvbGxFbGVtZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJwZXJmb3JtYW5jZSIsImlzTWljcm9zb2Z0QnJvd3NlciIsInVzZXJBZ2VudFBhdHRlcm5zIiwiUmVnRXhwIiwiam9pbiIsIlJPVU5ESU5HX1RPTEVSQU5DRSIsImVhc2UiLCJjb3MiLCJQSSIsInNob3VsZEJhaWxPdXQiLCJmaXJzdEFyZyIsImJlaGF2aW9yIiwiVHlwZUVycm9yIiwiaGFzU2Nyb2xsYWJsZVNwYWNlIiwiY2FuT3ZlcmZsb3ciLCJvdmVyZmxvd1ZhbHVlIiwiaXNTY3JvbGxhYmxlIiwiaXNTY3JvbGxhYmxlWSIsImlzU2Nyb2xsYWJsZVgiLCJmaW5kU2Nyb2xsYWJsZVBhcmVudCIsInRpbWUiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwiZWxhcHNlZCIsInN0YXJ0VGltZSIsInN0YXJ0WCIsInN0YXJ0WSIsIm1ldGhvZCIsInNjcm9sbGFibGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzbW9vdGhTY3JvbGwiLCJzY3JvbGxYIiwic2Nyb2xsWSIsIlN5bnRheEVycm9yIiwic2Nyb2xsYWJsZVBhcmVudCIsInBhcmVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJtb2R1bGUiLCJzbW9vdGhzY3JvbGwiLCJTdGVwIiwiX3Jlc29sdmVkQXR0YWNoVG8iLCJfc2V0T3B0aW9ucyIsImNvbXBsZXRlIiwiX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUiLCJnZXRUb3VyIiwibW9kYWwiLCJoaWRkZW4iLCJfcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucyIsIkJvb2xlYW4iLCJzaG93IiwiYmVmb3JlU2hvd1Byb21pc2UiLCJfc2hvdyIsInVwZGF0ZVN0ZXBPcHRpb25zIiwiZ2V0VGFyZ2V0IiwiX2NyZWF0ZVRvb2x0aXBDb250ZW50IiwiU2hlcGhlcmRFbGVtZW50Iiwic3RlcHNDb250YWluZXIiLCJfc2Nyb2xsVG8iLCJzY3JvbGxUb09wdGlvbnMiLCJzY3JvbGxUb0hhbmRsZXIiLCJfZ2V0Q2xhc3NPcHRpb25zIiwic3RlcENsYXNzZXMiLCJkZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsInVuaXFDbGFzc2VzIiwidHJpbSIsInRvdXJPcHRpb25zIiwibWVyZ2UiLCJ3aGVuIiwiX3NldHVwRWxlbWVudHMiLCJfc2V0dXBNb2RhbCIsInNldHVwRm9yU3RlcCIsIl9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwIiwidGFyZ2V0RWxlbWVudCIsImhpZ2hsaWdodENsYXNzIiwiY2FuQ2xpY2tUYXJnZXQiLCJjbGVhbnVwU3RlcHMiLCJzdGVwcyIsIm1ha2VPdmVybGF5UGF0aCIsImlubmVyV2lkdGgiLCJoIiwiaW5uZXJIZWlnaHQiLCJpc0h0bWxFbGVtZW50IiwiX2dldFNjcm9sbFBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJfZ2V0VmlzaWJsZUhlaWdodCIsImVsZW1lbnRSZWN0Iiwic2Nyb2xsUmVjdCIsInNjcm9sbEJvdHRvbSIsIm9wZW5pbmdQcm9wZXJ0aWVzIiwicGF0aERlZmluaXRpb24iLCJjbG9zZU1vZGFsT3BlbmluZyIsIl9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzIiwicG9zaXRpb25Nb2RhbCIsIm1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIiwibW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyIsInVzZU1vZGFsT3ZlcmxheSIsIl9zdHlsZUZvclN0ZXAiLCJfcHJldmVudE1vZGFsQm9keVRvdWNoIiwiX3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaCIsInN0b3BQcm9wYWdhdGlvbiIsIl9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMiLCJyYWZJZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmFmTG9vcCIsIlNoZXBoZXJkIiwiVG91ciIsImRlZmF1bHRUb3VyT3B0aW9ucyIsImFkZFN0ZXBzIiwiZXZlbnRzIiwib3B0cyIsIl9zZXRUb3VySUQiLCJhZGRTdGVwIiwiY3VycmVudFN0ZXAiLCJjb25maXJtQ2FuY2VsIiwiY2FuY2VsTWVzc2FnZSIsImNvbmZpcm1DYW5jZWxNZXNzYWdlIiwic3RvcFRvdXIiLCJjb25maXJtIiwiX2RvbmUiLCJnZXRCeUlkIiwiZ2V0Q3VycmVudFN0ZXAiLCJpc0FjdGl2ZSIsImFjdGl2ZVRvdXIiLCJyZW1vdmVTdGVwIiwiZm9yd2FyZCIsIl91cGRhdGVTdGF0ZUJlZm9yZVNob3ciLCJzaG91bGRTa2lwU3RlcCIsInNob3dPbiIsIl9za2lwU3RlcCIsInByZXZpb3VzIiwiZm9jdXNlZEVsQmVmb3JlT3BlbiIsIl9zZXR1cEFjdGl2ZVRvdXIiLCJtb2RhbENvbnRhaW5lciIsIlNoZXBoZXJkTW9kYWwiLCJuZXh0SW5kZXgiLCJ0b3VyTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;